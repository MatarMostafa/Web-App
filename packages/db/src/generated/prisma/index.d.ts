
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model EmployeePerformance
 * 
 */
export type EmployeePerformance = $Result.DefaultSelection<Prisma.$EmployeePerformancePayload>
/**
 * Model PerformanceThreshold
 * 
 */
export type PerformanceThreshold = $Result.DefaultSelection<Prisma.$PerformanceThresholdPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model SubAccount
 * 
 */
export type SubAccount = $Result.DefaultSelection<Prisma.$SubAccountPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Qualification
 * 
 */
export type Qualification = $Result.DefaultSelection<Prisma.$QualificationPayload>
/**
 * Model EmployeeQualification
 * 
 */
export type EmployeeQualification = $Result.DefaultSelection<Prisma.$EmployeeQualificationPayload>
/**
 * Model OrderQualification
 * 
 */
export type OrderQualification = $Result.DefaultSelection<Prisma.$OrderQualificationPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model OrderAssignment
 * 
 */
export type OrderAssignment = $Result.DefaultSelection<Prisma.$OrderAssignmentPayload>
/**
 * Model Absence
 * 
 */
export type Absence = $Result.DefaultSelection<Prisma.$AbsencePayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model WorkStatistic
 * 
 */
export type WorkStatistic = $Result.DefaultSelection<Prisma.$WorkStatisticPayload>
/**
 * Model NotificationTemplate
 * 
 */
export type NotificationTemplate = $Result.DefaultSelection<Prisma.$NotificationTemplatePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationRecipient
 * 
 */
export type NotificationRecipient = $Result.DefaultSelection<Prisma.$NotificationRecipientPayload>
/**
 * Model NotificationOutbox
 * 
 */
export type NotificationOutbox = $Result.DefaultSelection<Prisma.$NotificationOutboxPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  TEAM_LEADER: 'TEAM_LEADER',
  EMPLOYEE: 'EMPLOYEE',
  HR_MANAGER: 'HR_MANAGER',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const RatingStatus: {
  EXCELLENT: 'EXCELLENT',
  GOOD: 'GOOD',
  NEEDS_IMPROVEMENT: 'NEEDS_IMPROVEMENT'
};

export type RatingStatus = (typeof RatingStatus)[keyof typeof RatingStatus]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  ACTIVE: 'ACTIVE',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const RequestStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const AssignmentStatus: {
  ASSIGNED: 'ASSIGNED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]


export const AssignmentTier: {
  PRIMARY: 'PRIMARY',
  BACKUP: 'BACKUP',
  FALLBACK: 'FALLBACK'
};

export type AssignmentTier = (typeof AssignmentTier)[keyof typeof AssignmentTier]


export const DocumentType: {
  RESUME: 'RESUME',
  ID_CARD: 'ID_CARD',
  PASSPORT: 'PASSPORT',
  CONTRACT: 'CONTRACT',
  CERTIFICATE: 'CERTIFICATE',
  WORK_EVIDENCE: 'WORK_EVIDENCE',
  PROFILE_PICTURE: 'PROFILE_PICTURE',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const AbsenceType: {
  SICK_LEAVE: 'SICK_LEAVE',
  VACATION: 'VACATION',
  PERSONAL_LEAVE: 'PERSONAL_LEAVE',
  MATERNITY_LEAVE: 'MATERNITY_LEAVE',
  PATERNITY_LEAVE: 'PATERNITY_LEAVE',
  UNPAID_LEAVE: 'UNPAID_LEAVE',
  BEREAVEMENT_LEAVE: 'BEREAVEMENT_LEAVE',
  OTHER: 'OTHER'
};

export type AbsenceType = (typeof AbsenceType)[keyof typeof AbsenceType]


export const WorkScheduleType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  CONTRACT: 'CONTRACT',
  TEMPORARY: 'TEMPORARY',
  INTERN: 'INTERN'
};

export type WorkScheduleType = (typeof WorkScheduleType)[keyof typeof WorkScheduleType]


export const TrafficLight: {
  RED: 'RED',
  YELLOW: 'YELLOW',
  GREEN: 'GREEN'
};

export type TrafficLight = (typeof TrafficLight)[keyof typeof TrafficLight]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type RatingStatus = $Enums.RatingStatus

export const RatingStatus: typeof $Enums.RatingStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

export type AssignmentTier = $Enums.AssignmentTier

export const AssignmentTier: typeof $Enums.AssignmentTier

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type AbsenceType = $Enums.AbsenceType

export const AbsenceType: typeof $Enums.AbsenceType

export type WorkScheduleType = $Enums.WorkScheduleType

export const WorkScheduleType: typeof $Enums.WorkScheduleType

export type TrafficLight = $Enums.TrafficLight

export const TrafficLight: typeof $Enums.TrafficLight

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeePerformance`: Exposes CRUD operations for the **EmployeePerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeePerformances
    * const employeePerformances = await prisma.employeePerformance.findMany()
    * ```
    */
  get employeePerformance(): Prisma.EmployeePerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceThreshold`: Exposes CRUD operations for the **PerformanceThreshold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceThresholds
    * const performanceThresholds = await prisma.performanceThreshold.findMany()
    * ```
    */
  get performanceThreshold(): Prisma.PerformanceThresholdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccount`: Exposes CRUD operations for the **SubAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccounts
    * const subAccounts = await prisma.subAccount.findMany()
    * ```
    */
  get subAccount(): Prisma.SubAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qualification`: Exposes CRUD operations for the **Qualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qualifications
    * const qualifications = await prisma.qualification.findMany()
    * ```
    */
  get qualification(): Prisma.QualificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeQualification`: Exposes CRUD operations for the **EmployeeQualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeQualifications
    * const employeeQualifications = await prisma.employeeQualification.findMany()
    * ```
    */
  get employeeQualification(): Prisma.EmployeeQualificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderQualification`: Exposes CRUD operations for the **OrderQualification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderQualifications
    * const orderQualifications = await prisma.orderQualification.findMany()
    * ```
    */
  get orderQualification(): Prisma.OrderQualificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderAssignment`: Exposes CRUD operations for the **OrderAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderAssignments
    * const orderAssignments = await prisma.orderAssignment.findMany()
    * ```
    */
  get orderAssignment(): Prisma.OrderAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.absence`: Exposes CRUD operations for the **Absence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Absences
    * const absences = await prisma.absence.findMany()
    * ```
    */
  get absence(): Prisma.AbsenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workStatistic`: Exposes CRUD operations for the **WorkStatistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkStatistics
    * const workStatistics = await prisma.workStatistic.findMany()
    * ```
    */
  get workStatistic(): Prisma.WorkStatisticDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationTemplate`: Exposes CRUD operations for the **NotificationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTemplates
    * const notificationTemplates = await prisma.notificationTemplate.findMany()
    * ```
    */
  get notificationTemplate(): Prisma.NotificationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationRecipient`: Exposes CRUD operations for the **NotificationRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationRecipients
    * const notificationRecipients = await prisma.notificationRecipient.findMany()
    * ```
    */
  get notificationRecipient(): Prisma.NotificationRecipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationOutbox`: Exposes CRUD operations for the **NotificationOutbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationOutboxes
    * const notificationOutboxes = await prisma.notificationOutbox.findMany()
    * ```
    */
  get notificationOutbox(): Prisma.NotificationOutboxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Employee: 'Employee',
    EmployeePerformance: 'EmployeePerformance',
    PerformanceThreshold: 'PerformanceThreshold',
    Department: 'Department',
    Position: 'Position',
    Customer: 'Customer',
    SubAccount: 'SubAccount',
    Order: 'Order',
    Qualification: 'Qualification',
    EmployeeQualification: 'EmployeeQualification',
    OrderQualification: 'OrderQualification',
    Assignment: 'Assignment',
    OrderAssignment: 'OrderAssignment',
    Absence: 'Absence',
    Rating: 'Rating',
    WorkStatistic: 'WorkStatistic',
    NotificationTemplate: 'NotificationTemplate',
    Notification: 'Notification',
    NotificationRecipient: 'NotificationRecipient',
    NotificationOutbox: 'NotificationOutbox',
    NotificationPreference: 'NotificationPreference',
    File: 'File',
    SystemConfig: 'SystemConfig',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "employee" | "employeePerformance" | "performanceThreshold" | "department" | "position" | "customer" | "subAccount" | "order" | "qualification" | "employeeQualification" | "orderQualification" | "assignment" | "orderAssignment" | "absence" | "rating" | "workStatistic" | "notificationTemplate" | "notification" | "notificationRecipient" | "notificationOutbox" | "notificationPreference" | "file" | "systemConfig" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      EmployeePerformance: {
        payload: Prisma.$EmployeePerformancePayload<ExtArgs>
        fields: Prisma.EmployeePerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeePerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeePerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>
          }
          findFirst: {
            args: Prisma.EmployeePerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeePerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>
          }
          findMany: {
            args: Prisma.EmployeePerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>[]
          }
          create: {
            args: Prisma.EmployeePerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>
          }
          createMany: {
            args: Prisma.EmployeePerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeePerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>[]
          }
          delete: {
            args: Prisma.EmployeePerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>
          }
          update: {
            args: Prisma.EmployeePerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>
          }
          deleteMany: {
            args: Prisma.EmployeePerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeePerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeePerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>[]
          }
          upsert: {
            args: Prisma.EmployeePerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePerformancePayload>
          }
          aggregate: {
            args: Prisma.EmployeePerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeePerformance>
          }
          groupBy: {
            args: Prisma.EmployeePerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeePerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeePerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeePerformanceCountAggregateOutputType> | number
          }
        }
      }
      PerformanceThreshold: {
        payload: Prisma.$PerformanceThresholdPayload<ExtArgs>
        fields: Prisma.PerformanceThresholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceThresholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceThresholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>
          }
          findFirst: {
            args: Prisma.PerformanceThresholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceThresholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>
          }
          findMany: {
            args: Prisma.PerformanceThresholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>[]
          }
          create: {
            args: Prisma.PerformanceThresholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>
          }
          createMany: {
            args: Prisma.PerformanceThresholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceThresholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>[]
          }
          delete: {
            args: Prisma.PerformanceThresholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>
          }
          update: {
            args: Prisma.PerformanceThresholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceThresholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceThresholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceThresholdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceThresholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceThresholdPayload>
          }
          aggregate: {
            args: Prisma.PerformanceThresholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceThreshold>
          }
          groupBy: {
            args: Prisma.PerformanceThresholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceThresholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceThresholdCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceThresholdCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      SubAccount: {
        payload: Prisma.$SubAccountPayload<ExtArgs>
        fields: Prisma.SubAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findFirst: {
            args: Prisma.SubAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          findMany: {
            args: Prisma.SubAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          create: {
            args: Prisma.SubAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          createMany: {
            args: Prisma.SubAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          delete: {
            args: Prisma.SubAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          update: {
            args: Prisma.SubAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>[]
          }
          upsert: {
            args: Prisma.SubAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountPayload>
          }
          aggregate: {
            args: Prisma.SubAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccount>
          }
          groupBy: {
            args: Prisma.SubAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Qualification: {
        payload: Prisma.$QualificationPayload<ExtArgs>
        fields: Prisma.QualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>
          }
          findFirst: {
            args: Prisma.QualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>
          }
          findMany: {
            args: Prisma.QualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>[]
          }
          create: {
            args: Prisma.QualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>
          }
          createMany: {
            args: Prisma.QualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>[]
          }
          delete: {
            args: Prisma.QualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>
          }
          update: {
            args: Prisma.QualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>
          }
          deleteMany: {
            args: Prisma.QualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QualificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>[]
          }
          upsert: {
            args: Prisma.QualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualificationPayload>
          }
          aggregate: {
            args: Prisma.QualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualification>
          }
          groupBy: {
            args: Prisma.QualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualificationCountArgs<ExtArgs>
            result: $Utils.Optional<QualificationCountAggregateOutputType> | number
          }
        }
      }
      EmployeeQualification: {
        payload: Prisma.$EmployeeQualificationPayload<ExtArgs>
        fields: Prisma.EmployeeQualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeQualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeQualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>
          }
          findFirst: {
            args: Prisma.EmployeeQualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeQualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>
          }
          findMany: {
            args: Prisma.EmployeeQualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>[]
          }
          create: {
            args: Prisma.EmployeeQualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>
          }
          createMany: {
            args: Prisma.EmployeeQualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeQualificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>[]
          }
          delete: {
            args: Prisma.EmployeeQualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>
          }
          update: {
            args: Prisma.EmployeeQualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeQualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeQualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeQualificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeQualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeQualificationPayload>
          }
          aggregate: {
            args: Prisma.EmployeeQualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeQualification>
          }
          groupBy: {
            args: Prisma.EmployeeQualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeQualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeQualificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeQualificationCountAggregateOutputType> | number
          }
        }
      }
      OrderQualification: {
        payload: Prisma.$OrderQualificationPayload<ExtArgs>
        fields: Prisma.OrderQualificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderQualificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderQualificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>
          }
          findFirst: {
            args: Prisma.OrderQualificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderQualificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>
          }
          findMany: {
            args: Prisma.OrderQualificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>[]
          }
          create: {
            args: Prisma.OrderQualificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>
          }
          createMany: {
            args: Prisma.OrderQualificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderQualificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>[]
          }
          delete: {
            args: Prisma.OrderQualificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>
          }
          update: {
            args: Prisma.OrderQualificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>
          }
          deleteMany: {
            args: Prisma.OrderQualificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderQualificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderQualificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>[]
          }
          upsert: {
            args: Prisma.OrderQualificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderQualificationPayload>
          }
          aggregate: {
            args: Prisma.OrderQualificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderQualification>
          }
          groupBy: {
            args: Prisma.OrderQualificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderQualificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderQualificationCountArgs<ExtArgs>
            result: $Utils.Optional<OrderQualificationCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      OrderAssignment: {
        payload: Prisma.$OrderAssignmentPayload<ExtArgs>
        fields: Prisma.OrderAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>
          }
          findFirst: {
            args: Prisma.OrderAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>
          }
          findMany: {
            args: Prisma.OrderAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>[]
          }
          create: {
            args: Prisma.OrderAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>
          }
          createMany: {
            args: Prisma.OrderAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>[]
          }
          delete: {
            args: Prisma.OrderAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>
          }
          update: {
            args: Prisma.OrderAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.OrderAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.OrderAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderAssignmentPayload>
          }
          aggregate: {
            args: Prisma.OrderAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderAssignment>
          }
          groupBy: {
            args: Prisma.OrderAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<OrderAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Absence: {
        payload: Prisma.$AbsencePayload<ExtArgs>
        fields: Prisma.AbsenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbsenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbsenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          findFirst: {
            args: Prisma.AbsenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbsenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          findMany: {
            args: Prisma.AbsenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>[]
          }
          create: {
            args: Prisma.AbsenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          createMany: {
            args: Prisma.AbsenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AbsenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>[]
          }
          delete: {
            args: Prisma.AbsenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          update: {
            args: Prisma.AbsenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          deleteMany: {
            args: Prisma.AbsenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbsenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AbsenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>[]
          }
          upsert: {
            args: Prisma.AbsenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          aggregate: {
            args: Prisma.AbsenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbsence>
          }
          groupBy: {
            args: Prisma.AbsenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbsenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbsenceCountArgs<ExtArgs>
            result: $Utils.Optional<AbsenceCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      WorkStatistic: {
        payload: Prisma.$WorkStatisticPayload<ExtArgs>
        fields: Prisma.WorkStatisticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkStatisticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkStatisticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>
          }
          findFirst: {
            args: Prisma.WorkStatisticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkStatisticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>
          }
          findMany: {
            args: Prisma.WorkStatisticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>[]
          }
          create: {
            args: Prisma.WorkStatisticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>
          }
          createMany: {
            args: Prisma.WorkStatisticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkStatisticCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>[]
          }
          delete: {
            args: Prisma.WorkStatisticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>
          }
          update: {
            args: Prisma.WorkStatisticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>
          }
          deleteMany: {
            args: Prisma.WorkStatisticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkStatisticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkStatisticUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>[]
          }
          upsert: {
            args: Prisma.WorkStatisticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkStatisticPayload>
          }
          aggregate: {
            args: Prisma.WorkStatisticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkStatistic>
          }
          groupBy: {
            args: Prisma.WorkStatisticGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkStatisticGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkStatisticCountArgs<ExtArgs>
            result: $Utils.Optional<WorkStatisticCountAggregateOutputType> | number
          }
        }
      }
      NotificationTemplate: {
        payload: Prisma.$NotificationTemplatePayload<ExtArgs>
        fields: Prisma.NotificationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findFirst: {
            args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findMany: {
            args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          create: {
            args: Prisma.NotificationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          createMany: {
            args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          delete: {
            args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          update: {
            args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          upsert: {
            args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          aggregate: {
            args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationTemplate>
          }
          groupBy: {
            args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationRecipient: {
        payload: Prisma.$NotificationRecipientPayload<ExtArgs>
        fields: Prisma.NotificationRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          findFirst: {
            args: Prisma.NotificationRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          findMany: {
            args: Prisma.NotificationRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>[]
          }
          create: {
            args: Prisma.NotificationRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          createMany: {
            args: Prisma.NotificationRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>[]
          }
          delete: {
            args: Prisma.NotificationRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          update: {
            args: Prisma.NotificationRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          deleteMany: {
            args: Prisma.NotificationRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationRecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>[]
          }
          upsert: {
            args: Prisma.NotificationRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          aggregate: {
            args: Prisma.NotificationRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRecipient>
          }
          groupBy: {
            args: Prisma.NotificationRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationRecipientCountAggregateOutputType> | number
          }
        }
      }
      NotificationOutbox: {
        payload: Prisma.$NotificationOutboxPayload<ExtArgs>
        fields: Prisma.NotificationOutboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationOutboxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationOutboxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>
          }
          findFirst: {
            args: Prisma.NotificationOutboxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationOutboxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>
          }
          findMany: {
            args: Prisma.NotificationOutboxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>[]
          }
          create: {
            args: Prisma.NotificationOutboxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>
          }
          createMany: {
            args: Prisma.NotificationOutboxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationOutboxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>[]
          }
          delete: {
            args: Prisma.NotificationOutboxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>
          }
          update: {
            args: Prisma.NotificationOutboxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>
          }
          deleteMany: {
            args: Prisma.NotificationOutboxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationOutboxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationOutboxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>[]
          }
          upsert: {
            args: Prisma.NotificationOutboxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationOutboxPayload>
          }
          aggregate: {
            args: Prisma.NotificationOutboxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationOutbox>
          }
          groupBy: {
            args: Prisma.NotificationOutboxGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationOutboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationOutboxCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationOutboxCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    employee?: EmployeeOmit
    employeePerformance?: EmployeePerformanceOmit
    performanceThreshold?: PerformanceThresholdOmit
    department?: DepartmentOmit
    position?: PositionOmit
    customer?: CustomerOmit
    subAccount?: SubAccountOmit
    order?: OrderOmit
    qualification?: QualificationOmit
    employeeQualification?: EmployeeQualificationOmit
    orderQualification?: OrderQualificationOmit
    assignment?: AssignmentOmit
    orderAssignment?: OrderAssignmentOmit
    absence?: AbsenceOmit
    rating?: RatingOmit
    workStatistic?: WorkStatisticOmit
    notificationTemplate?: NotificationTemplateOmit
    notification?: NotificationOmit
    notificationRecipient?: NotificationRecipientOmit
    notificationOutbox?: NotificationOutboxOmit
    notificationPreference?: NotificationPreferenceOmit
    file?: FileOmit
    systemConfig?: SystemConfigOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    manualOverrides: number
    subordinates: number
    notificationRecipients: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manualOverrides?: boolean | UserCountOutputTypeCountManualOverridesArgs
    subordinates?: boolean | UserCountOutputTypeCountSubordinatesArgs
    notificationRecipients?: boolean | UserCountOutputTypeCountNotificationRecipientsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManualOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePerformanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRecipientWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    performanceRecords: number
    qualifications: number
    assignments: number
    absences: number
    ratings: number
    workStatistics: number
    orderAssignments: number
    files: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performanceRecords?: boolean | EmployeeCountOutputTypeCountPerformanceRecordsArgs
    qualifications?: boolean | EmployeeCountOutputTypeCountQualificationsArgs
    assignments?: boolean | EmployeeCountOutputTypeCountAssignmentsArgs
    absences?: boolean | EmployeeCountOutputTypeCountAbsencesArgs
    ratings?: boolean | EmployeeCountOutputTypeCountRatingsArgs
    workStatistics?: boolean | EmployeeCountOutputTypeCountWorkStatisticsArgs
    orderAssignments?: boolean | EmployeeCountOutputTypeCountOrderAssignmentsArgs
    files?: boolean | EmployeeCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPerformanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePerformanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeQualificationWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAbsencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbsenceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountWorkStatisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkStatisticWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOrderAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    childDepartments: number
    employees: number
    positions: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childDepartments?: boolean | DepartmentCountOutputTypeCountChildDepartmentsArgs
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
    positions?: boolean | DepartmentCountOutputTypeCountPositionsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountChildDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    employees: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | PositionCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    subAccounts: number
    orders: number
    ratings: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccounts?: boolean | CustomerCountOutputTypeCountSubAccountsArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    ratings?: boolean | CustomerCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSubAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    qualifications: number
    orderAssignments: number
    employeeAssignments: number
    ratings: number
    files: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualifications?: boolean | OrderCountOutputTypeCountQualificationsArgs
    orderAssignments?: boolean | OrderCountOutputTypeCountOrderAssignmentsArgs
    employeeAssignments?: boolean | OrderCountOutputTypeCountEmployeeAssignmentsArgs
    ratings?: boolean | OrderCountOutputTypeCountRatingsArgs
    files?: boolean | OrderCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderQualificationWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAssignmentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountEmployeeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type QualificationCountOutputType
   */

  export type QualificationCountOutputType = {
    employeeQualifications: number
    orderQualifications: number
  }

  export type QualificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeQualifications?: boolean | QualificationCountOutputTypeCountEmployeeQualificationsArgs
    orderQualifications?: boolean | QualificationCountOutputTypeCountOrderQualificationsArgs
  }

  // Custom InputTypes
  /**
   * QualificationCountOutputType without action
   */
  export type QualificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualificationCountOutputType
     */
    select?: QualificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QualificationCountOutputType without action
   */
  export type QualificationCountOutputTypeCountEmployeeQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeQualificationWhereInput
  }

  /**
   * QualificationCountOutputType without action
   */
  export type QualificationCountOutputTypeCountOrderQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderQualificationWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    files: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | AssignmentCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    recipients: number
    NotificationOutbox: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | NotificationCountOutputTypeCountRecipientsArgs
    NotificationOutbox?: boolean | NotificationCountOutputTypeCountNotificationOutboxArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRecipientWhereInput
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountNotificationOutboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationOutboxWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    refreshToken: string | null
    emailVerificationToken: string | null
    emailVerificationExpires: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    emailVerified: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    refreshToken: string | null
    emailVerificationToken: string | null
    emailVerificationExpires: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    emailVerified: boolean | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    role: number
    isActive: number
    lastLogin: number
    refreshToken: number
    emailVerificationToken: number
    emailVerificationExpires: number
    passwordResetToken: number
    passwordResetExpires: number
    emailVerified: number
    twoFactorEnabled: number
    twoFactorSecret: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    role?: true
    isActive?: true
    lastLogin?: true
    refreshToken?: true
    emailVerificationToken?: true
    emailVerificationExpires?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    emailVerified?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    role?: true
    isActive?: true
    lastLogin?: true
    refreshToken?: true
    emailVerificationToken?: true
    emailVerificationExpires?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    emailVerified?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    role?: true
    isActive?: true
    lastLogin?: true
    refreshToken?: true
    emailVerificationToken?: true
    emailVerificationExpires?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    emailVerified?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    username: string
    password: string
    role: $Enums.UserRole
    isActive: boolean
    lastLogin: Date | null
    refreshToken: string | null
    emailVerificationToken: string | null
    emailVerificationExpires: Date | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    emailVerified: boolean
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
    manualOverrides?: boolean | User$manualOverridesArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    notificationRecipients?: boolean | User$notificationRecipientsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    refreshToken?: boolean
    emailVerificationToken?: boolean
    emailVerificationExpires?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password" | "role" | "isActive" | "lastLogin" | "refreshToken" | "emailVerificationToken" | "emailVerificationExpires" | "passwordResetToken" | "passwordResetExpires" | "emailVerified" | "twoFactorEnabled" | "twoFactorSecret" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
    manualOverrides?: boolean | User$manualOverridesArgs<ExtArgs>
    subordinates?: boolean | User$subordinatesArgs<ExtArgs>
    notificationRecipients?: boolean | User$notificationRecipientsArgs<ExtArgs>
    notificationPreferences?: boolean | User$notificationPreferencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      manualOverrides: Prisma.$EmployeePerformancePayload<ExtArgs>[]
      subordinates: Prisma.$EmployeePayload<ExtArgs>[]
      notificationRecipients: Prisma.$NotificationRecipientPayload<ExtArgs>[]
      notificationPreferences: Prisma.$NotificationPreferencePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      username: string
      password: string
      role: $Enums.UserRole
      isActive: boolean
      lastLogin: Date | null
      refreshToken: string | null
      emailVerificationToken: string | null
      emailVerificationExpires: Date | null
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      emailVerified: boolean
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manualOverrides<T extends User$manualOverridesArgs<ExtArgs> = {}>(args?: Subset<T, User$manualOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subordinates<T extends User$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, User$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationRecipients<T extends User$notificationRecipientsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationRecipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreferences<T extends User$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferencesArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly emailVerificationExpires: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly updatedBy: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.manualOverrides
   */
  export type User$manualOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    where?: EmployeePerformanceWhereInput
    orderBy?: EmployeePerformanceOrderByWithRelationInput | EmployeePerformanceOrderByWithRelationInput[]
    cursor?: EmployeePerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeePerformanceScalarFieldEnum | EmployeePerformanceScalarFieldEnum[]
  }

  /**
   * User.subordinates
   */
  export type User$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * User.notificationRecipients
   */
  export type User$notificationRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    where?: NotificationRecipientWhereInput
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    cursor?: NotificationRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * User.notificationPreferences
   */
  export type User$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    hourlyRate: Decimal | null
    salary: Decimal | null
    priority: number | null
    performanceScore: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    hourlyRate: Decimal | null
    salary: Decimal | null
    priority: number | null
    performanceScore: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    employeeCode: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    dateOfBirth: Date | null
    address: string | null
    hireDate: Date | null
    terminationDate: Date | null
    departmentId: string | null
    positionId: string | null
    managerId: string | null
    scheduleType: $Enums.WorkScheduleType | null
    hourlyRate: Decimal | null
    salary: Decimal | null
    isAvailable: boolean | null
    priority: number | null
    blockedAt: Date | null
    blockedReason: string | null
    performanceScore: Decimal | null
    trafficLight: $Enums.TrafficLight | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    employeeCode: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    dateOfBirth: Date | null
    address: string | null
    hireDate: Date | null
    terminationDate: Date | null
    departmentId: string | null
    positionId: string | null
    managerId: string | null
    scheduleType: $Enums.WorkScheduleType | null
    hourlyRate: Decimal | null
    salary: Decimal | null
    isAvailable: boolean | null
    priority: number | null
    blockedAt: Date | null
    blockedReason: string | null
    performanceScore: Decimal | null
    trafficLight: $Enums.TrafficLight | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeCode: number
    firstName: number
    lastName: number
    phoneNumber: number
    dateOfBirth: number
    address: number
    emergencyContact: number
    hireDate: number
    terminationDate: number
    departmentId: number
    positionId: number
    managerId: number
    scheduleType: number
    hourlyRate: number
    salary: number
    isAvailable: number
    priority: number
    blockedAt: number
    blockedReason: number
    performanceScore: number
    trafficLight: number
    userId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    hourlyRate?: true
    salary?: true
    priority?: true
    performanceScore?: true
  }

  export type EmployeeSumAggregateInputType = {
    hourlyRate?: true
    salary?: true
    priority?: true
    performanceScore?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    dateOfBirth?: true
    address?: true
    hireDate?: true
    terminationDate?: true
    departmentId?: true
    positionId?: true
    managerId?: true
    scheduleType?: true
    hourlyRate?: true
    salary?: true
    isAvailable?: true
    priority?: true
    blockedAt?: true
    blockedReason?: true
    performanceScore?: true
    trafficLight?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    dateOfBirth?: true
    address?: true
    hireDate?: true
    terminationDate?: true
    departmentId?: true
    positionId?: true
    managerId?: true
    scheduleType?: true
    hourlyRate?: true
    salary?: true
    isAvailable?: true
    priority?: true
    blockedAt?: true
    blockedReason?: true
    performanceScore?: true
    trafficLight?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    dateOfBirth?: true
    address?: true
    emergencyContact?: true
    hireDate?: true
    terminationDate?: true
    departmentId?: true
    positionId?: true
    managerId?: true
    scheduleType?: true
    hourlyRate?: true
    salary?: true
    isAvailable?: true
    priority?: true
    blockedAt?: true
    blockedReason?: true
    performanceScore?: true
    trafficLight?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    employeeCode: string
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    dateOfBirth: Date | null
    address: string | null
    emergencyContact: JsonValue | null
    hireDate: Date
    terminationDate: Date | null
    departmentId: string | null
    positionId: string | null
    managerId: string | null
    scheduleType: $Enums.WorkScheduleType
    hourlyRate: Decimal | null
    salary: Decimal | null
    isAvailable: boolean
    priority: number
    blockedAt: Date | null
    blockedReason: string | null
    performanceScore: Decimal | null
    trafficLight: $Enums.TrafficLight | null
    userId: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    hireDate?: boolean
    terminationDate?: boolean
    departmentId?: boolean
    positionId?: boolean
    managerId?: boolean
    scheduleType?: boolean
    hourlyRate?: boolean
    salary?: boolean
    isAvailable?: boolean
    priority?: boolean
    blockedAt?: boolean
    blockedReason?: boolean
    performanceScore?: boolean
    trafficLight?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    performanceRecords?: boolean | Employee$performanceRecordsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    qualifications?: boolean | Employee$qualificationsArgs<ExtArgs>
    assignments?: boolean | Employee$assignmentsArgs<ExtArgs>
    absences?: boolean | Employee$absencesArgs<ExtArgs>
    ratings?: boolean | Employee$ratingsArgs<ExtArgs>
    workStatistics?: boolean | Employee$workStatisticsArgs<ExtArgs>
    orderAssignments?: boolean | Employee$orderAssignmentsArgs<ExtArgs>
    files?: boolean | Employee$filesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    hireDate?: boolean
    terminationDate?: boolean
    departmentId?: boolean
    positionId?: boolean
    managerId?: boolean
    scheduleType?: boolean
    hourlyRate?: boolean
    salary?: boolean
    isAvailable?: boolean
    priority?: boolean
    blockedAt?: boolean
    blockedReason?: boolean
    performanceScore?: boolean
    trafficLight?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    hireDate?: boolean
    terminationDate?: boolean
    departmentId?: boolean
    positionId?: boolean
    managerId?: boolean
    scheduleType?: boolean
    hourlyRate?: boolean
    salary?: boolean
    isAvailable?: boolean
    priority?: boolean
    blockedAt?: boolean
    blockedReason?: boolean
    performanceScore?: boolean
    trafficLight?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    dateOfBirth?: boolean
    address?: boolean
    emergencyContact?: boolean
    hireDate?: boolean
    terminationDate?: boolean
    departmentId?: boolean
    positionId?: boolean
    managerId?: boolean
    scheduleType?: boolean
    hourlyRate?: boolean
    salary?: boolean
    isAvailable?: boolean
    priority?: boolean
    blockedAt?: boolean
    blockedReason?: boolean
    performanceScore?: boolean
    trafficLight?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeCode" | "firstName" | "lastName" | "phoneNumber" | "dateOfBirth" | "address" | "emergencyContact" | "hireDate" | "terminationDate" | "departmentId" | "positionId" | "managerId" | "scheduleType" | "hourlyRate" | "salary" | "isAvailable" | "priority" | "blockedAt" | "blockedReason" | "performanceScore" | "trafficLight" | "userId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    performanceRecords?: boolean | Employee$performanceRecordsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    qualifications?: boolean | Employee$qualificationsArgs<ExtArgs>
    assignments?: boolean | Employee$assignmentsArgs<ExtArgs>
    absences?: boolean | Employee$absencesArgs<ExtArgs>
    ratings?: boolean | Employee$ratingsArgs<ExtArgs>
    workStatistics?: boolean | Employee$workStatisticsArgs<ExtArgs>
    orderAssignments?: boolean | Employee$orderAssignmentsArgs<ExtArgs>
    files?: boolean | Employee$filesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      position: Prisma.$PositionPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      performanceRecords: Prisma.$EmployeePerformancePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      qualifications: Prisma.$EmployeeQualificationPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      absences: Prisma.$AbsencePayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      workStatistics: Prisma.$WorkStatisticPayload<ExtArgs>[]
      orderAssignments: Prisma.$OrderAssignmentPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeCode: string
      firstName: string | null
      lastName: string | null
      phoneNumber: string | null
      dateOfBirth: Date | null
      address: string | null
      emergencyContact: Prisma.JsonValue | null
      hireDate: Date
      terminationDate: Date | null
      departmentId: string | null
      positionId: string | null
      managerId: string | null
      scheduleType: $Enums.WorkScheduleType
      hourlyRate: Prisma.Decimal | null
      salary: Prisma.Decimal | null
      isAvailable: boolean
      priority: number
      blockedAt: Date | null
      blockedReason: string | null
      performanceScore: Prisma.Decimal | null
      trafficLight: $Enums.TrafficLight | null
      userId: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends Employee$positionArgs<ExtArgs> = {}>(args?: Subset<T, Employee$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends Employee$managerArgs<ExtArgs> = {}>(args?: Subset<T, Employee$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    performanceRecords<T extends Employee$performanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$performanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qualifications<T extends Employee$qualificationsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$qualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Employee$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    absences<T extends Employee$absencesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$absencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Employee$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workStatistics<T extends Employee$workStatisticsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$workStatisticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderAssignments<T extends Employee$orderAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$orderAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Employee$filesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly employeeCode: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly phoneNumber: FieldRef<"Employee", 'String'>
    readonly dateOfBirth: FieldRef<"Employee", 'DateTime'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly emergencyContact: FieldRef<"Employee", 'Json'>
    readonly hireDate: FieldRef<"Employee", 'DateTime'>
    readonly terminationDate: FieldRef<"Employee", 'DateTime'>
    readonly departmentId: FieldRef<"Employee", 'String'>
    readonly positionId: FieldRef<"Employee", 'String'>
    readonly managerId: FieldRef<"Employee", 'String'>
    readonly scheduleType: FieldRef<"Employee", 'WorkScheduleType'>
    readonly hourlyRate: FieldRef<"Employee", 'Decimal'>
    readonly salary: FieldRef<"Employee", 'Decimal'>
    readonly isAvailable: FieldRef<"Employee", 'Boolean'>
    readonly priority: FieldRef<"Employee", 'Int'>
    readonly blockedAt: FieldRef<"Employee", 'DateTime'>
    readonly blockedReason: FieldRef<"Employee", 'String'>
    readonly performanceScore: FieldRef<"Employee", 'Decimal'>
    readonly trafficLight: FieldRef<"Employee", 'TrafficLight'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly createdBy: FieldRef<"Employee", 'String'>
    readonly updatedBy: FieldRef<"Employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee.position
   */
  export type Employee$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * Employee.manager
   */
  export type Employee$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.performanceRecords
   */
  export type Employee$performanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    where?: EmployeePerformanceWhereInput
    orderBy?: EmployeePerformanceOrderByWithRelationInput | EmployeePerformanceOrderByWithRelationInput[]
    cursor?: EmployeePerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeePerformanceScalarFieldEnum | EmployeePerformanceScalarFieldEnum[]
  }

  /**
   * Employee.qualifications
   */
  export type Employee$qualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    where?: EmployeeQualificationWhereInput
    orderBy?: EmployeeQualificationOrderByWithRelationInput | EmployeeQualificationOrderByWithRelationInput[]
    cursor?: EmployeeQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeQualificationScalarFieldEnum | EmployeeQualificationScalarFieldEnum[]
  }

  /**
   * Employee.assignments
   */
  export type Employee$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Employee.absences
   */
  export type Employee$absencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    where?: AbsenceWhereInput
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    cursor?: AbsenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Employee.ratings
   */
  export type Employee$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Employee.workStatistics
   */
  export type Employee$workStatisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    where?: WorkStatisticWhereInput
    orderBy?: WorkStatisticOrderByWithRelationInput | WorkStatisticOrderByWithRelationInput[]
    cursor?: WorkStatisticWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkStatisticScalarFieldEnum | WorkStatisticScalarFieldEnum[]
  }

  /**
   * Employee.orderAssignments
   */
  export type Employee$orderAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    where?: OrderAssignmentWhereInput
    orderBy?: OrderAssignmentOrderByWithRelationInput | OrderAssignmentOrderByWithRelationInput[]
    cursor?: OrderAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderAssignmentScalarFieldEnum | OrderAssignmentScalarFieldEnum[]
  }

  /**
   * Employee.files
   */
  export type Employee$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model EmployeePerformance
   */

  export type AggregateEmployeePerformance = {
    _count: EmployeePerformanceCountAggregateOutputType | null
    _avg: EmployeePerformanceAvgAggregateOutputType | null
    _sum: EmployeePerformanceSumAggregateOutputType | null
    _min: EmployeePerformanceMinAggregateOutputType | null
    _max: EmployeePerformanceMaxAggregateOutputType | null
  }

  export type EmployeePerformanceAvgAggregateOutputType = {
    score: Decimal | null
  }

  export type EmployeePerformanceSumAggregateOutputType = {
    score: Decimal | null
  }

  export type EmployeePerformanceMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    score: Decimal | null
    trafficLight: $Enums.TrafficLight | null
    trafficLightReason: string | null
    manualOverride: boolean | null
    manualOverrideById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeePerformanceMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    score: Decimal | null
    trafficLight: $Enums.TrafficLight | null
    trafficLightReason: string | null
    manualOverride: boolean | null
    manualOverrideById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeePerformanceCountAggregateOutputType = {
    id: number
    employeeId: number
    periodStart: number
    periodEnd: number
    score: number
    trafficLight: number
    trafficLightReason: number
    metrics: number
    manualOverride: number
    manualOverrideById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeePerformanceAvgAggregateInputType = {
    score?: true
  }

  export type EmployeePerformanceSumAggregateInputType = {
    score?: true
  }

  export type EmployeePerformanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    periodStart?: true
    periodEnd?: true
    score?: true
    trafficLight?: true
    trafficLightReason?: true
    manualOverride?: true
    manualOverrideById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeePerformanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    periodStart?: true
    periodEnd?: true
    score?: true
    trafficLight?: true
    trafficLightReason?: true
    manualOverride?: true
    manualOverrideById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeePerformanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    periodStart?: true
    periodEnd?: true
    score?: true
    trafficLight?: true
    trafficLightReason?: true
    metrics?: true
    manualOverride?: true
    manualOverrideById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeePerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeePerformance to aggregate.
     */
    where?: EmployeePerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePerformances to fetch.
     */
    orderBy?: EmployeePerformanceOrderByWithRelationInput | EmployeePerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeePerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeePerformances
    **/
    _count?: true | EmployeePerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeePerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeePerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeePerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeePerformanceMaxAggregateInputType
  }

  export type GetEmployeePerformanceAggregateType<T extends EmployeePerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeePerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeePerformance[P]>
      : GetScalarType<T[P], AggregateEmployeePerformance[P]>
  }




  export type EmployeePerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePerformanceWhereInput
    orderBy?: EmployeePerformanceOrderByWithAggregationInput | EmployeePerformanceOrderByWithAggregationInput[]
    by: EmployeePerformanceScalarFieldEnum[] | EmployeePerformanceScalarFieldEnum
    having?: EmployeePerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeePerformanceCountAggregateInputType | true
    _avg?: EmployeePerformanceAvgAggregateInputType
    _sum?: EmployeePerformanceSumAggregateInputType
    _min?: EmployeePerformanceMinAggregateInputType
    _max?: EmployeePerformanceMaxAggregateInputType
  }

  export type EmployeePerformanceGroupByOutputType = {
    id: string
    employeeId: string
    periodStart: Date
    periodEnd: Date
    score: Decimal
    trafficLight: $Enums.TrafficLight
    trafficLightReason: string | null
    metrics: JsonValue | null
    manualOverride: boolean
    manualOverrideById: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeePerformanceCountAggregateOutputType | null
    _avg: EmployeePerformanceAvgAggregateOutputType | null
    _sum: EmployeePerformanceSumAggregateOutputType | null
    _min: EmployeePerformanceMinAggregateOutputType | null
    _max: EmployeePerformanceMaxAggregateOutputType | null
  }

  type GetEmployeePerformanceGroupByPayload<T extends EmployeePerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeePerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeePerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeePerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeePerformanceGroupByOutputType[P]>
        }
      >
    >


  export type EmployeePerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    score?: boolean
    trafficLight?: boolean
    trafficLightReason?: boolean
    metrics?: boolean
    manualOverride?: boolean
    manualOverrideById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    manualOverrideBy?: boolean | EmployeePerformance$manualOverrideByArgs<ExtArgs>
  }, ExtArgs["result"]["employeePerformance"]>

  export type EmployeePerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    score?: boolean
    trafficLight?: boolean
    trafficLightReason?: boolean
    metrics?: boolean
    manualOverride?: boolean
    manualOverrideById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    manualOverrideBy?: boolean | EmployeePerformance$manualOverrideByArgs<ExtArgs>
  }, ExtArgs["result"]["employeePerformance"]>

  export type EmployeePerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    score?: boolean
    trafficLight?: boolean
    trafficLightReason?: boolean
    metrics?: boolean
    manualOverride?: boolean
    manualOverrideById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    manualOverrideBy?: boolean | EmployeePerformance$manualOverrideByArgs<ExtArgs>
  }, ExtArgs["result"]["employeePerformance"]>

  export type EmployeePerformanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    score?: boolean
    trafficLight?: boolean
    trafficLightReason?: boolean
    metrics?: boolean
    manualOverride?: boolean
    manualOverrideById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeePerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "periodStart" | "periodEnd" | "score" | "trafficLight" | "trafficLightReason" | "metrics" | "manualOverride" | "manualOverrideById" | "createdAt" | "updatedAt", ExtArgs["result"]["employeePerformance"]>
  export type EmployeePerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    manualOverrideBy?: boolean | EmployeePerformance$manualOverrideByArgs<ExtArgs>
  }
  export type EmployeePerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    manualOverrideBy?: boolean | EmployeePerformance$manualOverrideByArgs<ExtArgs>
  }
  export type EmployeePerformanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    manualOverrideBy?: boolean | EmployeePerformance$manualOverrideByArgs<ExtArgs>
  }

  export type $EmployeePerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeePerformance"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      manualOverrideBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      periodStart: Date
      periodEnd: Date
      score: Prisma.Decimal
      trafficLight: $Enums.TrafficLight
      trafficLightReason: string | null
      metrics: Prisma.JsonValue | null
      manualOverride: boolean
      manualOverrideById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeePerformance"]>
    composites: {}
  }

  type EmployeePerformanceGetPayload<S extends boolean | null | undefined | EmployeePerformanceDefaultArgs> = $Result.GetResult<Prisma.$EmployeePerformancePayload, S>

  type EmployeePerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeePerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeePerformanceCountAggregateInputType | true
    }

  export interface EmployeePerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeePerformance'], meta: { name: 'EmployeePerformance' } }
    /**
     * Find zero or one EmployeePerformance that matches the filter.
     * @param {EmployeePerformanceFindUniqueArgs} args - Arguments to find a EmployeePerformance
     * @example
     * // Get one EmployeePerformance
     * const employeePerformance = await prisma.employeePerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeePerformanceFindUniqueArgs>(args: SelectSubset<T, EmployeePerformanceFindUniqueArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeePerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeePerformanceFindUniqueOrThrowArgs} args - Arguments to find a EmployeePerformance
     * @example
     * // Get one EmployeePerformance
     * const employeePerformance = await prisma.employeePerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeePerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeePerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeePerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceFindFirstArgs} args - Arguments to find a EmployeePerformance
     * @example
     * // Get one EmployeePerformance
     * const employeePerformance = await prisma.employeePerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeePerformanceFindFirstArgs>(args?: SelectSubset<T, EmployeePerformanceFindFirstArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeePerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceFindFirstOrThrowArgs} args - Arguments to find a EmployeePerformance
     * @example
     * // Get one EmployeePerformance
     * const employeePerformance = await prisma.employeePerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeePerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeePerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeePerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeePerformances
     * const employeePerformances = await prisma.employeePerformance.findMany()
     * 
     * // Get first 10 EmployeePerformances
     * const employeePerformances = await prisma.employeePerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeePerformanceWithIdOnly = await prisma.employeePerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeePerformanceFindManyArgs>(args?: SelectSubset<T, EmployeePerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeePerformance.
     * @param {EmployeePerformanceCreateArgs} args - Arguments to create a EmployeePerformance.
     * @example
     * // Create one EmployeePerformance
     * const EmployeePerformance = await prisma.employeePerformance.create({
     *   data: {
     *     // ... data to create a EmployeePerformance
     *   }
     * })
     * 
     */
    create<T extends EmployeePerformanceCreateArgs>(args: SelectSubset<T, EmployeePerformanceCreateArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeePerformances.
     * @param {EmployeePerformanceCreateManyArgs} args - Arguments to create many EmployeePerformances.
     * @example
     * // Create many EmployeePerformances
     * const employeePerformance = await prisma.employeePerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeePerformanceCreateManyArgs>(args?: SelectSubset<T, EmployeePerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeePerformances and returns the data saved in the database.
     * @param {EmployeePerformanceCreateManyAndReturnArgs} args - Arguments to create many EmployeePerformances.
     * @example
     * // Create many EmployeePerformances
     * const employeePerformance = await prisma.employeePerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeePerformances and only return the `id`
     * const employeePerformanceWithIdOnly = await prisma.employeePerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeePerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeePerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeePerformance.
     * @param {EmployeePerformanceDeleteArgs} args - Arguments to delete one EmployeePerformance.
     * @example
     * // Delete one EmployeePerformance
     * const EmployeePerformance = await prisma.employeePerformance.delete({
     *   where: {
     *     // ... filter to delete one EmployeePerformance
     *   }
     * })
     * 
     */
    delete<T extends EmployeePerformanceDeleteArgs>(args: SelectSubset<T, EmployeePerformanceDeleteArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeePerformance.
     * @param {EmployeePerformanceUpdateArgs} args - Arguments to update one EmployeePerformance.
     * @example
     * // Update one EmployeePerformance
     * const employeePerformance = await prisma.employeePerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeePerformanceUpdateArgs>(args: SelectSubset<T, EmployeePerformanceUpdateArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeePerformances.
     * @param {EmployeePerformanceDeleteManyArgs} args - Arguments to filter EmployeePerformances to delete.
     * @example
     * // Delete a few EmployeePerformances
     * const { count } = await prisma.employeePerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeePerformanceDeleteManyArgs>(args?: SelectSubset<T, EmployeePerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeePerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeePerformances
     * const employeePerformance = await prisma.employeePerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeePerformanceUpdateManyArgs>(args: SelectSubset<T, EmployeePerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeePerformances and returns the data updated in the database.
     * @param {EmployeePerformanceUpdateManyAndReturnArgs} args - Arguments to update many EmployeePerformances.
     * @example
     * // Update many EmployeePerformances
     * const employeePerformance = await prisma.employeePerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeePerformances and only return the `id`
     * const employeePerformanceWithIdOnly = await prisma.employeePerformance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeePerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeePerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeePerformance.
     * @param {EmployeePerformanceUpsertArgs} args - Arguments to update or create a EmployeePerformance.
     * @example
     * // Update or create a EmployeePerformance
     * const employeePerformance = await prisma.employeePerformance.upsert({
     *   create: {
     *     // ... data to create a EmployeePerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeePerformance we want to update
     *   }
     * })
     */
    upsert<T extends EmployeePerformanceUpsertArgs>(args: SelectSubset<T, EmployeePerformanceUpsertArgs<ExtArgs>>): Prisma__EmployeePerformanceClient<$Result.GetResult<Prisma.$EmployeePerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeePerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceCountArgs} args - Arguments to filter EmployeePerformances to count.
     * @example
     * // Count the number of EmployeePerformances
     * const count = await prisma.employeePerformance.count({
     *   where: {
     *     // ... the filter for the EmployeePerformances we want to count
     *   }
     * })
    **/
    count<T extends EmployeePerformanceCountArgs>(
      args?: Subset<T, EmployeePerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeePerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeePerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeePerformanceAggregateArgs>(args: Subset<T, EmployeePerformanceAggregateArgs>): Prisma.PrismaPromise<GetEmployeePerformanceAggregateType<T>>

    /**
     * Group by EmployeePerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeePerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeePerformanceGroupByArgs['orderBy'] }
        : { orderBy?: EmployeePerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeePerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeePerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeePerformance model
   */
  readonly fields: EmployeePerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeePerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeePerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manualOverrideBy<T extends EmployeePerformance$manualOverrideByArgs<ExtArgs> = {}>(args?: Subset<T, EmployeePerformance$manualOverrideByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeePerformance model
   */
  interface EmployeePerformanceFieldRefs {
    readonly id: FieldRef<"EmployeePerformance", 'String'>
    readonly employeeId: FieldRef<"EmployeePerformance", 'String'>
    readonly periodStart: FieldRef<"EmployeePerformance", 'DateTime'>
    readonly periodEnd: FieldRef<"EmployeePerformance", 'DateTime'>
    readonly score: FieldRef<"EmployeePerformance", 'Decimal'>
    readonly trafficLight: FieldRef<"EmployeePerformance", 'TrafficLight'>
    readonly trafficLightReason: FieldRef<"EmployeePerformance", 'String'>
    readonly metrics: FieldRef<"EmployeePerformance", 'Json'>
    readonly manualOverride: FieldRef<"EmployeePerformance", 'Boolean'>
    readonly manualOverrideById: FieldRef<"EmployeePerformance", 'String'>
    readonly createdAt: FieldRef<"EmployeePerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeePerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeePerformance findUnique
   */
  export type EmployeePerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePerformance to fetch.
     */
    where: EmployeePerformanceWhereUniqueInput
  }

  /**
   * EmployeePerformance findUniqueOrThrow
   */
  export type EmployeePerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePerformance to fetch.
     */
    where: EmployeePerformanceWhereUniqueInput
  }

  /**
   * EmployeePerformance findFirst
   */
  export type EmployeePerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePerformance to fetch.
     */
    where?: EmployeePerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePerformances to fetch.
     */
    orderBy?: EmployeePerformanceOrderByWithRelationInput | EmployeePerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeePerformances.
     */
    cursor?: EmployeePerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeePerformances.
     */
    distinct?: EmployeePerformanceScalarFieldEnum | EmployeePerformanceScalarFieldEnum[]
  }

  /**
   * EmployeePerformance findFirstOrThrow
   */
  export type EmployeePerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePerformance to fetch.
     */
    where?: EmployeePerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePerformances to fetch.
     */
    orderBy?: EmployeePerformanceOrderByWithRelationInput | EmployeePerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeePerformances.
     */
    cursor?: EmployeePerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeePerformances.
     */
    distinct?: EmployeePerformanceScalarFieldEnum | EmployeePerformanceScalarFieldEnum[]
  }

  /**
   * EmployeePerformance findMany
   */
  export type EmployeePerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePerformances to fetch.
     */
    where?: EmployeePerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePerformances to fetch.
     */
    orderBy?: EmployeePerformanceOrderByWithRelationInput | EmployeePerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeePerformances.
     */
    cursor?: EmployeePerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePerformances.
     */
    skip?: number
    distinct?: EmployeePerformanceScalarFieldEnum | EmployeePerformanceScalarFieldEnum[]
  }

  /**
   * EmployeePerformance create
   */
  export type EmployeePerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeePerformance.
     */
    data: XOR<EmployeePerformanceCreateInput, EmployeePerformanceUncheckedCreateInput>
  }

  /**
   * EmployeePerformance createMany
   */
  export type EmployeePerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeePerformances.
     */
    data: EmployeePerformanceCreateManyInput | EmployeePerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeePerformance createManyAndReturn
   */
  export type EmployeePerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeePerformances.
     */
    data: EmployeePerformanceCreateManyInput | EmployeePerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeePerformance update
   */
  export type EmployeePerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeePerformance.
     */
    data: XOR<EmployeePerformanceUpdateInput, EmployeePerformanceUncheckedUpdateInput>
    /**
     * Choose, which EmployeePerformance to update.
     */
    where: EmployeePerformanceWhereUniqueInput
  }

  /**
   * EmployeePerformance updateMany
   */
  export type EmployeePerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeePerformances.
     */
    data: XOR<EmployeePerformanceUpdateManyMutationInput, EmployeePerformanceUncheckedUpdateManyInput>
    /**
     * Filter which EmployeePerformances to update
     */
    where?: EmployeePerformanceWhereInput
    /**
     * Limit how many EmployeePerformances to update.
     */
    limit?: number
  }

  /**
   * EmployeePerformance updateManyAndReturn
   */
  export type EmployeePerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * The data used to update EmployeePerformances.
     */
    data: XOR<EmployeePerformanceUpdateManyMutationInput, EmployeePerformanceUncheckedUpdateManyInput>
    /**
     * Filter which EmployeePerformances to update
     */
    where?: EmployeePerformanceWhereInput
    /**
     * Limit how many EmployeePerformances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeePerformance upsert
   */
  export type EmployeePerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeePerformance to update in case it exists.
     */
    where: EmployeePerformanceWhereUniqueInput
    /**
     * In case the EmployeePerformance found by the `where` argument doesn't exist, create a new EmployeePerformance with this data.
     */
    create: XOR<EmployeePerformanceCreateInput, EmployeePerformanceUncheckedCreateInput>
    /**
     * In case the EmployeePerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeePerformanceUpdateInput, EmployeePerformanceUncheckedUpdateInput>
  }

  /**
   * EmployeePerformance delete
   */
  export type EmployeePerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
    /**
     * Filter which EmployeePerformance to delete.
     */
    where: EmployeePerformanceWhereUniqueInput
  }

  /**
   * EmployeePerformance deleteMany
   */
  export type EmployeePerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeePerformances to delete
     */
    where?: EmployeePerformanceWhereInput
    /**
     * Limit how many EmployeePerformances to delete.
     */
    limit?: number
  }

  /**
   * EmployeePerformance.manualOverrideBy
   */
  export type EmployeePerformance$manualOverrideByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmployeePerformance without action
   */
  export type EmployeePerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePerformance
     */
    select?: EmployeePerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePerformance
     */
    omit?: EmployeePerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePerformanceInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceThreshold
   */

  export type AggregatePerformanceThreshold = {
    _count: PerformanceThresholdCountAggregateOutputType | null
    _avg: PerformanceThresholdAvgAggregateOutputType | null
    _sum: PerformanceThresholdSumAggregateOutputType | null
    _min: PerformanceThresholdMinAggregateOutputType | null
    _max: PerformanceThresholdMaxAggregateOutputType | null
  }

  export type PerformanceThresholdAvgAggregateOutputType = {
    redMin: number | null
    redMax: number | null
    yellowMin: number | null
    yellowMax: number | null
    greenMin: number | null
    greenMax: number | null
  }

  export type PerformanceThresholdSumAggregateOutputType = {
    redMin: number | null
    redMax: number | null
    yellowMin: number | null
    yellowMax: number | null
    greenMin: number | null
    greenMax: number | null
  }

  export type PerformanceThresholdMinAggregateOutputType = {
    id: string | null
    departmentId: string | null
    redMin: number | null
    redMax: number | null
    yellowMin: number | null
    yellowMax: number | null
    greenMin: number | null
    greenMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceThresholdMaxAggregateOutputType = {
    id: string | null
    departmentId: string | null
    redMin: number | null
    redMax: number | null
    yellowMin: number | null
    yellowMax: number | null
    greenMin: number | null
    greenMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceThresholdCountAggregateOutputType = {
    id: number
    departmentId: number
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceThresholdAvgAggregateInputType = {
    redMin?: true
    redMax?: true
    yellowMin?: true
    yellowMax?: true
    greenMin?: true
    greenMax?: true
  }

  export type PerformanceThresholdSumAggregateInputType = {
    redMin?: true
    redMax?: true
    yellowMin?: true
    yellowMax?: true
    greenMin?: true
    greenMax?: true
  }

  export type PerformanceThresholdMinAggregateInputType = {
    id?: true
    departmentId?: true
    redMin?: true
    redMax?: true
    yellowMin?: true
    yellowMax?: true
    greenMin?: true
    greenMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceThresholdMaxAggregateInputType = {
    id?: true
    departmentId?: true
    redMin?: true
    redMax?: true
    yellowMin?: true
    yellowMax?: true
    greenMin?: true
    greenMax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceThresholdCountAggregateInputType = {
    id?: true
    departmentId?: true
    redMin?: true
    redMax?: true
    yellowMin?: true
    yellowMax?: true
    greenMin?: true
    greenMax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceThresholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceThreshold to aggregate.
     */
    where?: PerformanceThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceThresholds to fetch.
     */
    orderBy?: PerformanceThresholdOrderByWithRelationInput | PerformanceThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceThresholds
    **/
    _count?: true | PerformanceThresholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceThresholdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceThresholdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceThresholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceThresholdMaxAggregateInputType
  }

  export type GetPerformanceThresholdAggregateType<T extends PerformanceThresholdAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceThreshold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceThreshold[P]>
      : GetScalarType<T[P], AggregatePerformanceThreshold[P]>
  }




  export type PerformanceThresholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceThresholdWhereInput
    orderBy?: PerformanceThresholdOrderByWithAggregationInput | PerformanceThresholdOrderByWithAggregationInput[]
    by: PerformanceThresholdScalarFieldEnum[] | PerformanceThresholdScalarFieldEnum
    having?: PerformanceThresholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceThresholdCountAggregateInputType | true
    _avg?: PerformanceThresholdAvgAggregateInputType
    _sum?: PerformanceThresholdSumAggregateInputType
    _min?: PerformanceThresholdMinAggregateInputType
    _max?: PerformanceThresholdMaxAggregateInputType
  }

  export type PerformanceThresholdGroupByOutputType = {
    id: string
    departmentId: string
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt: Date
    updatedAt: Date
    _count: PerformanceThresholdCountAggregateOutputType | null
    _avg: PerformanceThresholdAvgAggregateOutputType | null
    _sum: PerformanceThresholdSumAggregateOutputType | null
    _min: PerformanceThresholdMinAggregateOutputType | null
    _max: PerformanceThresholdMaxAggregateOutputType | null
  }

  type GetPerformanceThresholdGroupByPayload<T extends PerformanceThresholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceThresholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceThresholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceThresholdGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceThresholdGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceThresholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    redMin?: boolean
    redMax?: boolean
    yellowMin?: boolean
    yellowMax?: boolean
    greenMin?: boolean
    greenMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceThreshold"]>

  export type PerformanceThresholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    redMin?: boolean
    redMax?: boolean
    yellowMin?: boolean
    yellowMax?: boolean
    greenMin?: boolean
    greenMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceThreshold"]>

  export type PerformanceThresholdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    redMin?: boolean
    redMax?: boolean
    yellowMin?: boolean
    yellowMax?: boolean
    greenMin?: boolean
    greenMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceThreshold"]>

  export type PerformanceThresholdSelectScalar = {
    id?: boolean
    departmentId?: boolean
    redMin?: boolean
    redMax?: boolean
    yellowMin?: boolean
    yellowMax?: boolean
    greenMin?: boolean
    greenMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceThresholdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departmentId" | "redMin" | "redMax" | "yellowMin" | "yellowMax" | "greenMin" | "greenMax" | "createdAt" | "updatedAt", ExtArgs["result"]["performanceThreshold"]>
  export type PerformanceThresholdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type PerformanceThresholdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type PerformanceThresholdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $PerformanceThresholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceThreshold"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      departmentId: string
      redMin: number
      redMax: number
      yellowMin: number
      yellowMax: number
      greenMin: number
      greenMax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performanceThreshold"]>
    composites: {}
  }

  type PerformanceThresholdGetPayload<S extends boolean | null | undefined | PerformanceThresholdDefaultArgs> = $Result.GetResult<Prisma.$PerformanceThresholdPayload, S>

  type PerformanceThresholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceThresholdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceThresholdCountAggregateInputType | true
    }

  export interface PerformanceThresholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceThreshold'], meta: { name: 'PerformanceThreshold' } }
    /**
     * Find zero or one PerformanceThreshold that matches the filter.
     * @param {PerformanceThresholdFindUniqueArgs} args - Arguments to find a PerformanceThreshold
     * @example
     * // Get one PerformanceThreshold
     * const performanceThreshold = await prisma.performanceThreshold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceThresholdFindUniqueArgs>(args: SelectSubset<T, PerformanceThresholdFindUniqueArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceThreshold that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceThresholdFindUniqueOrThrowArgs} args - Arguments to find a PerformanceThreshold
     * @example
     * // Get one PerformanceThreshold
     * const performanceThreshold = await prisma.performanceThreshold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceThresholdFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceThresholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceThreshold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdFindFirstArgs} args - Arguments to find a PerformanceThreshold
     * @example
     * // Get one PerformanceThreshold
     * const performanceThreshold = await prisma.performanceThreshold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceThresholdFindFirstArgs>(args?: SelectSubset<T, PerformanceThresholdFindFirstArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceThreshold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdFindFirstOrThrowArgs} args - Arguments to find a PerformanceThreshold
     * @example
     * // Get one PerformanceThreshold
     * const performanceThreshold = await prisma.performanceThreshold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceThresholdFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceThresholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceThresholds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceThresholds
     * const performanceThresholds = await prisma.performanceThreshold.findMany()
     * 
     * // Get first 10 PerformanceThresholds
     * const performanceThresholds = await prisma.performanceThreshold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceThresholdWithIdOnly = await prisma.performanceThreshold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceThresholdFindManyArgs>(args?: SelectSubset<T, PerformanceThresholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceThreshold.
     * @param {PerformanceThresholdCreateArgs} args - Arguments to create a PerformanceThreshold.
     * @example
     * // Create one PerformanceThreshold
     * const PerformanceThreshold = await prisma.performanceThreshold.create({
     *   data: {
     *     // ... data to create a PerformanceThreshold
     *   }
     * })
     * 
     */
    create<T extends PerformanceThresholdCreateArgs>(args: SelectSubset<T, PerformanceThresholdCreateArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceThresholds.
     * @param {PerformanceThresholdCreateManyArgs} args - Arguments to create many PerformanceThresholds.
     * @example
     * // Create many PerformanceThresholds
     * const performanceThreshold = await prisma.performanceThreshold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceThresholdCreateManyArgs>(args?: SelectSubset<T, PerformanceThresholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceThresholds and returns the data saved in the database.
     * @param {PerformanceThresholdCreateManyAndReturnArgs} args - Arguments to create many PerformanceThresholds.
     * @example
     * // Create many PerformanceThresholds
     * const performanceThreshold = await prisma.performanceThreshold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceThresholds and only return the `id`
     * const performanceThresholdWithIdOnly = await prisma.performanceThreshold.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceThresholdCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceThresholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceThreshold.
     * @param {PerformanceThresholdDeleteArgs} args - Arguments to delete one PerformanceThreshold.
     * @example
     * // Delete one PerformanceThreshold
     * const PerformanceThreshold = await prisma.performanceThreshold.delete({
     *   where: {
     *     // ... filter to delete one PerformanceThreshold
     *   }
     * })
     * 
     */
    delete<T extends PerformanceThresholdDeleteArgs>(args: SelectSubset<T, PerformanceThresholdDeleteArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceThreshold.
     * @param {PerformanceThresholdUpdateArgs} args - Arguments to update one PerformanceThreshold.
     * @example
     * // Update one PerformanceThreshold
     * const performanceThreshold = await prisma.performanceThreshold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceThresholdUpdateArgs>(args: SelectSubset<T, PerformanceThresholdUpdateArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceThresholds.
     * @param {PerformanceThresholdDeleteManyArgs} args - Arguments to filter PerformanceThresholds to delete.
     * @example
     * // Delete a few PerformanceThresholds
     * const { count } = await prisma.performanceThreshold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceThresholdDeleteManyArgs>(args?: SelectSubset<T, PerformanceThresholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceThresholds
     * const performanceThreshold = await prisma.performanceThreshold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceThresholdUpdateManyArgs>(args: SelectSubset<T, PerformanceThresholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceThresholds and returns the data updated in the database.
     * @param {PerformanceThresholdUpdateManyAndReturnArgs} args - Arguments to update many PerformanceThresholds.
     * @example
     * // Update many PerformanceThresholds
     * const performanceThreshold = await prisma.performanceThreshold.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceThresholds and only return the `id`
     * const performanceThresholdWithIdOnly = await prisma.performanceThreshold.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceThresholdUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceThresholdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceThreshold.
     * @param {PerformanceThresholdUpsertArgs} args - Arguments to update or create a PerformanceThreshold.
     * @example
     * // Update or create a PerformanceThreshold
     * const performanceThreshold = await prisma.performanceThreshold.upsert({
     *   create: {
     *     // ... data to create a PerformanceThreshold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceThreshold we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceThresholdUpsertArgs>(args: SelectSubset<T, PerformanceThresholdUpsertArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdCountArgs} args - Arguments to filter PerformanceThresholds to count.
     * @example
     * // Count the number of PerformanceThresholds
     * const count = await prisma.performanceThreshold.count({
     *   where: {
     *     // ... the filter for the PerformanceThresholds we want to count
     *   }
     * })
    **/
    count<T extends PerformanceThresholdCountArgs>(
      args?: Subset<T, PerformanceThresholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceThresholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceThresholdAggregateArgs>(args: Subset<T, PerformanceThresholdAggregateArgs>): Prisma.PrismaPromise<GetPerformanceThresholdAggregateType<T>>

    /**
     * Group by PerformanceThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceThresholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceThresholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceThresholdGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceThresholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceThresholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceThresholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceThreshold model
   */
  readonly fields: PerformanceThresholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceThreshold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceThresholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceThreshold model
   */
  interface PerformanceThresholdFieldRefs {
    readonly id: FieldRef<"PerformanceThreshold", 'String'>
    readonly departmentId: FieldRef<"PerformanceThreshold", 'String'>
    readonly redMin: FieldRef<"PerformanceThreshold", 'Int'>
    readonly redMax: FieldRef<"PerformanceThreshold", 'Int'>
    readonly yellowMin: FieldRef<"PerformanceThreshold", 'Int'>
    readonly yellowMax: FieldRef<"PerformanceThreshold", 'Int'>
    readonly greenMin: FieldRef<"PerformanceThreshold", 'Int'>
    readonly greenMax: FieldRef<"PerformanceThreshold", 'Int'>
    readonly createdAt: FieldRef<"PerformanceThreshold", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceThreshold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceThreshold findUnique
   */
  export type PerformanceThresholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceThreshold to fetch.
     */
    where: PerformanceThresholdWhereUniqueInput
  }

  /**
   * PerformanceThreshold findUniqueOrThrow
   */
  export type PerformanceThresholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceThreshold to fetch.
     */
    where: PerformanceThresholdWhereUniqueInput
  }

  /**
   * PerformanceThreshold findFirst
   */
  export type PerformanceThresholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceThreshold to fetch.
     */
    where?: PerformanceThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceThresholds to fetch.
     */
    orderBy?: PerformanceThresholdOrderByWithRelationInput | PerformanceThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceThresholds.
     */
    cursor?: PerformanceThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceThresholds.
     */
    distinct?: PerformanceThresholdScalarFieldEnum | PerformanceThresholdScalarFieldEnum[]
  }

  /**
   * PerformanceThreshold findFirstOrThrow
   */
  export type PerformanceThresholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceThreshold to fetch.
     */
    where?: PerformanceThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceThresholds to fetch.
     */
    orderBy?: PerformanceThresholdOrderByWithRelationInput | PerformanceThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceThresholds.
     */
    cursor?: PerformanceThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceThresholds.
     */
    distinct?: PerformanceThresholdScalarFieldEnum | PerformanceThresholdScalarFieldEnum[]
  }

  /**
   * PerformanceThreshold findMany
   */
  export type PerformanceThresholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceThresholds to fetch.
     */
    where?: PerformanceThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceThresholds to fetch.
     */
    orderBy?: PerformanceThresholdOrderByWithRelationInput | PerformanceThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceThresholds.
     */
    cursor?: PerformanceThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceThresholds.
     */
    skip?: number
    distinct?: PerformanceThresholdScalarFieldEnum | PerformanceThresholdScalarFieldEnum[]
  }

  /**
   * PerformanceThreshold create
   */
  export type PerformanceThresholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceThreshold.
     */
    data: XOR<PerformanceThresholdCreateInput, PerformanceThresholdUncheckedCreateInput>
  }

  /**
   * PerformanceThreshold createMany
   */
  export type PerformanceThresholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceThresholds.
     */
    data: PerformanceThresholdCreateManyInput | PerformanceThresholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceThreshold createManyAndReturn
   */
  export type PerformanceThresholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceThresholds.
     */
    data: PerformanceThresholdCreateManyInput | PerformanceThresholdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceThreshold update
   */
  export type PerformanceThresholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceThreshold.
     */
    data: XOR<PerformanceThresholdUpdateInput, PerformanceThresholdUncheckedUpdateInput>
    /**
     * Choose, which PerformanceThreshold to update.
     */
    where: PerformanceThresholdWhereUniqueInput
  }

  /**
   * PerformanceThreshold updateMany
   */
  export type PerformanceThresholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceThresholds.
     */
    data: XOR<PerformanceThresholdUpdateManyMutationInput, PerformanceThresholdUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceThresholds to update
     */
    where?: PerformanceThresholdWhereInput
    /**
     * Limit how many PerformanceThresholds to update.
     */
    limit?: number
  }

  /**
   * PerformanceThreshold updateManyAndReturn
   */
  export type PerformanceThresholdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceThresholds.
     */
    data: XOR<PerformanceThresholdUpdateManyMutationInput, PerformanceThresholdUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceThresholds to update
     */
    where?: PerformanceThresholdWhereInput
    /**
     * Limit how many PerformanceThresholds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceThreshold upsert
   */
  export type PerformanceThresholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceThreshold to update in case it exists.
     */
    where: PerformanceThresholdWhereUniqueInput
    /**
     * In case the PerformanceThreshold found by the `where` argument doesn't exist, create a new PerformanceThreshold with this data.
     */
    create: XOR<PerformanceThresholdCreateInput, PerformanceThresholdUncheckedCreateInput>
    /**
     * In case the PerformanceThreshold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceThresholdUpdateInput, PerformanceThresholdUncheckedUpdateInput>
  }

  /**
   * PerformanceThreshold delete
   */
  export type PerformanceThresholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    /**
     * Filter which PerformanceThreshold to delete.
     */
    where: PerformanceThresholdWhereUniqueInput
  }

  /**
   * PerformanceThreshold deleteMany
   */
  export type PerformanceThresholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceThresholds to delete
     */
    where?: PerformanceThresholdWhereInput
    /**
     * Limit how many PerformanceThresholds to delete.
     */
    limit?: number
  }

  /**
   * PerformanceThreshold without action
   */
  export type PerformanceThresholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    isActive: boolean | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    code: string | null
    isActive: boolean | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    code: number
    isActive: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    isActive?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    isActive?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    code?: true
    isActive?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    code: string
    isActive: boolean
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    isActive?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentDepartment?: boolean | Department$parentDepartmentArgs<ExtArgs>
    childDepartments?: boolean | Department$childDepartmentsArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    positions?: boolean | Department$positionsArgs<ExtArgs>
    performanceThreshold?: boolean | Department$performanceThresholdArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    isActive?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentDepartment?: boolean | Department$parentDepartmentArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    isActive?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentDepartment?: boolean | Department$parentDepartmentArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    code?: boolean
    isActive?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "code" | "isActive" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentDepartment?: boolean | Department$parentDepartmentArgs<ExtArgs>
    childDepartments?: boolean | Department$childDepartmentsArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    positions?: boolean | Department$positionsArgs<ExtArgs>
    performanceThreshold?: boolean | Department$performanceThresholdArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentDepartment?: boolean | Department$parentDepartmentArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentDepartment?: boolean | Department$parentDepartmentArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      parentDepartment: Prisma.$DepartmentPayload<ExtArgs> | null
      childDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      positions: Prisma.$PositionPayload<ExtArgs>[]
      performanceThreshold: Prisma.$PerformanceThresholdPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      code: string
      isActive: boolean
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentDepartment<T extends Department$parentDepartmentArgs<ExtArgs> = {}>(args?: Subset<T, Department$parentDepartmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childDepartments<T extends Department$childDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$childDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    positions<T extends Department$positionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceThreshold<T extends Department$performanceThresholdArgs<ExtArgs> = {}>(args?: Subset<T, Department$performanceThresholdArgs<ExtArgs>>): Prisma__PerformanceThresholdClient<$Result.GetResult<Prisma.$PerformanceThresholdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly parentId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.parentDepartment
   */
  export type Department$parentDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Department.childDepartments
   */
  export type Department$childDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department.positions
   */
  export type Department$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    cursor?: PositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Department.performanceThreshold
   */
  export type Department$performanceThresholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceThreshold
     */
    select?: PerformanceThresholdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceThreshold
     */
    omit?: PerformanceThresholdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceThresholdInclude<ExtArgs> | null
    where?: PerformanceThresholdWhereInput
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    level: number | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
  }

  export type PositionSumAggregateOutputType = {
    level: number | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: number | null
    isActive: boolean | null
    departmentId: string | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: number | null
    isActive: boolean | null
    departmentId: string | null
    minSalary: Decimal | null
    maxSalary: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    level: number
    isActive: number
    departmentId: number
    minSalary: number
    maxSalary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    level?: true
    minSalary?: true
    maxSalary?: true
  }

  export type PositionSumAggregateInputType = {
    level?: true
    minSalary?: true
    maxSalary?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    isActive?: true
    departmentId?: true
    minSalary?: true
    maxSalary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    isActive?: true
    departmentId?: true
    minSalary?: true
    maxSalary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    isActive?: true
    departmentId?: true
    minSalary?: true
    maxSalary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    level: number
    isActive: boolean
    departmentId: string
    minSalary: Decimal | null
    maxSalary: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    isActive?: boolean
    departmentId?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    employees?: boolean | Position$employeesArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    isActive?: boolean
    departmentId?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    isActive?: boolean
    departmentId?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    isActive?: boolean
    departmentId?: boolean
    minSalary?: boolean
    maxSalary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "level" | "isActive" | "departmentId" | "minSalary" | "maxSalary" | "createdAt" | "updatedAt", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    employees?: boolean | Position$employeesArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type PositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      level: number
      isActive: boolean
      departmentId: string
      minSalary: Prisma.Decimal | null
      maxSalary: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {PositionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends Position$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Position$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'String'>
    readonly title: FieldRef<"Position", 'String'>
    readonly description: FieldRef<"Position", 'String'>
    readonly level: FieldRef<"Position", 'Int'>
    readonly isActive: FieldRef<"Position", 'Boolean'>
    readonly departmentId: FieldRef<"Position", 'String'>
    readonly minSalary: FieldRef<"Position", 'Decimal'>
    readonly maxSalary: FieldRef<"Position", 'Decimal'>
    readonly createdAt: FieldRef<"Position", 'DateTime'>
    readonly updatedAt: FieldRef<"Position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position updateManyAndReturn
   */
  export type PositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.employees
   */
  export type Position$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean | null
    industry: string | null
    taxNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    contactEmail: string | null
    contactPhone: string | null
    isActive: boolean | null
    industry: string | null
    taxNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    companyName: number
    contactEmail: number
    contactPhone: number
    address: number
    isActive: number
    industry: number
    taxNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    industry?: true
    taxNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    contactPhone?: true
    isActive?: true
    industry?: true
    taxNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    companyName?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    isActive?: true
    industry?: true
    taxNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    companyName: string
    contactEmail: string | null
    contactPhone: string | null
    address: JsonValue | null
    isActive: boolean
    industry: string | null
    taxNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    isActive?: boolean
    industry?: boolean
    taxNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccounts?: boolean | Customer$subAccountsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    ratings?: boolean | Customer$ratingsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    isActive?: boolean
    industry?: boolean
    taxNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    isActive?: boolean
    industry?: boolean
    taxNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    companyName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    isActive?: boolean
    industry?: boolean
    taxNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "contactEmail" | "contactPhone" | "address" | "isActive" | "industry" | "taxNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subAccounts?: boolean | Customer$subAccountsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    ratings?: boolean | Customer$ratingsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      subAccounts: Prisma.$SubAccountPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string
      contactEmail: string | null
      contactPhone: string | null
      address: Prisma.JsonValue | null
      isActive: boolean
      industry: string | null
      taxNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subAccounts<T extends Customer$subAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Customer$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly companyName: FieldRef<"Customer", 'String'>
    readonly contactEmail: FieldRef<"Customer", 'String'>
    readonly contactPhone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'Json'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly industry: FieldRef<"Customer", 'String'>
    readonly taxNumber: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.subAccounts
   */
  export type Customer$subAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    cursor?: SubAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.ratings
   */
  export type Customer$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model SubAccount
   */

  export type AggregateSubAccount = {
    _count: SubAccountCountAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  export type SubAccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    isActive: boolean | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubAccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    isActive: boolean | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubAccountCountAggregateOutputType = {
    id: number
    name: number
    code: number
    isActive: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubAccountMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubAccountMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubAccountCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    isActive?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccount to aggregate.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccounts
    **/
    _count?: true | SubAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountMaxAggregateInputType
  }

  export type GetSubAccountAggregateType<T extends SubAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccount[P]>
      : GetScalarType<T[P], AggregateSubAccount[P]>
  }




  export type SubAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountWhereInput
    orderBy?: SubAccountOrderByWithAggregationInput | SubAccountOrderByWithAggregationInput[]
    by: SubAccountScalarFieldEnum[] | SubAccountScalarFieldEnum
    having?: SubAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountCountAggregateInputType | true
    _min?: SubAccountMinAggregateInputType
    _max?: SubAccountMaxAggregateInputType
  }

  export type SubAccountGroupByOutputType = {
    id: string
    name: string
    code: string | null
    isActive: boolean
    customerId: string
    createdAt: Date
    updatedAt: Date
    _count: SubAccountCountAggregateOutputType | null
    _min: SubAccountMinAggregateOutputType | null
    _max: SubAccountMaxAggregateOutputType | null
  }

  type GetSubAccountGroupByPayload<T extends SubAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccount"]>

  export type SubAccountSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    isActive?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "isActive" | "customerId" | "createdAt" | "updatedAt", ExtArgs["result"]["subAccount"]>
  export type SubAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SubAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SubAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SubAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccount"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      isActive: boolean
      customerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subAccount"]>
    composites: {}
  }

  type SubAccountGetPayload<S extends boolean | null | undefined | SubAccountDefaultArgs> = $Result.GetResult<Prisma.$SubAccountPayload, S>

  type SubAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountCountAggregateInputType | true
    }

  export interface SubAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccount'], meta: { name: 'SubAccount' } }
    /**
     * Find zero or one SubAccount that matches the filter.
     * @param {SubAccountFindUniqueArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountFindUniqueArgs>(args: SelectSubset<T, SubAccountFindUniqueArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountFindUniqueOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountFindFirstArgs>(args?: SelectSubset<T, SubAccountFindFirstArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindFirstOrThrowArgs} args - Arguments to find a SubAccount
     * @example
     * // Get one SubAccount
     * const subAccount = await prisma.subAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccounts
     * const subAccounts = await prisma.subAccount.findMany()
     * 
     * // Get first 10 SubAccounts
     * const subAccounts = await prisma.subAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountFindManyArgs>(args?: SelectSubset<T, SubAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccount.
     * @param {SubAccountCreateArgs} args - Arguments to create a SubAccount.
     * @example
     * // Create one SubAccount
     * const SubAccount = await prisma.subAccount.create({
     *   data: {
     *     // ... data to create a SubAccount
     *   }
     * })
     * 
     */
    create<T extends SubAccountCreateArgs>(args: SelectSubset<T, SubAccountCreateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccounts.
     * @param {SubAccountCreateManyArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountCreateManyArgs>(args?: SelectSubset<T, SubAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubAccounts and returns the data saved in the database.
     * @param {SubAccountCreateManyAndReturnArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccount = await prisma.subAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubAccounts and only return the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SubAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubAccount.
     * @param {SubAccountDeleteArgs} args - Arguments to delete one SubAccount.
     * @example
     * // Delete one SubAccount
     * const SubAccount = await prisma.subAccount.delete({
     *   where: {
     *     // ... filter to delete one SubAccount
     *   }
     * })
     * 
     */
    delete<T extends SubAccountDeleteArgs>(args: SelectSubset<T, SubAccountDeleteArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccount.
     * @param {SubAccountUpdateArgs} args - Arguments to update one SubAccount.
     * @example
     * // Update one SubAccount
     * const subAccount = await prisma.subAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountUpdateArgs>(args: SelectSubset<T, SubAccountUpdateArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccounts.
     * @param {SubAccountDeleteManyArgs} args - Arguments to filter SubAccounts to delete.
     * @example
     * // Delete a few SubAccounts
     * const { count } = await prisma.subAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountDeleteManyArgs>(args?: SelectSubset<T, SubAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccounts
     * const subAccount = await prisma.subAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountUpdateManyArgs>(args: SelectSubset<T, SubAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts and returns the data updated in the database.
     * @param {SubAccountUpdateManyAndReturnArgs} args - Arguments to update many SubAccounts.
     * @example
     * // Update many SubAccounts
     * const subAccount = await prisma.subAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubAccounts and only return the `id`
     * const subAccountWithIdOnly = await prisma.subAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SubAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubAccount.
     * @param {SubAccountUpsertArgs} args - Arguments to update or create a SubAccount.
     * @example
     * // Update or create a SubAccount
     * const subAccount = await prisma.subAccount.upsert({
     *   create: {
     *     // ... data to create a SubAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccount we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountUpsertArgs>(args: SelectSubset<T, SubAccountUpsertArgs<ExtArgs>>): Prisma__SubAccountClient<$Result.GetResult<Prisma.$SubAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountCountArgs} args - Arguments to filter SubAccounts to count.
     * @example
     * // Count the number of SubAccounts
     * const count = await prisma.subAccount.count({
     *   where: {
     *     // ... the filter for the SubAccounts we want to count
     *   }
     * })
    **/
    count<T extends SubAccountCountArgs>(
      args?: Subset<T, SubAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountAggregateArgs>(args: Subset<T, SubAccountAggregateArgs>): Prisma.PrismaPromise<GetSubAccountAggregateType<T>>

    /**
     * Group by SubAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccount model
   */
  readonly fields: SubAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccount model
   */
  interface SubAccountFieldRefs {
    readonly id: FieldRef<"SubAccount", 'String'>
    readonly name: FieldRef<"SubAccount", 'String'>
    readonly code: FieldRef<"SubAccount", 'String'>
    readonly isActive: FieldRef<"SubAccount", 'Boolean'>
    readonly customerId: FieldRef<"SubAccount", 'String'>
    readonly createdAt: FieldRef<"SubAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubAccount findUnique
   */
  export type SubAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findUniqueOrThrow
   */
  export type SubAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount findFirst
   */
  export type SubAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findFirstOrThrow
   */
  export type SubAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccount to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount findMany
   */
  export type SubAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountOrderByWithRelationInput | SubAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccounts.
     */
    cursor?: SubAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    distinct?: SubAccountScalarFieldEnum | SubAccountScalarFieldEnum[]
  }

  /**
   * SubAccount create
   */
  export type SubAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccount.
     */
    data: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
  }

  /**
   * SubAccount createMany
   */
  export type SubAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccount createManyAndReturn
   */
  export type SubAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountCreateManyInput | SubAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccount update
   */
  export type SubAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccount.
     */
    data: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
    /**
     * Choose, which SubAccount to update.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount updateMany
   */
  export type SubAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
  }

  /**
   * SubAccount updateManyAndReturn
   */
  export type SubAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccount upsert
   */
  export type SubAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccount to update in case it exists.
     */
    where: SubAccountWhereUniqueInput
    /**
     * In case the SubAccount found by the `where` argument doesn't exist, create a new SubAccount with this data.
     */
    create: XOR<SubAccountCreateInput, SubAccountUncheckedCreateInput>
    /**
     * In case the SubAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountUpdateInput, SubAccountUncheckedUpdateInput>
  }

  /**
   * SubAccount delete
   */
  export type SubAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
    /**
     * Filter which SubAccount to delete.
     */
    where: SubAccountWhereUniqueInput
  }

  /**
   * SubAccount deleteMany
   */
  export type SubAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccounts to delete
     */
    where?: SubAccountWhereInput
    /**
     * Limit how many SubAccounts to delete.
     */
    limit?: number
  }

  /**
   * SubAccount without action
   */
  export type SubAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccount
     */
    select?: SubAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccount
     */
    omit?: SubAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    duration: number | null
    requiredEmployees: number | null
    priority: number | null
  }

  export type OrderSumAggregateOutputType = {
    duration: number | null
    requiredEmployees: number | null
    priority: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    description: string | null
    scheduledDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    location: string | null
    requiredEmployees: number | null
    priority: number | null
    specialInstructions: string | null
    status: $Enums.OrderStatus | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    description: string | null
    scheduledDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    location: string | null
    requiredEmployees: number | null
    priority: number | null
    specialInstructions: string | null
    status: $Enums.OrderStatus | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    description: number
    scheduledDate: number
    startTime: number
    endTime: number
    duration: number
    location: number
    requiredEmployees: number
    priority: number
    specialInstructions: number
    status: number
    customerId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    duration?: true
    requiredEmployees?: true
    priority?: true
  }

  export type OrderSumAggregateInputType = {
    duration?: true
    requiredEmployees?: true
    priority?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    description?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    location?: true
    requiredEmployees?: true
    priority?: true
    specialInstructions?: true
    status?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    description?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    location?: true
    requiredEmployees?: true
    priority?: true
    specialInstructions?: true
    status?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    description?: true
    scheduledDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    location?: true
    requiredEmployees?: true
    priority?: true
    specialInstructions?: true
    status?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    description: string | null
    scheduledDate: Date
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    location: string | null
    requiredEmployees: number
    priority: number
    specialInstructions: string | null
    status: $Enums.OrderStatus
    customerId: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    description?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    location?: boolean
    requiredEmployees?: boolean
    priority?: boolean
    specialInstructions?: boolean
    status?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    qualifications?: boolean | Order$qualificationsArgs<ExtArgs>
    orderAssignments?: boolean | Order$orderAssignmentsArgs<ExtArgs>
    employeeAssignments?: boolean | Order$employeeAssignmentsArgs<ExtArgs>
    ratings?: boolean | Order$ratingsArgs<ExtArgs>
    files?: boolean | Order$filesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    description?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    location?: boolean
    requiredEmployees?: boolean
    priority?: boolean
    specialInstructions?: boolean
    status?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    description?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    location?: boolean
    requiredEmployees?: boolean
    priority?: boolean
    specialInstructions?: boolean
    status?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    description?: boolean
    scheduledDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    location?: boolean
    requiredEmployees?: boolean
    priority?: boolean
    specialInstructions?: boolean
    status?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "description" | "scheduledDate" | "startTime" | "endTime" | "duration" | "location" | "requiredEmployees" | "priority" | "specialInstructions" | "status" | "customerId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    qualifications?: boolean | Order$qualificationsArgs<ExtArgs>
    orderAssignments?: boolean | Order$orderAssignmentsArgs<ExtArgs>
    employeeAssignments?: boolean | Order$employeeAssignmentsArgs<ExtArgs>
    ratings?: boolean | Order$ratingsArgs<ExtArgs>
    files?: boolean | Order$filesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      qualifications: Prisma.$OrderQualificationPayload<ExtArgs>[]
      orderAssignments: Prisma.$OrderAssignmentPayload<ExtArgs>[]
      employeeAssignments: Prisma.$AssignmentPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      description: string | null
      scheduledDate: Date
      startTime: Date | null
      endTime: Date | null
      duration: number | null
      location: string | null
      requiredEmployees: number
      priority: number
      specialInstructions: string | null
      status: $Enums.OrderStatus
      customerId: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qualifications<T extends Order$qualificationsArgs<ExtArgs> = {}>(args?: Subset<T, Order$qualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderAssignments<T extends Order$orderAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeAssignments<T extends Order$employeeAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$employeeAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Order$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Order$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Order$filesArgs<ExtArgs> = {}>(args?: Subset<T, Order$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly description: FieldRef<"Order", 'String'>
    readonly scheduledDate: FieldRef<"Order", 'DateTime'>
    readonly startTime: FieldRef<"Order", 'DateTime'>
    readonly endTime: FieldRef<"Order", 'DateTime'>
    readonly duration: FieldRef<"Order", 'Int'>
    readonly location: FieldRef<"Order", 'String'>
    readonly requiredEmployees: FieldRef<"Order", 'Int'>
    readonly priority: FieldRef<"Order", 'Int'>
    readonly specialInstructions: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly createdBy: FieldRef<"Order", 'String'>
    readonly updatedBy: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.qualifications
   */
  export type Order$qualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    where?: OrderQualificationWhereInput
    orderBy?: OrderQualificationOrderByWithRelationInput | OrderQualificationOrderByWithRelationInput[]
    cursor?: OrderQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderQualificationScalarFieldEnum | OrderQualificationScalarFieldEnum[]
  }

  /**
   * Order.orderAssignments
   */
  export type Order$orderAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    where?: OrderAssignmentWhereInput
    orderBy?: OrderAssignmentOrderByWithRelationInput | OrderAssignmentOrderByWithRelationInput[]
    cursor?: OrderAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderAssignmentScalarFieldEnum | OrderAssignmentScalarFieldEnum[]
  }

  /**
   * Order.employeeAssignments
   */
  export type Order$employeeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Order.ratings
   */
  export type Order$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Order.files
   */
  export type Order$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Qualification
   */

  export type AggregateQualification = {
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  export type QualificationAvgAggregateOutputType = {
    expiryMonths: number | null
  }

  export type QualificationSumAggregateOutputType = {
    expiryMonths: number | null
  }

  export type QualificationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    requiresCertificate: boolean | null
    expiryMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualificationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    isActive: boolean | null
    requiresCertificate: boolean | null
    expiryMonths: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualificationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    isActive: number
    requiresCertificate: number
    expiryMonths: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QualificationAvgAggregateInputType = {
    expiryMonths?: true
  }

  export type QualificationSumAggregateInputType = {
    expiryMonths?: true
  }

  export type QualificationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    requiresCertificate?: true
    expiryMonths?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualificationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    requiresCertificate?: true
    expiryMonths?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualificationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    requiresCertificate?: true
    expiryMonths?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Qualification to aggregate.
     */
    where?: QualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Qualifications to fetch.
     */
    orderBy?: QualificationOrderByWithRelationInput | QualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Qualifications
    **/
    _count?: true | QualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualificationMaxAggregateInputType
  }

  export type GetQualificationAggregateType<T extends QualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualification[P]>
      : GetScalarType<T[P], AggregateQualification[P]>
  }




  export type QualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualificationWhereInput
    orderBy?: QualificationOrderByWithAggregationInput | QualificationOrderByWithAggregationInput[]
    by: QualificationScalarFieldEnum[] | QualificationScalarFieldEnum
    having?: QualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualificationCountAggregateInputType | true
    _avg?: QualificationAvgAggregateInputType
    _sum?: QualificationSumAggregateInputType
    _min?: QualificationMinAggregateInputType
    _max?: QualificationMaxAggregateInputType
  }

  export type QualificationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string | null
    isActive: boolean
    requiresCertificate: boolean
    expiryMonths: number | null
    createdAt: Date
    updatedAt: Date
    _count: QualificationCountAggregateOutputType | null
    _avg: QualificationAvgAggregateOutputType | null
    _sum: QualificationSumAggregateOutputType | null
    _min: QualificationMinAggregateOutputType | null
    _max: QualificationMaxAggregateOutputType | null
  }

  type GetQualificationGroupByPayload<T extends QualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualificationGroupByOutputType[P]>
            : GetScalarType<T[P], QualificationGroupByOutputType[P]>
        }
      >
    >


  export type QualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeQualifications?: boolean | Qualification$employeeQualificationsArgs<ExtArgs>
    orderQualifications?: boolean | Qualification$orderQualificationsArgs<ExtArgs>
    _count?: boolean | QualificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualification"]>

  export type QualificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qualification"]>

  export type QualificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qualification"]>

  export type QualificationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QualificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "isActive" | "requiresCertificate" | "expiryMonths" | "createdAt" | "updatedAt", ExtArgs["result"]["qualification"]>
  export type QualificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeQualifications?: boolean | Qualification$employeeQualificationsArgs<ExtArgs>
    orderQualifications?: boolean | Qualification$orderQualificationsArgs<ExtArgs>
    _count?: boolean | QualificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QualificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QualificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Qualification"
    objects: {
      employeeQualifications: Prisma.$EmployeeQualificationPayload<ExtArgs>[]
      orderQualifications: Prisma.$OrderQualificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string | null
      isActive: boolean
      requiresCertificate: boolean
      expiryMonths: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qualification"]>
    composites: {}
  }

  type QualificationGetPayload<S extends boolean | null | undefined | QualificationDefaultArgs> = $Result.GetResult<Prisma.$QualificationPayload, S>

  type QualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QualificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QualificationCountAggregateInputType | true
    }

  export interface QualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Qualification'], meta: { name: 'Qualification' } }
    /**
     * Find zero or one Qualification that matches the filter.
     * @param {QualificationFindUniqueArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualificationFindUniqueArgs>(args: SelectSubset<T, QualificationFindUniqueArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qualification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QualificationFindUniqueOrThrowArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, QualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationFindFirstArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualificationFindFirstArgs>(args?: SelectSubset<T, QualificationFindFirstArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationFindFirstOrThrowArgs} args - Arguments to find a Qualification
     * @example
     * // Get one Qualification
     * const qualification = await prisma.qualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, QualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qualifications
     * const qualifications = await prisma.qualification.findMany()
     * 
     * // Get first 10 Qualifications
     * const qualifications = await prisma.qualification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualificationWithIdOnly = await prisma.qualification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualificationFindManyArgs>(args?: SelectSubset<T, QualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qualification.
     * @param {QualificationCreateArgs} args - Arguments to create a Qualification.
     * @example
     * // Create one Qualification
     * const Qualification = await prisma.qualification.create({
     *   data: {
     *     // ... data to create a Qualification
     *   }
     * })
     * 
     */
    create<T extends QualificationCreateArgs>(args: SelectSubset<T, QualificationCreateArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qualifications.
     * @param {QualificationCreateManyArgs} args - Arguments to create many Qualifications.
     * @example
     * // Create many Qualifications
     * const qualification = await prisma.qualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualificationCreateManyArgs>(args?: SelectSubset<T, QualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Qualifications and returns the data saved in the database.
     * @param {QualificationCreateManyAndReturnArgs} args - Arguments to create many Qualifications.
     * @example
     * // Create many Qualifications
     * const qualification = await prisma.qualification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Qualifications and only return the `id`
     * const qualificationWithIdOnly = await prisma.qualification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualificationCreateManyAndReturnArgs>(args?: SelectSubset<T, QualificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Qualification.
     * @param {QualificationDeleteArgs} args - Arguments to delete one Qualification.
     * @example
     * // Delete one Qualification
     * const Qualification = await prisma.qualification.delete({
     *   where: {
     *     // ... filter to delete one Qualification
     *   }
     * })
     * 
     */
    delete<T extends QualificationDeleteArgs>(args: SelectSubset<T, QualificationDeleteArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qualification.
     * @param {QualificationUpdateArgs} args - Arguments to update one Qualification.
     * @example
     * // Update one Qualification
     * const qualification = await prisma.qualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualificationUpdateArgs>(args: SelectSubset<T, QualificationUpdateArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qualifications.
     * @param {QualificationDeleteManyArgs} args - Arguments to filter Qualifications to delete.
     * @example
     * // Delete a few Qualifications
     * const { count } = await prisma.qualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualificationDeleteManyArgs>(args?: SelectSubset<T, QualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qualifications
     * const qualification = await prisma.qualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualificationUpdateManyArgs>(args: SelectSubset<T, QualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualifications and returns the data updated in the database.
     * @param {QualificationUpdateManyAndReturnArgs} args - Arguments to update many Qualifications.
     * @example
     * // Update many Qualifications
     * const qualification = await prisma.qualification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Qualifications and only return the `id`
     * const qualificationWithIdOnly = await prisma.qualification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QualificationUpdateManyAndReturnArgs>(args: SelectSubset<T, QualificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Qualification.
     * @param {QualificationUpsertArgs} args - Arguments to update or create a Qualification.
     * @example
     * // Update or create a Qualification
     * const qualification = await prisma.qualification.upsert({
     *   create: {
     *     // ... data to create a Qualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qualification we want to update
     *   }
     * })
     */
    upsert<T extends QualificationUpsertArgs>(args: SelectSubset<T, QualificationUpsertArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationCountArgs} args - Arguments to filter Qualifications to count.
     * @example
     * // Count the number of Qualifications
     * const count = await prisma.qualification.count({
     *   where: {
     *     // ... the filter for the Qualifications we want to count
     *   }
     * })
    **/
    count<T extends QualificationCountArgs>(
      args?: Subset<T, QualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualificationAggregateArgs>(args: Subset<T, QualificationAggregateArgs>): Prisma.PrismaPromise<GetQualificationAggregateType<T>>

    /**
     * Group by Qualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualificationGroupByArgs['orderBy'] }
        : { orderBy?: QualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Qualification model
   */
  readonly fields: QualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Qualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeQualifications<T extends Qualification$employeeQualificationsArgs<ExtArgs> = {}>(args?: Subset<T, Qualification$employeeQualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderQualifications<T extends Qualification$orderQualificationsArgs<ExtArgs> = {}>(args?: Subset<T, Qualification$orderQualificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Qualification model
   */
  interface QualificationFieldRefs {
    readonly id: FieldRef<"Qualification", 'String'>
    readonly name: FieldRef<"Qualification", 'String'>
    readonly description: FieldRef<"Qualification", 'String'>
    readonly category: FieldRef<"Qualification", 'String'>
    readonly isActive: FieldRef<"Qualification", 'Boolean'>
    readonly requiresCertificate: FieldRef<"Qualification", 'Boolean'>
    readonly expiryMonths: FieldRef<"Qualification", 'Int'>
    readonly createdAt: FieldRef<"Qualification", 'DateTime'>
    readonly updatedAt: FieldRef<"Qualification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Qualification findUnique
   */
  export type QualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * Filter, which Qualification to fetch.
     */
    where: QualificationWhereUniqueInput
  }

  /**
   * Qualification findUniqueOrThrow
   */
  export type QualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * Filter, which Qualification to fetch.
     */
    where: QualificationWhereUniqueInput
  }

  /**
   * Qualification findFirst
   */
  export type QualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * Filter, which Qualification to fetch.
     */
    where?: QualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Qualifications to fetch.
     */
    orderBy?: QualificationOrderByWithRelationInput | QualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Qualifications.
     */
    cursor?: QualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Qualifications.
     */
    distinct?: QualificationScalarFieldEnum | QualificationScalarFieldEnum[]
  }

  /**
   * Qualification findFirstOrThrow
   */
  export type QualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * Filter, which Qualification to fetch.
     */
    where?: QualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Qualifications to fetch.
     */
    orderBy?: QualificationOrderByWithRelationInput | QualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Qualifications.
     */
    cursor?: QualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Qualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Qualifications.
     */
    distinct?: QualificationScalarFieldEnum | QualificationScalarFieldEnum[]
  }

  /**
   * Qualification findMany
   */
  export type QualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * Filter, which Qualifications to fetch.
     */
    where?: QualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Qualifications to fetch.
     */
    orderBy?: QualificationOrderByWithRelationInput | QualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Qualifications.
     */
    cursor?: QualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Qualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Qualifications.
     */
    skip?: number
    distinct?: QualificationScalarFieldEnum | QualificationScalarFieldEnum[]
  }

  /**
   * Qualification create
   */
  export type QualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Qualification.
     */
    data: XOR<QualificationCreateInput, QualificationUncheckedCreateInput>
  }

  /**
   * Qualification createMany
   */
  export type QualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Qualifications.
     */
    data: QualificationCreateManyInput | QualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Qualification createManyAndReturn
   */
  export type QualificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * The data used to create many Qualifications.
     */
    data: QualificationCreateManyInput | QualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Qualification update
   */
  export type QualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Qualification.
     */
    data: XOR<QualificationUpdateInput, QualificationUncheckedUpdateInput>
    /**
     * Choose, which Qualification to update.
     */
    where: QualificationWhereUniqueInput
  }

  /**
   * Qualification updateMany
   */
  export type QualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Qualifications.
     */
    data: XOR<QualificationUpdateManyMutationInput, QualificationUncheckedUpdateManyInput>
    /**
     * Filter which Qualifications to update
     */
    where?: QualificationWhereInput
    /**
     * Limit how many Qualifications to update.
     */
    limit?: number
  }

  /**
   * Qualification updateManyAndReturn
   */
  export type QualificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * The data used to update Qualifications.
     */
    data: XOR<QualificationUpdateManyMutationInput, QualificationUncheckedUpdateManyInput>
    /**
     * Filter which Qualifications to update
     */
    where?: QualificationWhereInput
    /**
     * Limit how many Qualifications to update.
     */
    limit?: number
  }

  /**
   * Qualification upsert
   */
  export type QualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Qualification to update in case it exists.
     */
    where: QualificationWhereUniqueInput
    /**
     * In case the Qualification found by the `where` argument doesn't exist, create a new Qualification with this data.
     */
    create: XOR<QualificationCreateInput, QualificationUncheckedCreateInput>
    /**
     * In case the Qualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualificationUpdateInput, QualificationUncheckedUpdateInput>
  }

  /**
   * Qualification delete
   */
  export type QualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
    /**
     * Filter which Qualification to delete.
     */
    where: QualificationWhereUniqueInput
  }

  /**
   * Qualification deleteMany
   */
  export type QualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Qualifications to delete
     */
    where?: QualificationWhereInput
    /**
     * Limit how many Qualifications to delete.
     */
    limit?: number
  }

  /**
   * Qualification.employeeQualifications
   */
  export type Qualification$employeeQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    where?: EmployeeQualificationWhereInput
    orderBy?: EmployeeQualificationOrderByWithRelationInput | EmployeeQualificationOrderByWithRelationInput[]
    cursor?: EmployeeQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeQualificationScalarFieldEnum | EmployeeQualificationScalarFieldEnum[]
  }

  /**
   * Qualification.orderQualifications
   */
  export type Qualification$orderQualificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    where?: OrderQualificationWhereInput
    orderBy?: OrderQualificationOrderByWithRelationInput | OrderQualificationOrderByWithRelationInput[]
    cursor?: OrderQualificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderQualificationScalarFieldEnum | OrderQualificationScalarFieldEnum[]
  }

  /**
   * Qualification without action
   */
  export type QualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qualification
     */
    select?: QualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Qualification
     */
    omit?: QualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualificationInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeQualification
   */

  export type AggregateEmployeeQualification = {
    _count: EmployeeQualificationCountAggregateOutputType | null
    _avg: EmployeeQualificationAvgAggregateOutputType | null
    _sum: EmployeeQualificationSumAggregateOutputType | null
    _min: EmployeeQualificationMinAggregateOutputType | null
    _max: EmployeeQualificationMaxAggregateOutputType | null
  }

  export type EmployeeQualificationAvgAggregateOutputType = {
    proficiencyLevel: number | null
  }

  export type EmployeeQualificationSumAggregateOutputType = {
    proficiencyLevel: number | null
  }

  export type EmployeeQualificationMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    qualificationId: string | null
    acquiredDate: Date | null
    expiryDate: Date | null
    certificateUrl: string | null
    isVerified: boolean | null
    proficiencyLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeQualificationMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    qualificationId: string | null
    acquiredDate: Date | null
    expiryDate: Date | null
    certificateUrl: string | null
    isVerified: boolean | null
    proficiencyLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeQualificationCountAggregateOutputType = {
    id: number
    employeeId: number
    qualificationId: number
    acquiredDate: number
    expiryDate: number
    certificateUrl: number
    isVerified: number
    proficiencyLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeQualificationAvgAggregateInputType = {
    proficiencyLevel?: true
  }

  export type EmployeeQualificationSumAggregateInputType = {
    proficiencyLevel?: true
  }

  export type EmployeeQualificationMinAggregateInputType = {
    id?: true
    employeeId?: true
    qualificationId?: true
    acquiredDate?: true
    expiryDate?: true
    certificateUrl?: true
    isVerified?: true
    proficiencyLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeQualificationMaxAggregateInputType = {
    id?: true
    employeeId?: true
    qualificationId?: true
    acquiredDate?: true
    expiryDate?: true
    certificateUrl?: true
    isVerified?: true
    proficiencyLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeQualificationCountAggregateInputType = {
    id?: true
    employeeId?: true
    qualificationId?: true
    acquiredDate?: true
    expiryDate?: true
    certificateUrl?: true
    isVerified?: true
    proficiencyLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeQualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeQualification to aggregate.
     */
    where?: EmployeeQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeQualifications to fetch.
     */
    orderBy?: EmployeeQualificationOrderByWithRelationInput | EmployeeQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeQualifications
    **/
    _count?: true | EmployeeQualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeQualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeQualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeQualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeQualificationMaxAggregateInputType
  }

  export type GetEmployeeQualificationAggregateType<T extends EmployeeQualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeQualification[P]>
      : GetScalarType<T[P], AggregateEmployeeQualification[P]>
  }




  export type EmployeeQualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeQualificationWhereInput
    orderBy?: EmployeeQualificationOrderByWithAggregationInput | EmployeeQualificationOrderByWithAggregationInput[]
    by: EmployeeQualificationScalarFieldEnum[] | EmployeeQualificationScalarFieldEnum
    having?: EmployeeQualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeQualificationCountAggregateInputType | true
    _avg?: EmployeeQualificationAvgAggregateInputType
    _sum?: EmployeeQualificationSumAggregateInputType
    _min?: EmployeeQualificationMinAggregateInputType
    _max?: EmployeeQualificationMaxAggregateInputType
  }

  export type EmployeeQualificationGroupByOutputType = {
    id: string
    employeeId: string
    qualificationId: string
    acquiredDate: Date
    expiryDate: Date | null
    certificateUrl: string | null
    isVerified: boolean
    proficiencyLevel: number
    createdAt: Date
    updatedAt: Date
    _count: EmployeeQualificationCountAggregateOutputType | null
    _avg: EmployeeQualificationAvgAggregateOutputType | null
    _sum: EmployeeQualificationSumAggregateOutputType | null
    _min: EmployeeQualificationMinAggregateOutputType | null
    _max: EmployeeQualificationMaxAggregateOutputType | null
  }

  type GetEmployeeQualificationGroupByPayload<T extends EmployeeQualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeQualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeQualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeQualificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeQualificationGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeQualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    qualificationId?: boolean
    acquiredDate?: boolean
    expiryDate?: boolean
    certificateUrl?: boolean
    isVerified?: boolean
    proficiencyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeQualification"]>

  export type EmployeeQualificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    qualificationId?: boolean
    acquiredDate?: boolean
    expiryDate?: boolean
    certificateUrl?: boolean
    isVerified?: boolean
    proficiencyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeQualification"]>

  export type EmployeeQualificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    qualificationId?: boolean
    acquiredDate?: boolean
    expiryDate?: boolean
    certificateUrl?: boolean
    isVerified?: boolean
    proficiencyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeQualification"]>

  export type EmployeeQualificationSelectScalar = {
    id?: boolean
    employeeId?: boolean
    qualificationId?: boolean
    acquiredDate?: boolean
    expiryDate?: boolean
    certificateUrl?: boolean
    isVerified?: boolean
    proficiencyLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeQualificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "qualificationId" | "acquiredDate" | "expiryDate" | "certificateUrl" | "isVerified" | "proficiencyLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeQualification"]>
  export type EmployeeQualificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }
  export type EmployeeQualificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }
  export type EmployeeQualificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }

  export type $EmployeeQualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeQualification"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      qualification: Prisma.$QualificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      qualificationId: string
      acquiredDate: Date
      expiryDate: Date | null
      certificateUrl: string | null
      isVerified: boolean
      proficiencyLevel: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeQualification"]>
    composites: {}
  }

  type EmployeeQualificationGetPayload<S extends boolean | null | undefined | EmployeeQualificationDefaultArgs> = $Result.GetResult<Prisma.$EmployeeQualificationPayload, S>

  type EmployeeQualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeQualificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeQualificationCountAggregateInputType | true
    }

  export interface EmployeeQualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeQualification'], meta: { name: 'EmployeeQualification' } }
    /**
     * Find zero or one EmployeeQualification that matches the filter.
     * @param {EmployeeQualificationFindUniqueArgs} args - Arguments to find a EmployeeQualification
     * @example
     * // Get one EmployeeQualification
     * const employeeQualification = await prisma.employeeQualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeQualificationFindUniqueArgs>(args: SelectSubset<T, EmployeeQualificationFindUniqueArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeQualification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeQualificationFindUniqueOrThrowArgs} args - Arguments to find a EmployeeQualification
     * @example
     * // Get one EmployeeQualification
     * const employeeQualification = await prisma.employeeQualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeQualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeQualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeQualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationFindFirstArgs} args - Arguments to find a EmployeeQualification
     * @example
     * // Get one EmployeeQualification
     * const employeeQualification = await prisma.employeeQualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeQualificationFindFirstArgs>(args?: SelectSubset<T, EmployeeQualificationFindFirstArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeQualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationFindFirstOrThrowArgs} args - Arguments to find a EmployeeQualification
     * @example
     * // Get one EmployeeQualification
     * const employeeQualification = await prisma.employeeQualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeQualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeQualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeQualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeQualifications
     * const employeeQualifications = await prisma.employeeQualification.findMany()
     * 
     * // Get first 10 EmployeeQualifications
     * const employeeQualifications = await prisma.employeeQualification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeQualificationWithIdOnly = await prisma.employeeQualification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeQualificationFindManyArgs>(args?: SelectSubset<T, EmployeeQualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeQualification.
     * @param {EmployeeQualificationCreateArgs} args - Arguments to create a EmployeeQualification.
     * @example
     * // Create one EmployeeQualification
     * const EmployeeQualification = await prisma.employeeQualification.create({
     *   data: {
     *     // ... data to create a EmployeeQualification
     *   }
     * })
     * 
     */
    create<T extends EmployeeQualificationCreateArgs>(args: SelectSubset<T, EmployeeQualificationCreateArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeQualifications.
     * @param {EmployeeQualificationCreateManyArgs} args - Arguments to create many EmployeeQualifications.
     * @example
     * // Create many EmployeeQualifications
     * const employeeQualification = await prisma.employeeQualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeQualificationCreateManyArgs>(args?: SelectSubset<T, EmployeeQualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeQualifications and returns the data saved in the database.
     * @param {EmployeeQualificationCreateManyAndReturnArgs} args - Arguments to create many EmployeeQualifications.
     * @example
     * // Create many EmployeeQualifications
     * const employeeQualification = await prisma.employeeQualification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeQualifications and only return the `id`
     * const employeeQualificationWithIdOnly = await prisma.employeeQualification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeQualificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeQualificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeQualification.
     * @param {EmployeeQualificationDeleteArgs} args - Arguments to delete one EmployeeQualification.
     * @example
     * // Delete one EmployeeQualification
     * const EmployeeQualification = await prisma.employeeQualification.delete({
     *   where: {
     *     // ... filter to delete one EmployeeQualification
     *   }
     * })
     * 
     */
    delete<T extends EmployeeQualificationDeleteArgs>(args: SelectSubset<T, EmployeeQualificationDeleteArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeQualification.
     * @param {EmployeeQualificationUpdateArgs} args - Arguments to update one EmployeeQualification.
     * @example
     * // Update one EmployeeQualification
     * const employeeQualification = await prisma.employeeQualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeQualificationUpdateArgs>(args: SelectSubset<T, EmployeeQualificationUpdateArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeQualifications.
     * @param {EmployeeQualificationDeleteManyArgs} args - Arguments to filter EmployeeQualifications to delete.
     * @example
     * // Delete a few EmployeeQualifications
     * const { count } = await prisma.employeeQualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeQualificationDeleteManyArgs>(args?: SelectSubset<T, EmployeeQualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeQualifications
     * const employeeQualification = await prisma.employeeQualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeQualificationUpdateManyArgs>(args: SelectSubset<T, EmployeeQualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeQualifications and returns the data updated in the database.
     * @param {EmployeeQualificationUpdateManyAndReturnArgs} args - Arguments to update many EmployeeQualifications.
     * @example
     * // Update many EmployeeQualifications
     * const employeeQualification = await prisma.employeeQualification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeQualifications and only return the `id`
     * const employeeQualificationWithIdOnly = await prisma.employeeQualification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeQualificationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeQualificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeQualification.
     * @param {EmployeeQualificationUpsertArgs} args - Arguments to update or create a EmployeeQualification.
     * @example
     * // Update or create a EmployeeQualification
     * const employeeQualification = await prisma.employeeQualification.upsert({
     *   create: {
     *     // ... data to create a EmployeeQualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeQualification we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeQualificationUpsertArgs>(args: SelectSubset<T, EmployeeQualificationUpsertArgs<ExtArgs>>): Prisma__EmployeeQualificationClient<$Result.GetResult<Prisma.$EmployeeQualificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationCountArgs} args - Arguments to filter EmployeeQualifications to count.
     * @example
     * // Count the number of EmployeeQualifications
     * const count = await prisma.employeeQualification.count({
     *   where: {
     *     // ... the filter for the EmployeeQualifications we want to count
     *   }
     * })
    **/
    count<T extends EmployeeQualificationCountArgs>(
      args?: Subset<T, EmployeeQualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeQualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeQualificationAggregateArgs>(args: Subset<T, EmployeeQualificationAggregateArgs>): Prisma.PrismaPromise<GetEmployeeQualificationAggregateType<T>>

    /**
     * Group by EmployeeQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeQualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeQualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeQualificationGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeQualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeQualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeQualification model
   */
  readonly fields: EmployeeQualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeQualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeQualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qualification<T extends QualificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QualificationDefaultArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeQualification model
   */
  interface EmployeeQualificationFieldRefs {
    readonly id: FieldRef<"EmployeeQualification", 'String'>
    readonly employeeId: FieldRef<"EmployeeQualification", 'String'>
    readonly qualificationId: FieldRef<"EmployeeQualification", 'String'>
    readonly acquiredDate: FieldRef<"EmployeeQualification", 'DateTime'>
    readonly expiryDate: FieldRef<"EmployeeQualification", 'DateTime'>
    readonly certificateUrl: FieldRef<"EmployeeQualification", 'String'>
    readonly isVerified: FieldRef<"EmployeeQualification", 'Boolean'>
    readonly proficiencyLevel: FieldRef<"EmployeeQualification", 'Int'>
    readonly createdAt: FieldRef<"EmployeeQualification", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeQualification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeQualification findUnique
   */
  export type EmployeeQualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeQualification to fetch.
     */
    where: EmployeeQualificationWhereUniqueInput
  }

  /**
   * EmployeeQualification findUniqueOrThrow
   */
  export type EmployeeQualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeQualification to fetch.
     */
    where: EmployeeQualificationWhereUniqueInput
  }

  /**
   * EmployeeQualification findFirst
   */
  export type EmployeeQualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeQualification to fetch.
     */
    where?: EmployeeQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeQualifications to fetch.
     */
    orderBy?: EmployeeQualificationOrderByWithRelationInput | EmployeeQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeQualifications.
     */
    cursor?: EmployeeQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeQualifications.
     */
    distinct?: EmployeeQualificationScalarFieldEnum | EmployeeQualificationScalarFieldEnum[]
  }

  /**
   * EmployeeQualification findFirstOrThrow
   */
  export type EmployeeQualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeQualification to fetch.
     */
    where?: EmployeeQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeQualifications to fetch.
     */
    orderBy?: EmployeeQualificationOrderByWithRelationInput | EmployeeQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeQualifications.
     */
    cursor?: EmployeeQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeQualifications.
     */
    distinct?: EmployeeQualificationScalarFieldEnum | EmployeeQualificationScalarFieldEnum[]
  }

  /**
   * EmployeeQualification findMany
   */
  export type EmployeeQualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeQualifications to fetch.
     */
    where?: EmployeeQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeQualifications to fetch.
     */
    orderBy?: EmployeeQualificationOrderByWithRelationInput | EmployeeQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeQualifications.
     */
    cursor?: EmployeeQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeQualifications.
     */
    skip?: number
    distinct?: EmployeeQualificationScalarFieldEnum | EmployeeQualificationScalarFieldEnum[]
  }

  /**
   * EmployeeQualification create
   */
  export type EmployeeQualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeQualification.
     */
    data: XOR<EmployeeQualificationCreateInput, EmployeeQualificationUncheckedCreateInput>
  }

  /**
   * EmployeeQualification createMany
   */
  export type EmployeeQualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeQualifications.
     */
    data: EmployeeQualificationCreateManyInput | EmployeeQualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeQualification createManyAndReturn
   */
  export type EmployeeQualificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeQualifications.
     */
    data: EmployeeQualificationCreateManyInput | EmployeeQualificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeQualification update
   */
  export type EmployeeQualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeQualification.
     */
    data: XOR<EmployeeQualificationUpdateInput, EmployeeQualificationUncheckedUpdateInput>
    /**
     * Choose, which EmployeeQualification to update.
     */
    where: EmployeeQualificationWhereUniqueInput
  }

  /**
   * EmployeeQualification updateMany
   */
  export type EmployeeQualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeQualifications.
     */
    data: XOR<EmployeeQualificationUpdateManyMutationInput, EmployeeQualificationUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeQualifications to update
     */
    where?: EmployeeQualificationWhereInput
    /**
     * Limit how many EmployeeQualifications to update.
     */
    limit?: number
  }

  /**
   * EmployeeQualification updateManyAndReturn
   */
  export type EmployeeQualificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeQualifications.
     */
    data: XOR<EmployeeQualificationUpdateManyMutationInput, EmployeeQualificationUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeQualifications to update
     */
    where?: EmployeeQualificationWhereInput
    /**
     * Limit how many EmployeeQualifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeQualification upsert
   */
  export type EmployeeQualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeQualification to update in case it exists.
     */
    where: EmployeeQualificationWhereUniqueInput
    /**
     * In case the EmployeeQualification found by the `where` argument doesn't exist, create a new EmployeeQualification with this data.
     */
    create: XOR<EmployeeQualificationCreateInput, EmployeeQualificationUncheckedCreateInput>
    /**
     * In case the EmployeeQualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeQualificationUpdateInput, EmployeeQualificationUncheckedUpdateInput>
  }

  /**
   * EmployeeQualification delete
   */
  export type EmployeeQualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
    /**
     * Filter which EmployeeQualification to delete.
     */
    where: EmployeeQualificationWhereUniqueInput
  }

  /**
   * EmployeeQualification deleteMany
   */
  export type EmployeeQualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeQualifications to delete
     */
    where?: EmployeeQualificationWhereInput
    /**
     * Limit how many EmployeeQualifications to delete.
     */
    limit?: number
  }

  /**
   * EmployeeQualification without action
   */
  export type EmployeeQualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeQualification
     */
    select?: EmployeeQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeQualification
     */
    omit?: EmployeeQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeQualificationInclude<ExtArgs> | null
  }


  /**
   * Model OrderQualification
   */

  export type AggregateOrderQualification = {
    _count: OrderQualificationCountAggregateOutputType | null
    _avg: OrderQualificationAvgAggregateOutputType | null
    _sum: OrderQualificationSumAggregateOutputType | null
    _min: OrderQualificationMinAggregateOutputType | null
    _max: OrderQualificationMaxAggregateOutputType | null
  }

  export type OrderQualificationAvgAggregateOutputType = {
    minProficiency: number | null
  }

  export type OrderQualificationSumAggregateOutputType = {
    minProficiency: number | null
  }

  export type OrderQualificationMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    qualificationId: string | null
    required: boolean | null
    minProficiency: number | null
  }

  export type OrderQualificationMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    qualificationId: string | null
    required: boolean | null
    minProficiency: number | null
  }

  export type OrderQualificationCountAggregateOutputType = {
    id: number
    orderId: number
    qualificationId: number
    required: number
    minProficiency: number
    _all: number
  }


  export type OrderQualificationAvgAggregateInputType = {
    minProficiency?: true
  }

  export type OrderQualificationSumAggregateInputType = {
    minProficiency?: true
  }

  export type OrderQualificationMinAggregateInputType = {
    id?: true
    orderId?: true
    qualificationId?: true
    required?: true
    minProficiency?: true
  }

  export type OrderQualificationMaxAggregateInputType = {
    id?: true
    orderId?: true
    qualificationId?: true
    required?: true
    minProficiency?: true
  }

  export type OrderQualificationCountAggregateInputType = {
    id?: true
    orderId?: true
    qualificationId?: true
    required?: true
    minProficiency?: true
    _all?: true
  }

  export type OrderQualificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderQualification to aggregate.
     */
    where?: OrderQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderQualifications to fetch.
     */
    orderBy?: OrderQualificationOrderByWithRelationInput | OrderQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderQualifications
    **/
    _count?: true | OrderQualificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderQualificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderQualificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderQualificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderQualificationMaxAggregateInputType
  }

  export type GetOrderQualificationAggregateType<T extends OrderQualificationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderQualification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderQualification[P]>
      : GetScalarType<T[P], AggregateOrderQualification[P]>
  }




  export type OrderQualificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderQualificationWhereInput
    orderBy?: OrderQualificationOrderByWithAggregationInput | OrderQualificationOrderByWithAggregationInput[]
    by: OrderQualificationScalarFieldEnum[] | OrderQualificationScalarFieldEnum
    having?: OrderQualificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderQualificationCountAggregateInputType | true
    _avg?: OrderQualificationAvgAggregateInputType
    _sum?: OrderQualificationSumAggregateInputType
    _min?: OrderQualificationMinAggregateInputType
    _max?: OrderQualificationMaxAggregateInputType
  }

  export type OrderQualificationGroupByOutputType = {
    id: string
    orderId: string
    qualificationId: string
    required: boolean
    minProficiency: number
    _count: OrderQualificationCountAggregateOutputType | null
    _avg: OrderQualificationAvgAggregateOutputType | null
    _sum: OrderQualificationSumAggregateOutputType | null
    _min: OrderQualificationMinAggregateOutputType | null
    _max: OrderQualificationMaxAggregateOutputType | null
  }

  type GetOrderQualificationGroupByPayload<T extends OrderQualificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderQualificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderQualificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderQualificationGroupByOutputType[P]>
            : GetScalarType<T[P], OrderQualificationGroupByOutputType[P]>
        }
      >
    >


  export type OrderQualificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    qualificationId?: boolean
    required?: boolean
    minProficiency?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderQualification"]>

  export type OrderQualificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    qualificationId?: boolean
    required?: boolean
    minProficiency?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderQualification"]>

  export type OrderQualificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    qualificationId?: boolean
    required?: boolean
    minProficiency?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderQualification"]>

  export type OrderQualificationSelectScalar = {
    id?: boolean
    orderId?: boolean
    qualificationId?: boolean
    required?: boolean
    minProficiency?: boolean
  }

  export type OrderQualificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "qualificationId" | "required" | "minProficiency", ExtArgs["result"]["orderQualification"]>
  export type OrderQualificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }
  export type OrderQualificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }
  export type OrderQualificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    qualification?: boolean | QualificationDefaultArgs<ExtArgs>
  }

  export type $OrderQualificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderQualification"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      qualification: Prisma.$QualificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      qualificationId: string
      required: boolean
      minProficiency: number
    }, ExtArgs["result"]["orderQualification"]>
    composites: {}
  }

  type OrderQualificationGetPayload<S extends boolean | null | undefined | OrderQualificationDefaultArgs> = $Result.GetResult<Prisma.$OrderQualificationPayload, S>

  type OrderQualificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderQualificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderQualificationCountAggregateInputType | true
    }

  export interface OrderQualificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderQualification'], meta: { name: 'OrderQualification' } }
    /**
     * Find zero or one OrderQualification that matches the filter.
     * @param {OrderQualificationFindUniqueArgs} args - Arguments to find a OrderQualification
     * @example
     * // Get one OrderQualification
     * const orderQualification = await prisma.orderQualification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderQualificationFindUniqueArgs>(args: SelectSubset<T, OrderQualificationFindUniqueArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderQualification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderQualificationFindUniqueOrThrowArgs} args - Arguments to find a OrderQualification
     * @example
     * // Get one OrderQualification
     * const orderQualification = await prisma.orderQualification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderQualificationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderQualificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderQualification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationFindFirstArgs} args - Arguments to find a OrderQualification
     * @example
     * // Get one OrderQualification
     * const orderQualification = await prisma.orderQualification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderQualificationFindFirstArgs>(args?: SelectSubset<T, OrderQualificationFindFirstArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderQualification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationFindFirstOrThrowArgs} args - Arguments to find a OrderQualification
     * @example
     * // Get one OrderQualification
     * const orderQualification = await prisma.orderQualification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderQualificationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderQualificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderQualifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderQualifications
     * const orderQualifications = await prisma.orderQualification.findMany()
     * 
     * // Get first 10 OrderQualifications
     * const orderQualifications = await prisma.orderQualification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderQualificationWithIdOnly = await prisma.orderQualification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderQualificationFindManyArgs>(args?: SelectSubset<T, OrderQualificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderQualification.
     * @param {OrderQualificationCreateArgs} args - Arguments to create a OrderQualification.
     * @example
     * // Create one OrderQualification
     * const OrderQualification = await prisma.orderQualification.create({
     *   data: {
     *     // ... data to create a OrderQualification
     *   }
     * })
     * 
     */
    create<T extends OrderQualificationCreateArgs>(args: SelectSubset<T, OrderQualificationCreateArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderQualifications.
     * @param {OrderQualificationCreateManyArgs} args - Arguments to create many OrderQualifications.
     * @example
     * // Create many OrderQualifications
     * const orderQualification = await prisma.orderQualification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderQualificationCreateManyArgs>(args?: SelectSubset<T, OrderQualificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderQualifications and returns the data saved in the database.
     * @param {OrderQualificationCreateManyAndReturnArgs} args - Arguments to create many OrderQualifications.
     * @example
     * // Create many OrderQualifications
     * const orderQualification = await prisma.orderQualification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderQualifications and only return the `id`
     * const orderQualificationWithIdOnly = await prisma.orderQualification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderQualificationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderQualificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderQualification.
     * @param {OrderQualificationDeleteArgs} args - Arguments to delete one OrderQualification.
     * @example
     * // Delete one OrderQualification
     * const OrderQualification = await prisma.orderQualification.delete({
     *   where: {
     *     // ... filter to delete one OrderQualification
     *   }
     * })
     * 
     */
    delete<T extends OrderQualificationDeleteArgs>(args: SelectSubset<T, OrderQualificationDeleteArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderQualification.
     * @param {OrderQualificationUpdateArgs} args - Arguments to update one OrderQualification.
     * @example
     * // Update one OrderQualification
     * const orderQualification = await prisma.orderQualification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderQualificationUpdateArgs>(args: SelectSubset<T, OrderQualificationUpdateArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderQualifications.
     * @param {OrderQualificationDeleteManyArgs} args - Arguments to filter OrderQualifications to delete.
     * @example
     * // Delete a few OrderQualifications
     * const { count } = await prisma.orderQualification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderQualificationDeleteManyArgs>(args?: SelectSubset<T, OrderQualificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderQualifications
     * const orderQualification = await prisma.orderQualification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderQualificationUpdateManyArgs>(args: SelectSubset<T, OrderQualificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderQualifications and returns the data updated in the database.
     * @param {OrderQualificationUpdateManyAndReturnArgs} args - Arguments to update many OrderQualifications.
     * @example
     * // Update many OrderQualifications
     * const orderQualification = await prisma.orderQualification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderQualifications and only return the `id`
     * const orderQualificationWithIdOnly = await prisma.orderQualification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderQualificationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderQualificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderQualification.
     * @param {OrderQualificationUpsertArgs} args - Arguments to update or create a OrderQualification.
     * @example
     * // Update or create a OrderQualification
     * const orderQualification = await prisma.orderQualification.upsert({
     *   create: {
     *     // ... data to create a OrderQualification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderQualification we want to update
     *   }
     * })
     */
    upsert<T extends OrderQualificationUpsertArgs>(args: SelectSubset<T, OrderQualificationUpsertArgs<ExtArgs>>): Prisma__OrderQualificationClient<$Result.GetResult<Prisma.$OrderQualificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderQualifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationCountArgs} args - Arguments to filter OrderQualifications to count.
     * @example
     * // Count the number of OrderQualifications
     * const count = await prisma.orderQualification.count({
     *   where: {
     *     // ... the filter for the OrderQualifications we want to count
     *   }
     * })
    **/
    count<T extends OrderQualificationCountArgs>(
      args?: Subset<T, OrderQualificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderQualificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderQualificationAggregateArgs>(args: Subset<T, OrderQualificationAggregateArgs>): Prisma.PrismaPromise<GetOrderQualificationAggregateType<T>>

    /**
     * Group by OrderQualification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderQualificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderQualificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderQualificationGroupByArgs['orderBy'] }
        : { orderBy?: OrderQualificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderQualificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderQualificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderQualification model
   */
  readonly fields: OrderQualificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderQualification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderQualificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qualification<T extends QualificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QualificationDefaultArgs<ExtArgs>>): Prisma__QualificationClient<$Result.GetResult<Prisma.$QualificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderQualification model
   */
  interface OrderQualificationFieldRefs {
    readonly id: FieldRef<"OrderQualification", 'String'>
    readonly orderId: FieldRef<"OrderQualification", 'String'>
    readonly qualificationId: FieldRef<"OrderQualification", 'String'>
    readonly required: FieldRef<"OrderQualification", 'Boolean'>
    readonly minProficiency: FieldRef<"OrderQualification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderQualification findUnique
   */
  export type OrderQualificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * Filter, which OrderQualification to fetch.
     */
    where: OrderQualificationWhereUniqueInput
  }

  /**
   * OrderQualification findUniqueOrThrow
   */
  export type OrderQualificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * Filter, which OrderQualification to fetch.
     */
    where: OrderQualificationWhereUniqueInput
  }

  /**
   * OrderQualification findFirst
   */
  export type OrderQualificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * Filter, which OrderQualification to fetch.
     */
    where?: OrderQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderQualifications to fetch.
     */
    orderBy?: OrderQualificationOrderByWithRelationInput | OrderQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderQualifications.
     */
    cursor?: OrderQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderQualifications.
     */
    distinct?: OrderQualificationScalarFieldEnum | OrderQualificationScalarFieldEnum[]
  }

  /**
   * OrderQualification findFirstOrThrow
   */
  export type OrderQualificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * Filter, which OrderQualification to fetch.
     */
    where?: OrderQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderQualifications to fetch.
     */
    orderBy?: OrderQualificationOrderByWithRelationInput | OrderQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderQualifications.
     */
    cursor?: OrderQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderQualifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderQualifications.
     */
    distinct?: OrderQualificationScalarFieldEnum | OrderQualificationScalarFieldEnum[]
  }

  /**
   * OrderQualification findMany
   */
  export type OrderQualificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * Filter, which OrderQualifications to fetch.
     */
    where?: OrderQualificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderQualifications to fetch.
     */
    orderBy?: OrderQualificationOrderByWithRelationInput | OrderQualificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderQualifications.
     */
    cursor?: OrderQualificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderQualifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderQualifications.
     */
    skip?: number
    distinct?: OrderQualificationScalarFieldEnum | OrderQualificationScalarFieldEnum[]
  }

  /**
   * OrderQualification create
   */
  export type OrderQualificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderQualification.
     */
    data: XOR<OrderQualificationCreateInput, OrderQualificationUncheckedCreateInput>
  }

  /**
   * OrderQualification createMany
   */
  export type OrderQualificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderQualifications.
     */
    data: OrderQualificationCreateManyInput | OrderQualificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderQualification createManyAndReturn
   */
  export type OrderQualificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * The data used to create many OrderQualifications.
     */
    data: OrderQualificationCreateManyInput | OrderQualificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderQualification update
   */
  export type OrderQualificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderQualification.
     */
    data: XOR<OrderQualificationUpdateInput, OrderQualificationUncheckedUpdateInput>
    /**
     * Choose, which OrderQualification to update.
     */
    where: OrderQualificationWhereUniqueInput
  }

  /**
   * OrderQualification updateMany
   */
  export type OrderQualificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderQualifications.
     */
    data: XOR<OrderQualificationUpdateManyMutationInput, OrderQualificationUncheckedUpdateManyInput>
    /**
     * Filter which OrderQualifications to update
     */
    where?: OrderQualificationWhereInput
    /**
     * Limit how many OrderQualifications to update.
     */
    limit?: number
  }

  /**
   * OrderQualification updateManyAndReturn
   */
  export type OrderQualificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * The data used to update OrderQualifications.
     */
    data: XOR<OrderQualificationUpdateManyMutationInput, OrderQualificationUncheckedUpdateManyInput>
    /**
     * Filter which OrderQualifications to update
     */
    where?: OrderQualificationWhereInput
    /**
     * Limit how many OrderQualifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderQualification upsert
   */
  export type OrderQualificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderQualification to update in case it exists.
     */
    where: OrderQualificationWhereUniqueInput
    /**
     * In case the OrderQualification found by the `where` argument doesn't exist, create a new OrderQualification with this data.
     */
    create: XOR<OrderQualificationCreateInput, OrderQualificationUncheckedCreateInput>
    /**
     * In case the OrderQualification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderQualificationUpdateInput, OrderQualificationUncheckedUpdateInput>
  }

  /**
   * OrderQualification delete
   */
  export type OrderQualificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
    /**
     * Filter which OrderQualification to delete.
     */
    where: OrderQualificationWhereUniqueInput
  }

  /**
   * OrderQualification deleteMany
   */
  export type OrderQualificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderQualifications to delete
     */
    where?: OrderQualificationWhereInput
    /**
     * Limit how many OrderQualifications to delete.
     */
    limit?: number
  }

  /**
   * OrderQualification without action
   */
  export type OrderQualificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderQualification
     */
    select?: OrderQualificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderQualification
     */
    omit?: OrderQualificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderQualificationInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    estimatedHours: Decimal | null
    actualHours: Decimal | null
  }

  export type AssignmentSumAggregateOutputType = {
    estimatedHours: Decimal | null
    actualHours: Decimal | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    employeeId: string | null
    assignedDate: Date | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.AssignmentStatus | null
    tier: $Enums.AssignmentTier | null
    estimatedHours: Decimal | null
    actualHours: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    employeeId: string | null
    assignedDate: Date | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.AssignmentStatus | null
    tier: $Enums.AssignmentTier | null
    estimatedHours: Decimal | null
    actualHours: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    orderId: number
    employeeId: number
    assignedDate: number
    startDate: number
    endDate: number
    status: number
    tier: number
    estimatedHours: number
    actualHours: number
    notes: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    estimatedHours?: true
    actualHours?: true
  }

  export type AssignmentSumAggregateInputType = {
    estimatedHours?: true
    actualHours?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    assignedDate?: true
    startDate?: true
    endDate?: true
    status?: true
    tier?: true
    estimatedHours?: true
    actualHours?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    assignedDate?: true
    startDate?: true
    endDate?: true
    status?: true
    tier?: true
    estimatedHours?: true
    actualHours?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    assignedDate?: true
    startDate?: true
    endDate?: true
    status?: true
    tier?: true
    estimatedHours?: true
    actualHours?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    orderId: string | null
    employeeId: string
    assignedDate: Date
    startDate: Date | null
    endDate: Date | null
    status: $Enums.AssignmentStatus
    tier: $Enums.AssignmentTier
    estimatedHours: Decimal | null
    actualHours: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    assignedDate?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    tier?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    order?: boolean | Assignment$orderArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    files?: boolean | Assignment$filesArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    assignedDate?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    tier?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    order?: boolean | Assignment$orderArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    assignedDate?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    tier?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    order?: boolean | Assignment$orderArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    assignedDate?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    tier?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "employeeId" | "assignedDate" | "startDate" | "endDate" | "status" | "tier" | "estimatedHours" | "actualHours" | "notes" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Assignment$orderArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    files?: boolean | Assignment$filesArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Assignment$orderArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Assignment$orderArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      employee: Prisma.$EmployeePayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string | null
      employeeId: string
      assignedDate: Date
      startDate: Date | null
      endDate: Date | null
      status: $Enums.AssignmentStatus
      tier: $Enums.AssignmentTier
      estimatedHours: Prisma.Decimal | null
      actualHours: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {AssignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Assignment$orderArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends Assignment$filesArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly orderId: FieldRef<"Assignment", 'String'>
    readonly employeeId: FieldRef<"Assignment", 'String'>
    readonly assignedDate: FieldRef<"Assignment", 'DateTime'>
    readonly startDate: FieldRef<"Assignment", 'DateTime'>
    readonly endDate: FieldRef<"Assignment", 'DateTime'>
    readonly status: FieldRef<"Assignment", 'AssignmentStatus'>
    readonly tier: FieldRef<"Assignment", 'AssignmentTier'>
    readonly estimatedHours: FieldRef<"Assignment", 'Decimal'>
    readonly actualHours: FieldRef<"Assignment", 'Decimal'>
    readonly notes: FieldRef<"Assignment", 'String'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
    readonly createdBy: FieldRef<"Assignment", 'String'>
    readonly updatedBy: FieldRef<"Assignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment updateManyAndReturn
   */
  export type AssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment.order
   */
  export type Assignment$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Assignment.files
   */
  export type Assignment$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model OrderAssignment
   */

  export type AggregateOrderAssignment = {
    _count: OrderAssignmentCountAggregateOutputType | null
    _avg: OrderAssignmentAvgAggregateOutputType | null
    _sum: OrderAssignmentSumAggregateOutputType | null
    _min: OrderAssignmentMinAggregateOutputType | null
    _max: OrderAssignmentMaxAggregateOutputType | null
  }

  export type OrderAssignmentAvgAggregateOutputType = {
    hourlyRate: Decimal | null
  }

  export type OrderAssignmentSumAggregateOutputType = {
    hourlyRate: Decimal | null
  }

  export type OrderAssignmentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    employeeId: string | null
    role: string | null
    hourlyRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderAssignmentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    employeeId: string | null
    role: string | null
    hourlyRate: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderAssignmentCountAggregateOutputType = {
    id: number
    orderId: number
    employeeId: number
    role: number
    hourlyRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAssignmentAvgAggregateInputType = {
    hourlyRate?: true
  }

  export type OrderAssignmentSumAggregateInputType = {
    hourlyRate?: true
  }

  export type OrderAssignmentMinAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    role?: true
    hourlyRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderAssignmentMaxAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    role?: true
    hourlyRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderAssignmentCountAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    role?: true
    hourlyRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAssignment to aggregate.
     */
    where?: OrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAssignments to fetch.
     */
    orderBy?: OrderAssignmentOrderByWithRelationInput | OrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderAssignments
    **/
    _count?: true | OrderAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderAssignmentMaxAggregateInputType
  }

  export type GetOrderAssignmentAggregateType<T extends OrderAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderAssignment[P]>
      : GetScalarType<T[P], AggregateOrderAssignment[P]>
  }




  export type OrderAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderAssignmentWhereInput
    orderBy?: OrderAssignmentOrderByWithAggregationInput | OrderAssignmentOrderByWithAggregationInput[]
    by: OrderAssignmentScalarFieldEnum[] | OrderAssignmentScalarFieldEnum
    having?: OrderAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderAssignmentCountAggregateInputType | true
    _avg?: OrderAssignmentAvgAggregateInputType
    _sum?: OrderAssignmentSumAggregateInputType
    _min?: OrderAssignmentMinAggregateInputType
    _max?: OrderAssignmentMaxAggregateInputType
  }

  export type OrderAssignmentGroupByOutputType = {
    id: string
    orderId: string
    employeeId: string
    role: string | null
    hourlyRate: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: OrderAssignmentCountAggregateOutputType | null
    _avg: OrderAssignmentAvgAggregateOutputType | null
    _sum: OrderAssignmentSumAggregateOutputType | null
    _min: OrderAssignmentMinAggregateOutputType | null
    _max: OrderAssignmentMaxAggregateOutputType | null
  }

  type GetOrderAssignmentGroupByPayload<T extends OrderAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], OrderAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type OrderAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    role?: boolean
    hourlyRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAssignment"]>

  export type OrderAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    role?: boolean
    hourlyRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAssignment"]>

  export type OrderAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    role?: boolean
    hourlyRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderAssignment"]>

  export type OrderAssignmentSelectScalar = {
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    role?: boolean
    hourlyRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "employeeId" | "role" | "hourlyRate" | "createdAt" | "updatedAt", ExtArgs["result"]["orderAssignment"]>
  export type OrderAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type OrderAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type OrderAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $OrderAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderAssignment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      employeeId: string
      role: string | null
      hourlyRate: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderAssignment"]>
    composites: {}
  }

  type OrderAssignmentGetPayload<S extends boolean | null | undefined | OrderAssignmentDefaultArgs> = $Result.GetResult<Prisma.$OrderAssignmentPayload, S>

  type OrderAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderAssignmentCountAggregateInputType | true
    }

  export interface OrderAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderAssignment'], meta: { name: 'OrderAssignment' } }
    /**
     * Find zero or one OrderAssignment that matches the filter.
     * @param {OrderAssignmentFindUniqueArgs} args - Arguments to find a OrderAssignment
     * @example
     * // Get one OrderAssignment
     * const orderAssignment = await prisma.orderAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderAssignmentFindUniqueArgs>(args: SelectSubset<T, OrderAssignmentFindUniqueArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderAssignmentFindUniqueOrThrowArgs} args - Arguments to find a OrderAssignment
     * @example
     * // Get one OrderAssignment
     * const orderAssignment = await prisma.orderAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentFindFirstArgs} args - Arguments to find a OrderAssignment
     * @example
     * // Get one OrderAssignment
     * const orderAssignment = await prisma.orderAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderAssignmentFindFirstArgs>(args?: SelectSubset<T, OrderAssignmentFindFirstArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentFindFirstOrThrowArgs} args - Arguments to find a OrderAssignment
     * @example
     * // Get one OrderAssignment
     * const orderAssignment = await prisma.orderAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderAssignments
     * const orderAssignments = await prisma.orderAssignment.findMany()
     * 
     * // Get first 10 OrderAssignments
     * const orderAssignments = await prisma.orderAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderAssignmentWithIdOnly = await prisma.orderAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderAssignmentFindManyArgs>(args?: SelectSubset<T, OrderAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderAssignment.
     * @param {OrderAssignmentCreateArgs} args - Arguments to create a OrderAssignment.
     * @example
     * // Create one OrderAssignment
     * const OrderAssignment = await prisma.orderAssignment.create({
     *   data: {
     *     // ... data to create a OrderAssignment
     *   }
     * })
     * 
     */
    create<T extends OrderAssignmentCreateArgs>(args: SelectSubset<T, OrderAssignmentCreateArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderAssignments.
     * @param {OrderAssignmentCreateManyArgs} args - Arguments to create many OrderAssignments.
     * @example
     * // Create many OrderAssignments
     * const orderAssignment = await prisma.orderAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderAssignmentCreateManyArgs>(args?: SelectSubset<T, OrderAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderAssignments and returns the data saved in the database.
     * @param {OrderAssignmentCreateManyAndReturnArgs} args - Arguments to create many OrderAssignments.
     * @example
     * // Create many OrderAssignments
     * const orderAssignment = await prisma.orderAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderAssignments and only return the `id`
     * const orderAssignmentWithIdOnly = await prisma.orderAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderAssignment.
     * @param {OrderAssignmentDeleteArgs} args - Arguments to delete one OrderAssignment.
     * @example
     * // Delete one OrderAssignment
     * const OrderAssignment = await prisma.orderAssignment.delete({
     *   where: {
     *     // ... filter to delete one OrderAssignment
     *   }
     * })
     * 
     */
    delete<T extends OrderAssignmentDeleteArgs>(args: SelectSubset<T, OrderAssignmentDeleteArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderAssignment.
     * @param {OrderAssignmentUpdateArgs} args - Arguments to update one OrderAssignment.
     * @example
     * // Update one OrderAssignment
     * const orderAssignment = await prisma.orderAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderAssignmentUpdateArgs>(args: SelectSubset<T, OrderAssignmentUpdateArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderAssignments.
     * @param {OrderAssignmentDeleteManyArgs} args - Arguments to filter OrderAssignments to delete.
     * @example
     * // Delete a few OrderAssignments
     * const { count } = await prisma.orderAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderAssignmentDeleteManyArgs>(args?: SelectSubset<T, OrderAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderAssignments
     * const orderAssignment = await prisma.orderAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderAssignmentUpdateManyArgs>(args: SelectSubset<T, OrderAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderAssignments and returns the data updated in the database.
     * @param {OrderAssignmentUpdateManyAndReturnArgs} args - Arguments to update many OrderAssignments.
     * @example
     * // Update many OrderAssignments
     * const orderAssignment = await prisma.orderAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderAssignments and only return the `id`
     * const orderAssignmentWithIdOnly = await prisma.orderAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderAssignment.
     * @param {OrderAssignmentUpsertArgs} args - Arguments to update or create a OrderAssignment.
     * @example
     * // Update or create a OrderAssignment
     * const orderAssignment = await prisma.orderAssignment.upsert({
     *   create: {
     *     // ... data to create a OrderAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderAssignment we want to update
     *   }
     * })
     */
    upsert<T extends OrderAssignmentUpsertArgs>(args: SelectSubset<T, OrderAssignmentUpsertArgs<ExtArgs>>): Prisma__OrderAssignmentClient<$Result.GetResult<Prisma.$OrderAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentCountArgs} args - Arguments to filter OrderAssignments to count.
     * @example
     * // Count the number of OrderAssignments
     * const count = await prisma.orderAssignment.count({
     *   where: {
     *     // ... the filter for the OrderAssignments we want to count
     *   }
     * })
    **/
    count<T extends OrderAssignmentCountArgs>(
      args?: Subset<T, OrderAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAssignmentAggregateArgs>(args: Subset<T, OrderAssignmentAggregateArgs>): Prisma.PrismaPromise<GetOrderAssignmentAggregateType<T>>

    /**
     * Group by OrderAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: OrderAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderAssignment model
   */
  readonly fields: OrderAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderAssignment model
   */
  interface OrderAssignmentFieldRefs {
    readonly id: FieldRef<"OrderAssignment", 'String'>
    readonly orderId: FieldRef<"OrderAssignment", 'String'>
    readonly employeeId: FieldRef<"OrderAssignment", 'String'>
    readonly role: FieldRef<"OrderAssignment", 'String'>
    readonly hourlyRate: FieldRef<"OrderAssignment", 'Decimal'>
    readonly createdAt: FieldRef<"OrderAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderAssignment findUnique
   */
  export type OrderAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAssignment to fetch.
     */
    where: OrderAssignmentWhereUniqueInput
  }

  /**
   * OrderAssignment findUniqueOrThrow
   */
  export type OrderAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAssignment to fetch.
     */
    where: OrderAssignmentWhereUniqueInput
  }

  /**
   * OrderAssignment findFirst
   */
  export type OrderAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAssignment to fetch.
     */
    where?: OrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAssignments to fetch.
     */
    orderBy?: OrderAssignmentOrderByWithRelationInput | OrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAssignments.
     */
    cursor?: OrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAssignments.
     */
    distinct?: OrderAssignmentScalarFieldEnum | OrderAssignmentScalarFieldEnum[]
  }

  /**
   * OrderAssignment findFirstOrThrow
   */
  export type OrderAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAssignment to fetch.
     */
    where?: OrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAssignments to fetch.
     */
    orderBy?: OrderAssignmentOrderByWithRelationInput | OrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderAssignments.
     */
    cursor?: OrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderAssignments.
     */
    distinct?: OrderAssignmentScalarFieldEnum | OrderAssignmentScalarFieldEnum[]
  }

  /**
   * OrderAssignment findMany
   */
  export type OrderAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which OrderAssignments to fetch.
     */
    where?: OrderAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderAssignments to fetch.
     */
    orderBy?: OrderAssignmentOrderByWithRelationInput | OrderAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderAssignments.
     */
    cursor?: OrderAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderAssignments.
     */
    skip?: number
    distinct?: OrderAssignmentScalarFieldEnum | OrderAssignmentScalarFieldEnum[]
  }

  /**
   * OrderAssignment create
   */
  export type OrderAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderAssignment.
     */
    data: XOR<OrderAssignmentCreateInput, OrderAssignmentUncheckedCreateInput>
  }

  /**
   * OrderAssignment createMany
   */
  export type OrderAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderAssignments.
     */
    data: OrderAssignmentCreateManyInput | OrderAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderAssignment createManyAndReturn
   */
  export type OrderAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many OrderAssignments.
     */
    data: OrderAssignmentCreateManyInput | OrderAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAssignment update
   */
  export type OrderAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderAssignment.
     */
    data: XOR<OrderAssignmentUpdateInput, OrderAssignmentUncheckedUpdateInput>
    /**
     * Choose, which OrderAssignment to update.
     */
    where: OrderAssignmentWhereUniqueInput
  }

  /**
   * OrderAssignment updateMany
   */
  export type OrderAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderAssignments.
     */
    data: XOR<OrderAssignmentUpdateManyMutationInput, OrderAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAssignments to update
     */
    where?: OrderAssignmentWhereInput
    /**
     * Limit how many OrderAssignments to update.
     */
    limit?: number
  }

  /**
   * OrderAssignment updateManyAndReturn
   */
  export type OrderAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update OrderAssignments.
     */
    data: XOR<OrderAssignmentUpdateManyMutationInput, OrderAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which OrderAssignments to update
     */
    where?: OrderAssignmentWhereInput
    /**
     * Limit how many OrderAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderAssignment upsert
   */
  export type OrderAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderAssignment to update in case it exists.
     */
    where: OrderAssignmentWhereUniqueInput
    /**
     * In case the OrderAssignment found by the `where` argument doesn't exist, create a new OrderAssignment with this data.
     */
    create: XOR<OrderAssignmentCreateInput, OrderAssignmentUncheckedCreateInput>
    /**
     * In case the OrderAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderAssignmentUpdateInput, OrderAssignmentUncheckedUpdateInput>
  }

  /**
   * OrderAssignment delete
   */
  export type OrderAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
    /**
     * Filter which OrderAssignment to delete.
     */
    where: OrderAssignmentWhereUniqueInput
  }

  /**
   * OrderAssignment deleteMany
   */
  export type OrderAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderAssignments to delete
     */
    where?: OrderAssignmentWhereInput
    /**
     * Limit how many OrderAssignments to delete.
     */
    limit?: number
  }

  /**
   * OrderAssignment without action
   */
  export type OrderAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderAssignment
     */
    select?: OrderAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderAssignment
     */
    omit?: OrderAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Absence
   */

  export type AggregateAbsence = {
    _count: AbsenceCountAggregateOutputType | null
    _min: AbsenceMinAggregateOutputType | null
    _max: AbsenceMaxAggregateOutputType | null
  }

  export type AbsenceMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: $Enums.AbsenceType | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.RequestStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedBy: string | null
    rejectedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AbsenceMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: $Enums.AbsenceType | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    status: $Enums.RequestStatus | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedBy: string | null
    rejectedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AbsenceCountAggregateOutputType = {
    id: number
    employeeId: number
    type: number
    startDate: number
    endDate: number
    reason: number
    status: number
    approvedBy: number
    approvedAt: number
    rejectedBy: number
    rejectedAt: number
    rejectionReason: number
    documentUrls: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AbsenceMinAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedBy?: true
    rejectedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AbsenceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedBy?: true
    rejectedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AbsenceCountAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    startDate?: true
    endDate?: true
    reason?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    rejectedBy?: true
    rejectedAt?: true
    rejectionReason?: true
    documentUrls?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AbsenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Absence to aggregate.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Absences
    **/
    _count?: true | AbsenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbsenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbsenceMaxAggregateInputType
  }

  export type GetAbsenceAggregateType<T extends AbsenceAggregateArgs> = {
        [P in keyof T & keyof AggregateAbsence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbsence[P]>
      : GetScalarType<T[P], AggregateAbsence[P]>
  }




  export type AbsenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbsenceWhereInput
    orderBy?: AbsenceOrderByWithAggregationInput | AbsenceOrderByWithAggregationInput[]
    by: AbsenceScalarFieldEnum[] | AbsenceScalarFieldEnum
    having?: AbsenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbsenceCountAggregateInputType | true
    _min?: AbsenceMinAggregateInputType
    _max?: AbsenceMaxAggregateInputType
  }

  export type AbsenceGroupByOutputType = {
    id: string
    employeeId: string
    type: $Enums.AbsenceType
    startDate: Date
    endDate: Date
    reason: string | null
    status: $Enums.RequestStatus
    approvedBy: string | null
    approvedAt: Date | null
    rejectedBy: string | null
    rejectedAt: Date | null
    rejectionReason: string | null
    documentUrls: string[]
    createdAt: Date
    updatedAt: Date
    _count: AbsenceCountAggregateOutputType | null
    _min: AbsenceMinAggregateOutputType | null
    _max: AbsenceMaxAggregateOutputType | null
  }

  type GetAbsenceGroupByPayload<T extends AbsenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbsenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbsenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbsenceGroupByOutputType[P]>
            : GetScalarType<T[P], AbsenceGroupByOutputType[P]>
        }
      >
    >


  export type AbsenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["absence"]>

  export type AbsenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["absence"]>

  export type AbsenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["absence"]>

  export type AbsenceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    type?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    documentUrls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AbsenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "type" | "startDate" | "endDate" | "reason" | "status" | "approvedBy" | "approvedAt" | "rejectedBy" | "rejectedAt" | "rejectionReason" | "documentUrls" | "createdAt" | "updatedAt", ExtArgs["result"]["absence"]>
  export type AbsenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AbsenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AbsenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AbsencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Absence"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      type: $Enums.AbsenceType
      startDate: Date
      endDate: Date
      reason: string | null
      status: $Enums.RequestStatus
      approvedBy: string | null
      approvedAt: Date | null
      rejectedBy: string | null
      rejectedAt: Date | null
      rejectionReason: string | null
      documentUrls: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["absence"]>
    composites: {}
  }

  type AbsenceGetPayload<S extends boolean | null | undefined | AbsenceDefaultArgs> = $Result.GetResult<Prisma.$AbsencePayload, S>

  type AbsenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbsenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbsenceCountAggregateInputType | true
    }

  export interface AbsenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Absence'], meta: { name: 'Absence' } }
    /**
     * Find zero or one Absence that matches the filter.
     * @param {AbsenceFindUniqueArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbsenceFindUniqueArgs>(args: SelectSubset<T, AbsenceFindUniqueArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Absence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbsenceFindUniqueOrThrowArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbsenceFindUniqueOrThrowArgs>(args: SelectSubset<T, AbsenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Absence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceFindFirstArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbsenceFindFirstArgs>(args?: SelectSubset<T, AbsenceFindFirstArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Absence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceFindFirstOrThrowArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbsenceFindFirstOrThrowArgs>(args?: SelectSubset<T, AbsenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Absences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Absences
     * const absences = await prisma.absence.findMany()
     * 
     * // Get first 10 Absences
     * const absences = await prisma.absence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const absenceWithIdOnly = await prisma.absence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbsenceFindManyArgs>(args?: SelectSubset<T, AbsenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Absence.
     * @param {AbsenceCreateArgs} args - Arguments to create a Absence.
     * @example
     * // Create one Absence
     * const Absence = await prisma.absence.create({
     *   data: {
     *     // ... data to create a Absence
     *   }
     * })
     * 
     */
    create<T extends AbsenceCreateArgs>(args: SelectSubset<T, AbsenceCreateArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Absences.
     * @param {AbsenceCreateManyArgs} args - Arguments to create many Absences.
     * @example
     * // Create many Absences
     * const absence = await prisma.absence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbsenceCreateManyArgs>(args?: SelectSubset<T, AbsenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Absences and returns the data saved in the database.
     * @param {AbsenceCreateManyAndReturnArgs} args - Arguments to create many Absences.
     * @example
     * // Create many Absences
     * const absence = await prisma.absence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Absences and only return the `id`
     * const absenceWithIdOnly = await prisma.absence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AbsenceCreateManyAndReturnArgs>(args?: SelectSubset<T, AbsenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Absence.
     * @param {AbsenceDeleteArgs} args - Arguments to delete one Absence.
     * @example
     * // Delete one Absence
     * const Absence = await prisma.absence.delete({
     *   where: {
     *     // ... filter to delete one Absence
     *   }
     * })
     * 
     */
    delete<T extends AbsenceDeleteArgs>(args: SelectSubset<T, AbsenceDeleteArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Absence.
     * @param {AbsenceUpdateArgs} args - Arguments to update one Absence.
     * @example
     * // Update one Absence
     * const absence = await prisma.absence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbsenceUpdateArgs>(args: SelectSubset<T, AbsenceUpdateArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Absences.
     * @param {AbsenceDeleteManyArgs} args - Arguments to filter Absences to delete.
     * @example
     * // Delete a few Absences
     * const { count } = await prisma.absence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbsenceDeleteManyArgs>(args?: SelectSubset<T, AbsenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Absences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Absences
     * const absence = await prisma.absence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbsenceUpdateManyArgs>(args: SelectSubset<T, AbsenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Absences and returns the data updated in the database.
     * @param {AbsenceUpdateManyAndReturnArgs} args - Arguments to update many Absences.
     * @example
     * // Update many Absences
     * const absence = await prisma.absence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Absences and only return the `id`
     * const absenceWithIdOnly = await prisma.absence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AbsenceUpdateManyAndReturnArgs>(args: SelectSubset<T, AbsenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Absence.
     * @param {AbsenceUpsertArgs} args - Arguments to update or create a Absence.
     * @example
     * // Update or create a Absence
     * const absence = await prisma.absence.upsert({
     *   create: {
     *     // ... data to create a Absence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Absence we want to update
     *   }
     * })
     */
    upsert<T extends AbsenceUpsertArgs>(args: SelectSubset<T, AbsenceUpsertArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Absences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceCountArgs} args - Arguments to filter Absences to count.
     * @example
     * // Count the number of Absences
     * const count = await prisma.absence.count({
     *   where: {
     *     // ... the filter for the Absences we want to count
     *   }
     * })
    **/
    count<T extends AbsenceCountArgs>(
      args?: Subset<T, AbsenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbsenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Absence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbsenceAggregateArgs>(args: Subset<T, AbsenceAggregateArgs>): Prisma.PrismaPromise<GetAbsenceAggregateType<T>>

    /**
     * Group by Absence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbsenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbsenceGroupByArgs['orderBy'] }
        : { orderBy?: AbsenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbsenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbsenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Absence model
   */
  readonly fields: AbsenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Absence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbsenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Absence model
   */
  interface AbsenceFieldRefs {
    readonly id: FieldRef<"Absence", 'String'>
    readonly employeeId: FieldRef<"Absence", 'String'>
    readonly type: FieldRef<"Absence", 'AbsenceType'>
    readonly startDate: FieldRef<"Absence", 'DateTime'>
    readonly endDate: FieldRef<"Absence", 'DateTime'>
    readonly reason: FieldRef<"Absence", 'String'>
    readonly status: FieldRef<"Absence", 'RequestStatus'>
    readonly approvedBy: FieldRef<"Absence", 'String'>
    readonly approvedAt: FieldRef<"Absence", 'DateTime'>
    readonly rejectedBy: FieldRef<"Absence", 'String'>
    readonly rejectedAt: FieldRef<"Absence", 'DateTime'>
    readonly rejectionReason: FieldRef<"Absence", 'String'>
    readonly documentUrls: FieldRef<"Absence", 'String[]'>
    readonly createdAt: FieldRef<"Absence", 'DateTime'>
    readonly updatedAt: FieldRef<"Absence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Absence findUnique
   */
  export type AbsenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence findUniqueOrThrow
   */
  export type AbsenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence findFirst
   */
  export type AbsenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Absences.
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Absences.
     */
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Absence findFirstOrThrow
   */
  export type AbsenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Absences.
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Absences.
     */
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Absence findMany
   */
  export type AbsenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absences to fetch.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Absences.
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Absence create
   */
  export type AbsenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Absence.
     */
    data: XOR<AbsenceCreateInput, AbsenceUncheckedCreateInput>
  }

  /**
   * Absence createMany
   */
  export type AbsenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Absences.
     */
    data: AbsenceCreateManyInput | AbsenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Absence createManyAndReturn
   */
  export type AbsenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * The data used to create many Absences.
     */
    data: AbsenceCreateManyInput | AbsenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Absence update
   */
  export type AbsenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Absence.
     */
    data: XOR<AbsenceUpdateInput, AbsenceUncheckedUpdateInput>
    /**
     * Choose, which Absence to update.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence updateMany
   */
  export type AbsenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Absences.
     */
    data: XOR<AbsenceUpdateManyMutationInput, AbsenceUncheckedUpdateManyInput>
    /**
     * Filter which Absences to update
     */
    where?: AbsenceWhereInput
    /**
     * Limit how many Absences to update.
     */
    limit?: number
  }

  /**
   * Absence updateManyAndReturn
   */
  export type AbsenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * The data used to update Absences.
     */
    data: XOR<AbsenceUpdateManyMutationInput, AbsenceUncheckedUpdateManyInput>
    /**
     * Filter which Absences to update
     */
    where?: AbsenceWhereInput
    /**
     * Limit how many Absences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Absence upsert
   */
  export type AbsenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Absence to update in case it exists.
     */
    where: AbsenceWhereUniqueInput
    /**
     * In case the Absence found by the `where` argument doesn't exist, create a new Absence with this data.
     */
    create: XOR<AbsenceCreateInput, AbsenceUncheckedCreateInput>
    /**
     * In case the Absence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbsenceUpdateInput, AbsenceUncheckedUpdateInput>
  }

  /**
   * Absence delete
   */
  export type AbsenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter which Absence to delete.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence deleteMany
   */
  export type AbsenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Absences to delete
     */
    where?: AbsenceWhereInput
    /**
     * Limit how many Absences to delete.
     */
    limit?: number
  }

  /**
   * Absence without action
   */
  export type AbsenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
  }


  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type RatingSumAggregateOutputType = {
    rating: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    employeeId: string | null
    customerId: string | null
    rating: number | null
    comment: string | null
    category: string | null
    status: $Enums.RatingStatus | null
    ratedBy: string | null
    ratingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    employeeId: string | null
    customerId: string | null
    rating: number | null
    comment: string | null
    category: string | null
    status: $Enums.RatingStatus | null
    ratedBy: string | null
    ratingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    orderId: number
    employeeId: number
    customerId: number
    rating: number
    comment: number
    category: number
    status: number
    ratedBy: number
    ratingDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    rating?: true
  }

  export type RatingSumAggregateInputType = {
    rating?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    customerId?: true
    rating?: true
    comment?: true
    category?: true
    status?: true
    ratedBy?: true
    ratingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    customerId?: true
    rating?: true
    comment?: true
    category?: true
    status?: true
    ratedBy?: true
    ratingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    orderId?: true
    employeeId?: true
    customerId?: true
    rating?: true
    comment?: true
    category?: true
    status?: true
    ratedBy?: true
    ratingDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: string
    orderId: string | null
    employeeId: string | null
    customerId: string | null
    rating: number
    comment: string | null
    category: string | null
    status: $Enums.RatingStatus
    ratedBy: string | null
    ratingDate: Date
    createdAt: Date
    updatedAt: Date
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    status?: boolean
    ratedBy?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | Rating$orderArgs<ExtArgs>
    employee?: boolean | Rating$employeeArgs<ExtArgs>
    customer?: boolean | Rating$customerArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    status?: boolean
    ratedBy?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | Rating$orderArgs<ExtArgs>
    employee?: boolean | Rating$employeeArgs<ExtArgs>
    customer?: boolean | Rating$customerArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    status?: boolean
    ratedBy?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | Rating$orderArgs<ExtArgs>
    employee?: boolean | Rating$employeeArgs<ExtArgs>
    customer?: boolean | Rating$customerArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    orderId?: boolean
    employeeId?: boolean
    customerId?: boolean
    rating?: boolean
    comment?: boolean
    category?: boolean
    status?: boolean
    ratedBy?: boolean
    ratingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "employeeId" | "customerId" | "rating" | "comment" | "category" | "status" | "ratedBy" | "ratingDate" | "createdAt" | "updatedAt", ExtArgs["result"]["rating"]>
  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Rating$orderArgs<ExtArgs>
    employee?: boolean | Rating$employeeArgs<ExtArgs>
    customer?: boolean | Rating$customerArgs<ExtArgs>
  }
  export type RatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Rating$orderArgs<ExtArgs>
    employee?: boolean | Rating$employeeArgs<ExtArgs>
    customer?: boolean | Rating$customerArgs<ExtArgs>
  }
  export type RatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Rating$orderArgs<ExtArgs>
    employee?: boolean | Rating$employeeArgs<ExtArgs>
    customer?: boolean | Rating$customerArgs<ExtArgs>
  }

  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string | null
      employeeId: string | null
      customerId: string | null
      rating: number
      comment: string | null
      category: string | null
      status: $Enums.RatingStatus
      ratedBy: string | null
      ratingDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }

  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RatingFindUniqueArgs>(args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs>(args: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RatingFindFirstArgs>(args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs>(args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RatingFindManyArgs>(args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
     */
    create<T extends RatingCreateArgs>(args: SelectSubset<T, RatingCreateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ratings.
     * @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RatingCreateManyArgs>(args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ratings and returns the data saved in the database.
     * @param {RatingCreateManyAndReturnArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const rating = await prisma.rating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RatingCreateManyAndReturnArgs>(args?: SelectSubset<T, RatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
     */
    delete<T extends RatingDeleteArgs>(args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RatingUpdateArgs>(args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RatingDeleteManyArgs>(args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RatingUpdateManyArgs>(args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings and returns the data updated in the database.
     * @param {RatingUpdateManyAndReturnArgs} args - Arguments to update many Ratings.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ratings and only return the `id`
     * const ratingWithIdOnly = await prisma.rating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RatingUpdateManyAndReturnArgs>(args: SelectSubset<T, RatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
     */
    upsert<T extends RatingUpsertArgs>(args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Rating$orderArgs<ExtArgs> = {}>(args?: Subset<T, Rating$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends Rating$employeeArgs<ExtArgs> = {}>(args?: Subset<T, Rating$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Rating$customerArgs<ExtArgs> = {}>(args?: Subset<T, Rating$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rating model
   */
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'String'>
    readonly orderId: FieldRef<"Rating", 'String'>
    readonly employeeId: FieldRef<"Rating", 'String'>
    readonly customerId: FieldRef<"Rating", 'String'>
    readonly rating: FieldRef<"Rating", 'Int'>
    readonly comment: FieldRef<"Rating", 'String'>
    readonly category: FieldRef<"Rating", 'String'>
    readonly status: FieldRef<"Rating", 'RatingStatus'>
    readonly ratedBy: FieldRef<"Rating", 'String'>
    readonly ratingDate: FieldRef<"Rating", 'DateTime'>
    readonly createdAt: FieldRef<"Rating", 'DateTime'>
    readonly updatedAt: FieldRef<"Rating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }

  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }

  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rating createManyAndReturn
   */
  export type RatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
  }

  /**
   * Rating updateManyAndReturn
   */
  export type RatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }

  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }

  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
    /**
     * Limit how many Ratings to delete.
     */
    limit?: number
  }

  /**
   * Rating.order
   */
  export type Rating$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Rating.employee
   */
  export type Rating$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Rating.customer
   */
  export type Rating$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rating
     */
    omit?: RatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RatingInclude<ExtArgs> | null
  }


  /**
   * Model WorkStatistic
   */

  export type AggregateWorkStatistic = {
    _count: WorkStatisticCountAggregateOutputType | null
    _avg: WorkStatisticAvgAggregateOutputType | null
    _sum: WorkStatisticSumAggregateOutputType | null
    _min: WorkStatisticMinAggregateOutputType | null
    _max: WorkStatisticMaxAggregateOutputType | null
  }

  export type WorkStatisticAvgAggregateOutputType = {
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    efficiency: Decimal | null
    qualityScore: Decimal | null
  }

  export type WorkStatisticSumAggregateOutputType = {
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    efficiency: Decimal | null
    qualityScore: Decimal | null
  }

  export type WorkStatisticMinAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    location: string | null
    efficiency: Decimal | null
    qualityScore: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkStatisticMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    employeeId: string | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    location: string | null
    efficiency: Decimal | null
    qualityScore: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkStatisticCountAggregateOutputType = {
    id: number
    date: number
    employeeId: number
    hoursWorked: number
    overtimeHours: number
    location: number
    projects: number
    efficiency: number
    qualityScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkStatisticAvgAggregateInputType = {
    hoursWorked?: true
    overtimeHours?: true
    efficiency?: true
    qualityScore?: true
  }

  export type WorkStatisticSumAggregateInputType = {
    hoursWorked?: true
    overtimeHours?: true
    efficiency?: true
    qualityScore?: true
  }

  export type WorkStatisticMinAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    hoursWorked?: true
    overtimeHours?: true
    location?: true
    efficiency?: true
    qualityScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkStatisticMaxAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    hoursWorked?: true
    overtimeHours?: true
    location?: true
    efficiency?: true
    qualityScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkStatisticCountAggregateInputType = {
    id?: true
    date?: true
    employeeId?: true
    hoursWorked?: true
    overtimeHours?: true
    location?: true
    projects?: true
    efficiency?: true
    qualityScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkStatisticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkStatistic to aggregate.
     */
    where?: WorkStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStatistics to fetch.
     */
    orderBy?: WorkStatisticOrderByWithRelationInput | WorkStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkStatistics
    **/
    _count?: true | WorkStatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkStatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkStatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkStatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkStatisticMaxAggregateInputType
  }

  export type GetWorkStatisticAggregateType<T extends WorkStatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkStatistic[P]>
      : GetScalarType<T[P], AggregateWorkStatistic[P]>
  }




  export type WorkStatisticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkStatisticWhereInput
    orderBy?: WorkStatisticOrderByWithAggregationInput | WorkStatisticOrderByWithAggregationInput[]
    by: WorkStatisticScalarFieldEnum[] | WorkStatisticScalarFieldEnum
    having?: WorkStatisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkStatisticCountAggregateInputType | true
    _avg?: WorkStatisticAvgAggregateInputType
    _sum?: WorkStatisticSumAggregateInputType
    _min?: WorkStatisticMinAggregateInputType
    _max?: WorkStatisticMaxAggregateInputType
  }

  export type WorkStatisticGroupByOutputType = {
    id: string
    date: Date
    employeeId: string
    hoursWorked: Decimal
    overtimeHours: Decimal
    location: string | null
    projects: string[]
    efficiency: Decimal | null
    qualityScore: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: WorkStatisticCountAggregateOutputType | null
    _avg: WorkStatisticAvgAggregateOutputType | null
    _sum: WorkStatisticSumAggregateOutputType | null
    _min: WorkStatisticMinAggregateOutputType | null
    _max: WorkStatisticMaxAggregateOutputType | null
  }

  type GetWorkStatisticGroupByPayload<T extends WorkStatisticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkStatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkStatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkStatisticGroupByOutputType[P]>
            : GetScalarType<T[P], WorkStatisticGroupByOutputType[P]>
        }
      >
    >


  export type WorkStatisticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    location?: boolean
    projects?: boolean
    efficiency?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workStatistic"]>

  export type WorkStatisticSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    location?: boolean
    projects?: boolean
    efficiency?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workStatistic"]>

  export type WorkStatisticSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    employeeId?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    location?: boolean
    projects?: boolean
    efficiency?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workStatistic"]>

  export type WorkStatisticSelectScalar = {
    id?: boolean
    date?: boolean
    employeeId?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    location?: boolean
    projects?: boolean
    efficiency?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkStatisticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "employeeId" | "hoursWorked" | "overtimeHours" | "location" | "projects" | "efficiency" | "qualityScore" | "createdAt" | "updatedAt", ExtArgs["result"]["workStatistic"]>
  export type WorkStatisticInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WorkStatisticIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type WorkStatisticIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $WorkStatisticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkStatistic"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      employeeId: string
      hoursWorked: Prisma.Decimal
      overtimeHours: Prisma.Decimal
      location: string | null
      projects: string[]
      efficiency: Prisma.Decimal | null
      qualityScore: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workStatistic"]>
    composites: {}
  }

  type WorkStatisticGetPayload<S extends boolean | null | undefined | WorkStatisticDefaultArgs> = $Result.GetResult<Prisma.$WorkStatisticPayload, S>

  type WorkStatisticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkStatisticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkStatisticCountAggregateInputType | true
    }

  export interface WorkStatisticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkStatistic'], meta: { name: 'WorkStatistic' } }
    /**
     * Find zero or one WorkStatistic that matches the filter.
     * @param {WorkStatisticFindUniqueArgs} args - Arguments to find a WorkStatistic
     * @example
     * // Get one WorkStatistic
     * const workStatistic = await prisma.workStatistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkStatisticFindUniqueArgs>(args: SelectSubset<T, WorkStatisticFindUniqueArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkStatistic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkStatisticFindUniqueOrThrowArgs} args - Arguments to find a WorkStatistic
     * @example
     * // Get one WorkStatistic
     * const workStatistic = await prisma.workStatistic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkStatisticFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkStatisticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkStatistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticFindFirstArgs} args - Arguments to find a WorkStatistic
     * @example
     * // Get one WorkStatistic
     * const workStatistic = await prisma.workStatistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkStatisticFindFirstArgs>(args?: SelectSubset<T, WorkStatisticFindFirstArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkStatistic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticFindFirstOrThrowArgs} args - Arguments to find a WorkStatistic
     * @example
     * // Get one WorkStatistic
     * const workStatistic = await prisma.workStatistic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkStatisticFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkStatisticFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkStatistics
     * const workStatistics = await prisma.workStatistic.findMany()
     * 
     * // Get first 10 WorkStatistics
     * const workStatistics = await prisma.workStatistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workStatisticWithIdOnly = await prisma.workStatistic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkStatisticFindManyArgs>(args?: SelectSubset<T, WorkStatisticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkStatistic.
     * @param {WorkStatisticCreateArgs} args - Arguments to create a WorkStatistic.
     * @example
     * // Create one WorkStatistic
     * const WorkStatistic = await prisma.workStatistic.create({
     *   data: {
     *     // ... data to create a WorkStatistic
     *   }
     * })
     * 
     */
    create<T extends WorkStatisticCreateArgs>(args: SelectSubset<T, WorkStatisticCreateArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkStatistics.
     * @param {WorkStatisticCreateManyArgs} args - Arguments to create many WorkStatistics.
     * @example
     * // Create many WorkStatistics
     * const workStatistic = await prisma.workStatistic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkStatisticCreateManyArgs>(args?: SelectSubset<T, WorkStatisticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkStatistics and returns the data saved in the database.
     * @param {WorkStatisticCreateManyAndReturnArgs} args - Arguments to create many WorkStatistics.
     * @example
     * // Create many WorkStatistics
     * const workStatistic = await prisma.workStatistic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkStatistics and only return the `id`
     * const workStatisticWithIdOnly = await prisma.workStatistic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkStatisticCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkStatisticCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkStatistic.
     * @param {WorkStatisticDeleteArgs} args - Arguments to delete one WorkStatistic.
     * @example
     * // Delete one WorkStatistic
     * const WorkStatistic = await prisma.workStatistic.delete({
     *   where: {
     *     // ... filter to delete one WorkStatistic
     *   }
     * })
     * 
     */
    delete<T extends WorkStatisticDeleteArgs>(args: SelectSubset<T, WorkStatisticDeleteArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkStatistic.
     * @param {WorkStatisticUpdateArgs} args - Arguments to update one WorkStatistic.
     * @example
     * // Update one WorkStatistic
     * const workStatistic = await prisma.workStatistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkStatisticUpdateArgs>(args: SelectSubset<T, WorkStatisticUpdateArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkStatistics.
     * @param {WorkStatisticDeleteManyArgs} args - Arguments to filter WorkStatistics to delete.
     * @example
     * // Delete a few WorkStatistics
     * const { count } = await prisma.workStatistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkStatisticDeleteManyArgs>(args?: SelectSubset<T, WorkStatisticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkStatistics
     * const workStatistic = await prisma.workStatistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkStatisticUpdateManyArgs>(args: SelectSubset<T, WorkStatisticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkStatistics and returns the data updated in the database.
     * @param {WorkStatisticUpdateManyAndReturnArgs} args - Arguments to update many WorkStatistics.
     * @example
     * // Update many WorkStatistics
     * const workStatistic = await prisma.workStatistic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkStatistics and only return the `id`
     * const workStatisticWithIdOnly = await prisma.workStatistic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkStatisticUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkStatisticUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkStatistic.
     * @param {WorkStatisticUpsertArgs} args - Arguments to update or create a WorkStatistic.
     * @example
     * // Update or create a WorkStatistic
     * const workStatistic = await prisma.workStatistic.upsert({
     *   create: {
     *     // ... data to create a WorkStatistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkStatistic we want to update
     *   }
     * })
     */
    upsert<T extends WorkStatisticUpsertArgs>(args: SelectSubset<T, WorkStatisticUpsertArgs<ExtArgs>>): Prisma__WorkStatisticClient<$Result.GetResult<Prisma.$WorkStatisticPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticCountArgs} args - Arguments to filter WorkStatistics to count.
     * @example
     * // Count the number of WorkStatistics
     * const count = await prisma.workStatistic.count({
     *   where: {
     *     // ... the filter for the WorkStatistics we want to count
     *   }
     * })
    **/
    count<T extends WorkStatisticCountArgs>(
      args?: Subset<T, WorkStatisticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkStatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkStatisticAggregateArgs>(args: Subset<T, WorkStatisticAggregateArgs>): Prisma.PrismaPromise<GetWorkStatisticAggregateType<T>>

    /**
     * Group by WorkStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkStatisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkStatisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkStatisticGroupByArgs['orderBy'] }
        : { orderBy?: WorkStatisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkStatisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkStatisticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkStatistic model
   */
  readonly fields: WorkStatisticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkStatistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkStatisticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkStatistic model
   */
  interface WorkStatisticFieldRefs {
    readonly id: FieldRef<"WorkStatistic", 'String'>
    readonly date: FieldRef<"WorkStatistic", 'DateTime'>
    readonly employeeId: FieldRef<"WorkStatistic", 'String'>
    readonly hoursWorked: FieldRef<"WorkStatistic", 'Decimal'>
    readonly overtimeHours: FieldRef<"WorkStatistic", 'Decimal'>
    readonly location: FieldRef<"WorkStatistic", 'String'>
    readonly projects: FieldRef<"WorkStatistic", 'String[]'>
    readonly efficiency: FieldRef<"WorkStatistic", 'Decimal'>
    readonly qualityScore: FieldRef<"WorkStatistic", 'Decimal'>
    readonly createdAt: FieldRef<"WorkStatistic", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkStatistic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkStatistic findUnique
   */
  export type WorkStatisticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * Filter, which WorkStatistic to fetch.
     */
    where: WorkStatisticWhereUniqueInput
  }

  /**
   * WorkStatistic findUniqueOrThrow
   */
  export type WorkStatisticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * Filter, which WorkStatistic to fetch.
     */
    where: WorkStatisticWhereUniqueInput
  }

  /**
   * WorkStatistic findFirst
   */
  export type WorkStatisticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * Filter, which WorkStatistic to fetch.
     */
    where?: WorkStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStatistics to fetch.
     */
    orderBy?: WorkStatisticOrderByWithRelationInput | WorkStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkStatistics.
     */
    cursor?: WorkStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkStatistics.
     */
    distinct?: WorkStatisticScalarFieldEnum | WorkStatisticScalarFieldEnum[]
  }

  /**
   * WorkStatistic findFirstOrThrow
   */
  export type WorkStatisticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * Filter, which WorkStatistic to fetch.
     */
    where?: WorkStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStatistics to fetch.
     */
    orderBy?: WorkStatisticOrderByWithRelationInput | WorkStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkStatistics.
     */
    cursor?: WorkStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkStatistics.
     */
    distinct?: WorkStatisticScalarFieldEnum | WorkStatisticScalarFieldEnum[]
  }

  /**
   * WorkStatistic findMany
   */
  export type WorkStatisticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * Filter, which WorkStatistics to fetch.
     */
    where?: WorkStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkStatistics to fetch.
     */
    orderBy?: WorkStatisticOrderByWithRelationInput | WorkStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkStatistics.
     */
    cursor?: WorkStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkStatistics.
     */
    skip?: number
    distinct?: WorkStatisticScalarFieldEnum | WorkStatisticScalarFieldEnum[]
  }

  /**
   * WorkStatistic create
   */
  export type WorkStatisticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkStatistic.
     */
    data: XOR<WorkStatisticCreateInput, WorkStatisticUncheckedCreateInput>
  }

  /**
   * WorkStatistic createMany
   */
  export type WorkStatisticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkStatistics.
     */
    data: WorkStatisticCreateManyInput | WorkStatisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkStatistic createManyAndReturn
   */
  export type WorkStatisticCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * The data used to create many WorkStatistics.
     */
    data: WorkStatisticCreateManyInput | WorkStatisticCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkStatistic update
   */
  export type WorkStatisticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkStatistic.
     */
    data: XOR<WorkStatisticUpdateInput, WorkStatisticUncheckedUpdateInput>
    /**
     * Choose, which WorkStatistic to update.
     */
    where: WorkStatisticWhereUniqueInput
  }

  /**
   * WorkStatistic updateMany
   */
  export type WorkStatisticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkStatistics.
     */
    data: XOR<WorkStatisticUpdateManyMutationInput, WorkStatisticUncheckedUpdateManyInput>
    /**
     * Filter which WorkStatistics to update
     */
    where?: WorkStatisticWhereInput
    /**
     * Limit how many WorkStatistics to update.
     */
    limit?: number
  }

  /**
   * WorkStatistic updateManyAndReturn
   */
  export type WorkStatisticUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * The data used to update WorkStatistics.
     */
    data: XOR<WorkStatisticUpdateManyMutationInput, WorkStatisticUncheckedUpdateManyInput>
    /**
     * Filter which WorkStatistics to update
     */
    where?: WorkStatisticWhereInput
    /**
     * Limit how many WorkStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkStatistic upsert
   */
  export type WorkStatisticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkStatistic to update in case it exists.
     */
    where: WorkStatisticWhereUniqueInput
    /**
     * In case the WorkStatistic found by the `where` argument doesn't exist, create a new WorkStatistic with this data.
     */
    create: XOR<WorkStatisticCreateInput, WorkStatisticUncheckedCreateInput>
    /**
     * In case the WorkStatistic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkStatisticUpdateInput, WorkStatisticUncheckedUpdateInput>
  }

  /**
   * WorkStatistic delete
   */
  export type WorkStatisticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
    /**
     * Filter which WorkStatistic to delete.
     */
    where: WorkStatisticWhereUniqueInput
  }

  /**
   * WorkStatistic deleteMany
   */
  export type WorkStatisticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkStatistics to delete
     */
    where?: WorkStatisticWhereInput
    /**
     * Limit how many WorkStatistics to delete.
     */
    limit?: number
  }

  /**
   * WorkStatistic without action
   */
  export type WorkStatisticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkStatistic
     */
    select?: WorkStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkStatistic
     */
    omit?: WorkStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkStatisticInclude<ExtArgs> | null
  }


  /**
   * Model NotificationTemplate
   */

  export type AggregateNotificationTemplate = {
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  export type NotificationTemplateMinAggregateOutputType = {
    id: string | null
    key: string | null
    title: string | null
    body: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTemplateMaxAggregateOutputType = {
    id: string | null
    key: string | null
    title: string | null
    body: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTemplateCountAggregateOutputType = {
    id: number
    key: number
    title: number
    body: number
    defaultChannels: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationTemplateMinAggregateInputType = {
    id?: true
    key?: true
    title?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTemplateMaxAggregateInputType = {
    id?: true
    key?: true
    title?: true
    body?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTemplateCountAggregateInputType = {
    id?: true
    key?: true
    title?: true
    body?: true
    defaultChannels?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplate to aggregate.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTemplates
    **/
    _count?: true | NotificationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type GetNotificationTemplateAggregateType<T extends NotificationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTemplate[P]>
      : GetScalarType<T[P], AggregateNotificationTemplate[P]>
  }




  export type NotificationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithAggregationInput | NotificationTemplateOrderByWithAggregationInput[]
    by: NotificationTemplateScalarFieldEnum[] | NotificationTemplateScalarFieldEnum
    having?: NotificationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTemplateCountAggregateInputType | true
    _min?: NotificationTemplateMinAggregateInputType
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type NotificationTemplateGroupByOutputType = {
    id: string
    key: string
    title: string
    body: string
    defaultChannels: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  type GetNotificationTemplateGroupByPayload<T extends NotificationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    title?: boolean
    body?: boolean
    defaultChannels?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    title?: boolean
    body?: boolean
    defaultChannels?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    title?: boolean
    body?: boolean
    defaultChannels?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectScalar = {
    id?: boolean
    key?: boolean
    title?: boolean
    body?: boolean
    defaultChannels?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "title" | "body" | "defaultChannels" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationTemplate"]>

  export type $NotificationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      title: string
      body: string
      defaultChannels: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationTemplate"]>
    composites: {}
  }

  type NotificationTemplateGetPayload<S extends boolean | null | undefined | NotificationTemplateDefaultArgs> = $Result.GetResult<Prisma.$NotificationTemplatePayload, S>

  type NotificationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationTemplateCountAggregateInputType | true
    }

  export interface NotificationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationTemplate'], meta: { name: 'NotificationTemplate' } }
    /**
     * Find zero or one NotificationTemplate that matches the filter.
     * @param {NotificationTemplateFindUniqueArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTemplateFindUniqueArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTemplateFindUniqueOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTemplateFindFirstArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany()
     * 
     * // Get first 10 NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTemplateFindManyArgs>(args?: SelectSubset<T, NotificationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationTemplate.
     * @param {NotificationTemplateCreateArgs} args - Arguments to create a NotificationTemplate.
     * @example
     * // Create one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.create({
     *   data: {
     *     // ... data to create a NotificationTemplate
     *   }
     * })
     * 
     */
    create<T extends NotificationTemplateCreateArgs>(args: SelectSubset<T, NotificationTemplateCreateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationTemplates.
     * @param {NotificationTemplateCreateManyArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTemplateCreateManyArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationTemplates and returns the data saved in the database.
     * @param {NotificationTemplateCreateManyAndReturnArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationTemplate.
     * @param {NotificationTemplateDeleteArgs} args - Arguments to delete one NotificationTemplate.
     * @example
     * // Delete one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.delete({
     *   where: {
     *     // ... filter to delete one NotificationTemplate
     *   }
     * })
     * 
     */
    delete<T extends NotificationTemplateDeleteArgs>(args: SelectSubset<T, NotificationTemplateDeleteArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationTemplate.
     * @param {NotificationTemplateUpdateArgs} args - Arguments to update one NotificationTemplate.
     * @example
     * // Update one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTemplateUpdateArgs>(args: SelectSubset<T, NotificationTemplateUpdateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationTemplates.
     * @param {NotificationTemplateDeleteManyArgs} args - Arguments to filter NotificationTemplates to delete.
     * @example
     * // Delete a few NotificationTemplates
     * const { count } = await prisma.notificationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTemplateDeleteManyArgs>(args?: SelectSubset<T, NotificationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTemplateUpdateManyArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates and returns the data updated in the database.
     * @param {NotificationTemplateUpdateManyAndReturnArgs} args - Arguments to update many NotificationTemplates.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationTemplate.
     * @param {NotificationTemplateUpsertArgs} args - Arguments to update or create a NotificationTemplate.
     * @example
     * // Update or create a NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.upsert({
     *   create: {
     *     // ... data to create a NotificationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTemplateUpsertArgs>(args: SelectSubset<T, NotificationTemplateUpsertArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateCountArgs} args - Arguments to filter NotificationTemplates to count.
     * @example
     * // Count the number of NotificationTemplates
     * const count = await prisma.notificationTemplate.count({
     *   where: {
     *     // ... the filter for the NotificationTemplates we want to count
     *   }
     * })
    **/
    count<T extends NotificationTemplateCountArgs>(
      args?: Subset<T, NotificationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTemplateAggregateArgs>(args: Subset<T, NotificationTemplateAggregateArgs>): Prisma.PrismaPromise<GetNotificationTemplateAggregateType<T>>

    /**
     * Group by NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationTemplate model
   */
  readonly fields: NotificationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationTemplate model
   */
  interface NotificationTemplateFieldRefs {
    readonly id: FieldRef<"NotificationTemplate", 'String'>
    readonly key: FieldRef<"NotificationTemplate", 'String'>
    readonly title: FieldRef<"NotificationTemplate", 'String'>
    readonly body: FieldRef<"NotificationTemplate", 'String'>
    readonly defaultChannels: FieldRef<"NotificationTemplate", 'String[]'>
    readonly isActive: FieldRef<"NotificationTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationTemplate findUnique
   */
  export type NotificationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findUniqueOrThrow
   */
  export type NotificationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findFirst
   */
  export type NotificationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findFirstOrThrow
   */
  export type NotificationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findMany
   */
  export type NotificationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Filter, which NotificationTemplates to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate create
   */
  export type NotificationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a NotificationTemplate.
     */
    data: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
  }

  /**
   * NotificationTemplate createMany
   */
  export type NotificationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate createManyAndReturn
   */
  export type NotificationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate update
   */
  export type NotificationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a NotificationTemplate.
     */
    data: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
    /**
     * Choose, which NotificationTemplate to update.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate updateMany
   */
  export type NotificationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
  }

  /**
   * NotificationTemplate updateManyAndReturn
   */
  export type NotificationTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
  }

  /**
   * NotificationTemplate upsert
   */
  export type NotificationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the NotificationTemplate to update in case it exists.
     */
    where: NotificationTemplateWhereUniqueInput
    /**
     * In case the NotificationTemplate found by the `where` argument doesn't exist, create a new NotificationTemplate with this data.
     */
    create: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
    /**
     * In case the NotificationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
  }

  /**
   * NotificationTemplate delete
   */
  export type NotificationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Filter which NotificationTemplate to delete.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate deleteMany
   */
  export type NotificationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplates to delete
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to delete.
     */
    limit?: number
  }

  /**
   * NotificationTemplate without action
   */
  export type NotificationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    templateKey: string | null
    title: string | null
    body: string | null
    category: string | null
    createdBy: string | null
    createdAt: Date | null
    deliveredAt: Date | null
    status: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    templateKey: string | null
    title: string | null
    body: string | null
    category: string | null
    createdBy: string | null
    createdAt: Date | null
    deliveredAt: Date | null
    status: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    templateKey: number
    title: number
    body: number
    data: number
    category: number
    createdBy: number
    createdAt: number
    deliveredAt: number
    status: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    templateKey?: true
    title?: true
    body?: true
    category?: true
    createdBy?: true
    createdAt?: true
    deliveredAt?: true
    status?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    templateKey?: true
    title?: true
    body?: true
    category?: true
    createdBy?: true
    createdAt?: true
    deliveredAt?: true
    status?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    templateKey?: true
    title?: true
    body?: true
    data?: true
    category?: true
    createdBy?: true
    createdAt?: true
    deliveredAt?: true
    status?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    templateKey: string | null
    title: string
    body: string
    data: JsonValue | null
    category: string | null
    createdBy: string | null
    createdAt: Date
    deliveredAt: Date | null
    status: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateKey?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deliveredAt?: boolean
    status?: boolean
    recipients?: boolean | Notification$recipientsArgs<ExtArgs>
    NotificationOutbox?: boolean | Notification$NotificationOutboxArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateKey?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deliveredAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateKey?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deliveredAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    templateKey?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    category?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deliveredAt?: boolean
    status?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "templateKey" | "title" | "body" | "data" | "category" | "createdBy" | "createdAt" | "deliveredAt" | "status", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | Notification$recipientsArgs<ExtArgs>
    NotificationOutbox?: boolean | Notification$NotificationOutboxArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipients: Prisma.$NotificationRecipientPayload<ExtArgs>[]
      NotificationOutbox: Prisma.$NotificationOutboxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateKey: string | null
      title: string
      body: string
      data: Prisma.JsonValue | null
      category: string | null
      createdBy: string | null
      createdAt: Date
      deliveredAt: Date | null
      status: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipients<T extends Notification$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationOutbox<T extends Notification$NotificationOutboxArgs<ExtArgs> = {}>(args?: Subset<T, Notification$NotificationOutboxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly templateKey: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly createdBy: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly deliveredAt: FieldRef<"Notification", 'DateTime'>
    readonly status: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.recipients
   */
  export type Notification$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    where?: NotificationRecipientWhereInput
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    cursor?: NotificationRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * Notification.NotificationOutbox
   */
  export type Notification$NotificationOutboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    where?: NotificationOutboxWhereInput
    orderBy?: NotificationOutboxOrderByWithRelationInput | NotificationOutboxOrderByWithRelationInput[]
    cursor?: NotificationOutboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationOutboxScalarFieldEnum | NotificationOutboxScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationRecipient
   */

  export type AggregateNotificationRecipient = {
    _count: NotificationRecipientCountAggregateOutputType | null
    _min: NotificationRecipientMinAggregateOutputType | null
    _max: NotificationRecipientMaxAggregateOutputType | null
  }

  export type NotificationRecipientMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    readAt: Date | null
    seenAt: Date | null
    isArchived: boolean | null
    status: string | null
    error: string | null
    createdAt: Date | null
  }

  export type NotificationRecipientMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    userId: string | null
    readAt: Date | null
    seenAt: Date | null
    isArchived: boolean | null
    status: string | null
    error: string | null
    createdAt: Date | null
  }

  export type NotificationRecipientCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    channels: number
    readAt: number
    seenAt: number
    isArchived: number
    status: number
    error: number
    createdAt: number
    _all: number
  }


  export type NotificationRecipientMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
    seenAt?: true
    isArchived?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type NotificationRecipientMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
    seenAt?: true
    isArchived?: true
    status?: true
    error?: true
    createdAt?: true
  }

  export type NotificationRecipientCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    channels?: true
    readAt?: true
    seenAt?: true
    isArchived?: true
    status?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRecipient to aggregate.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationRecipients
    **/
    _count?: true | NotificationRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationRecipientMaxAggregateInputType
  }

  export type GetNotificationRecipientAggregateType<T extends NotificationRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRecipient[P]>
      : GetScalarType<T[P], AggregateNotificationRecipient[P]>
  }




  export type NotificationRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRecipientWhereInput
    orderBy?: NotificationRecipientOrderByWithAggregationInput | NotificationRecipientOrderByWithAggregationInput[]
    by: NotificationRecipientScalarFieldEnum[] | NotificationRecipientScalarFieldEnum
    having?: NotificationRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationRecipientCountAggregateInputType | true
    _min?: NotificationRecipientMinAggregateInputType
    _max?: NotificationRecipientMaxAggregateInputType
  }

  export type NotificationRecipientGroupByOutputType = {
    id: string
    notificationId: string
    userId: string | null
    channels: string[]
    readAt: Date | null
    seenAt: Date | null
    isArchived: boolean
    status: string
    error: string | null
    createdAt: Date
    _count: NotificationRecipientCountAggregateOutputType | null
    _min: NotificationRecipientMinAggregateOutputType | null
    _max: NotificationRecipientMaxAggregateOutputType | null
  }

  type GetNotificationRecipientGroupByPayload<T extends NotificationRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationRecipientGroupByOutputType[P]>
        }
      >
    >


  export type NotificationRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    channels?: boolean
    readAt?: boolean
    seenAt?: boolean
    isArchived?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | NotificationRecipient$userArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRecipient"]>

  export type NotificationRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    channels?: boolean
    readAt?: boolean
    seenAt?: boolean
    isArchived?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | NotificationRecipient$userArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRecipient"]>

  export type NotificationRecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    channels?: boolean
    readAt?: boolean
    seenAt?: boolean
    isArchived?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | NotificationRecipient$userArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRecipient"]>

  export type NotificationRecipientSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    channels?: boolean
    readAt?: boolean
    seenAt?: boolean
    isArchived?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type NotificationRecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "userId" | "channels" | "readAt" | "seenAt" | "isArchived" | "status" | "error" | "createdAt", ExtArgs["result"]["notificationRecipient"]>
  export type NotificationRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | NotificationRecipient$userArgs<ExtArgs>
  }
  export type NotificationRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | NotificationRecipient$userArgs<ExtArgs>
  }
  export type NotificationRecipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | NotificationRecipient$userArgs<ExtArgs>
  }

  export type $NotificationRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRecipient"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      userId: string | null
      channels: string[]
      readAt: Date | null
      seenAt: Date | null
      isArchived: boolean
      status: string
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["notificationRecipient"]>
    composites: {}
  }

  type NotificationRecipientGetPayload<S extends boolean | null | undefined | NotificationRecipientDefaultArgs> = $Result.GetResult<Prisma.$NotificationRecipientPayload, S>

  type NotificationRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationRecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationRecipientCountAggregateInputType | true
    }

  export interface NotificationRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRecipient'], meta: { name: 'NotificationRecipient' } }
    /**
     * Find zero or one NotificationRecipient that matches the filter.
     * @param {NotificationRecipientFindUniqueArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationRecipientFindUniqueArgs>(args: SelectSubset<T, NotificationRecipientFindUniqueArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationRecipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationRecipientFindUniqueOrThrowArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientFindFirstArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationRecipientFindFirstArgs>(args?: SelectSubset<T, NotificationRecipientFindFirstArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientFindFirstOrThrowArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationRecipients
     * const notificationRecipients = await prisma.notificationRecipient.findMany()
     * 
     * // Get first 10 NotificationRecipients
     * const notificationRecipients = await prisma.notificationRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationRecipientWithIdOnly = await prisma.notificationRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationRecipientFindManyArgs>(args?: SelectSubset<T, NotificationRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationRecipient.
     * @param {NotificationRecipientCreateArgs} args - Arguments to create a NotificationRecipient.
     * @example
     * // Create one NotificationRecipient
     * const NotificationRecipient = await prisma.notificationRecipient.create({
     *   data: {
     *     // ... data to create a NotificationRecipient
     *   }
     * })
     * 
     */
    create<T extends NotificationRecipientCreateArgs>(args: SelectSubset<T, NotificationRecipientCreateArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationRecipients.
     * @param {NotificationRecipientCreateManyArgs} args - Arguments to create many NotificationRecipients.
     * @example
     * // Create many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationRecipientCreateManyArgs>(args?: SelectSubset<T, NotificationRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationRecipients and returns the data saved in the database.
     * @param {NotificationRecipientCreateManyAndReturnArgs} args - Arguments to create many NotificationRecipients.
     * @example
     * // Create many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationRecipients and only return the `id`
     * const notificationRecipientWithIdOnly = await prisma.notificationRecipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationRecipient.
     * @param {NotificationRecipientDeleteArgs} args - Arguments to delete one NotificationRecipient.
     * @example
     * // Delete one NotificationRecipient
     * const NotificationRecipient = await prisma.notificationRecipient.delete({
     *   where: {
     *     // ... filter to delete one NotificationRecipient
     *   }
     * })
     * 
     */
    delete<T extends NotificationRecipientDeleteArgs>(args: SelectSubset<T, NotificationRecipientDeleteArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationRecipient.
     * @param {NotificationRecipientUpdateArgs} args - Arguments to update one NotificationRecipient.
     * @example
     * // Update one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationRecipientUpdateArgs>(args: SelectSubset<T, NotificationRecipientUpdateArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationRecipients.
     * @param {NotificationRecipientDeleteManyArgs} args - Arguments to filter NotificationRecipients to delete.
     * @example
     * // Delete a few NotificationRecipients
     * const { count } = await prisma.notificationRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationRecipientDeleteManyArgs>(args?: SelectSubset<T, NotificationRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationRecipientUpdateManyArgs>(args: SelectSubset<T, NotificationRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRecipients and returns the data updated in the database.
     * @param {NotificationRecipientUpdateManyAndReturnArgs} args - Arguments to update many NotificationRecipients.
     * @example
     * // Update many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationRecipients and only return the `id`
     * const notificationRecipientWithIdOnly = await prisma.notificationRecipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationRecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationRecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationRecipient.
     * @param {NotificationRecipientUpsertArgs} args - Arguments to update or create a NotificationRecipient.
     * @example
     * // Update or create a NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.upsert({
     *   create: {
     *     // ... data to create a NotificationRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRecipient we want to update
     *   }
     * })
     */
    upsert<T extends NotificationRecipientUpsertArgs>(args: SelectSubset<T, NotificationRecipientUpsertArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientCountArgs} args - Arguments to filter NotificationRecipients to count.
     * @example
     * // Count the number of NotificationRecipients
     * const count = await prisma.notificationRecipient.count({
     *   where: {
     *     // ... the filter for the NotificationRecipients we want to count
     *   }
     * })
    **/
    count<T extends NotificationRecipientCountArgs>(
      args?: Subset<T, NotificationRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationRecipientAggregateArgs>(args: Subset<T, NotificationRecipientAggregateArgs>): Prisma.PrismaPromise<GetNotificationRecipientAggregateType<T>>

    /**
     * Group by NotificationRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationRecipientGroupByArgs['orderBy'] }
        : { orderBy?: NotificationRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRecipient model
   */
  readonly fields: NotificationRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends NotificationRecipient$userArgs<ExtArgs> = {}>(args?: Subset<T, NotificationRecipient$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRecipient model
   */
  interface NotificationRecipientFieldRefs {
    readonly id: FieldRef<"NotificationRecipient", 'String'>
    readonly notificationId: FieldRef<"NotificationRecipient", 'String'>
    readonly userId: FieldRef<"NotificationRecipient", 'String'>
    readonly channels: FieldRef<"NotificationRecipient", 'String[]'>
    readonly readAt: FieldRef<"NotificationRecipient", 'DateTime'>
    readonly seenAt: FieldRef<"NotificationRecipient", 'DateTime'>
    readonly isArchived: FieldRef<"NotificationRecipient", 'Boolean'>
    readonly status: FieldRef<"NotificationRecipient", 'String'>
    readonly error: FieldRef<"NotificationRecipient", 'String'>
    readonly createdAt: FieldRef<"NotificationRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRecipient findUnique
   */
  export type NotificationRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient findUniqueOrThrow
   */
  export type NotificationRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient findFirst
   */
  export type NotificationRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRecipients.
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRecipients.
     */
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * NotificationRecipient findFirstOrThrow
   */
  export type NotificationRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRecipients.
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRecipients.
     */
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * NotificationRecipient findMany
   */
  export type NotificationRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipients to fetch.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationRecipients.
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * NotificationRecipient create
   */
  export type NotificationRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationRecipient.
     */
    data: XOR<NotificationRecipientCreateInput, NotificationRecipientUncheckedCreateInput>
  }

  /**
   * NotificationRecipient createMany
   */
  export type NotificationRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationRecipients.
     */
    data: NotificationRecipientCreateManyInput | NotificationRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationRecipient createManyAndReturn
   */
  export type NotificationRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationRecipients.
     */
    data: NotificationRecipientCreateManyInput | NotificationRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRecipient update
   */
  export type NotificationRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationRecipient.
     */
    data: XOR<NotificationRecipientUpdateInput, NotificationRecipientUncheckedUpdateInput>
    /**
     * Choose, which NotificationRecipient to update.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient updateMany
   */
  export type NotificationRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationRecipients.
     */
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRecipients to update
     */
    where?: NotificationRecipientWhereInput
    /**
     * Limit how many NotificationRecipients to update.
     */
    limit?: number
  }

  /**
   * NotificationRecipient updateManyAndReturn
   */
  export type NotificationRecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * The data used to update NotificationRecipients.
     */
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRecipients to update
     */
    where?: NotificationRecipientWhereInput
    /**
     * Limit how many NotificationRecipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRecipient upsert
   */
  export type NotificationRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationRecipient to update in case it exists.
     */
    where: NotificationRecipientWhereUniqueInput
    /**
     * In case the NotificationRecipient found by the `where` argument doesn't exist, create a new NotificationRecipient with this data.
     */
    create: XOR<NotificationRecipientCreateInput, NotificationRecipientUncheckedCreateInput>
    /**
     * In case the NotificationRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationRecipientUpdateInput, NotificationRecipientUncheckedUpdateInput>
  }

  /**
   * NotificationRecipient delete
   */
  export type NotificationRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter which NotificationRecipient to delete.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient deleteMany
   */
  export type NotificationRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRecipients to delete
     */
    where?: NotificationRecipientWhereInput
    /**
     * Limit how many NotificationRecipients to delete.
     */
    limit?: number
  }

  /**
   * NotificationRecipient.user
   */
  export type NotificationRecipient$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NotificationRecipient without action
   */
  export type NotificationRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
  }


  /**
   * Model NotificationOutbox
   */

  export type AggregateNotificationOutbox = {
    _count: NotificationOutboxCountAggregateOutputType | null
    _avg: NotificationOutboxAvgAggregateOutputType | null
    _sum: NotificationOutboxSumAggregateOutputType | null
    _min: NotificationOutboxMinAggregateOutputType | null
    _max: NotificationOutboxMaxAggregateOutputType | null
  }

  export type NotificationOutboxAvgAggregateOutputType = {
    attempts: number | null
    maxAttempts: number | null
  }

  export type NotificationOutboxSumAggregateOutputType = {
    attempts: number | null
    maxAttempts: number | null
  }

  export type NotificationOutboxMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    channel: string | null
    attempts: number | null
    maxAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationOutboxMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    channel: string | null
    attempts: number | null
    maxAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationOutboxCountAggregateOutputType = {
    id: number
    notificationId: number
    payload: number
    channel: number
    attempts: number
    maxAttempts: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationOutboxAvgAggregateInputType = {
    attempts?: true
    maxAttempts?: true
  }

  export type NotificationOutboxSumAggregateInputType = {
    attempts?: true
    maxAttempts?: true
  }

  export type NotificationOutboxMinAggregateInputType = {
    id?: true
    notificationId?: true
    channel?: true
    attempts?: true
    maxAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationOutboxMaxAggregateInputType = {
    id?: true
    notificationId?: true
    channel?: true
    attempts?: true
    maxAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationOutboxCountAggregateInputType = {
    id?: true
    notificationId?: true
    payload?: true
    channel?: true
    attempts?: true
    maxAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationOutboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationOutbox to aggregate.
     */
    where?: NotificationOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationOutboxes to fetch.
     */
    orderBy?: NotificationOutboxOrderByWithRelationInput | NotificationOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationOutboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationOutboxes
    **/
    _count?: true | NotificationOutboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationOutboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationOutboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationOutboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationOutboxMaxAggregateInputType
  }

  export type GetNotificationOutboxAggregateType<T extends NotificationOutboxAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationOutbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationOutbox[P]>
      : GetScalarType<T[P], AggregateNotificationOutbox[P]>
  }




  export type NotificationOutboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationOutboxWhereInput
    orderBy?: NotificationOutboxOrderByWithAggregationInput | NotificationOutboxOrderByWithAggregationInput[]
    by: NotificationOutboxScalarFieldEnum[] | NotificationOutboxScalarFieldEnum
    having?: NotificationOutboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationOutboxCountAggregateInputType | true
    _avg?: NotificationOutboxAvgAggregateInputType
    _sum?: NotificationOutboxSumAggregateInputType
    _min?: NotificationOutboxMinAggregateInputType
    _max?: NotificationOutboxMaxAggregateInputType
  }

  export type NotificationOutboxGroupByOutputType = {
    id: string
    notificationId: string | null
    payload: JsonValue
    channel: string
    attempts: number
    maxAttempts: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationOutboxCountAggregateOutputType | null
    _avg: NotificationOutboxAvgAggregateOutputType | null
    _sum: NotificationOutboxSumAggregateOutputType | null
    _min: NotificationOutboxMinAggregateOutputType | null
    _max: NotificationOutboxMaxAggregateOutputType | null
  }

  type GetNotificationOutboxGroupByPayload<T extends NotificationOutboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationOutboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationOutboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationOutboxGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationOutboxGroupByOutputType[P]>
        }
      >
    >


  export type NotificationOutboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    payload?: boolean
    channel?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationOutbox$notificationArgs<ExtArgs>
  }, ExtArgs["result"]["notificationOutbox"]>

  export type NotificationOutboxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    payload?: boolean
    channel?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationOutbox$notificationArgs<ExtArgs>
  }, ExtArgs["result"]["notificationOutbox"]>

  export type NotificationOutboxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    payload?: boolean
    channel?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationOutbox$notificationArgs<ExtArgs>
  }, ExtArgs["result"]["notificationOutbox"]>

  export type NotificationOutboxSelectScalar = {
    id?: boolean
    notificationId?: boolean
    payload?: boolean
    channel?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOutboxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "payload" | "channel" | "attempts" | "maxAttempts" | "lockedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationOutbox"]>
  export type NotificationOutboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationOutbox$notificationArgs<ExtArgs>
  }
  export type NotificationOutboxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationOutbox$notificationArgs<ExtArgs>
  }
  export type NotificationOutboxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationOutbox$notificationArgs<ExtArgs>
  }

  export type $NotificationOutboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationOutbox"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string | null
      payload: Prisma.JsonValue
      channel: string
      attempts: number
      maxAttempts: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationOutbox"]>
    composites: {}
  }

  type NotificationOutboxGetPayload<S extends boolean | null | undefined | NotificationOutboxDefaultArgs> = $Result.GetResult<Prisma.$NotificationOutboxPayload, S>

  type NotificationOutboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationOutboxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationOutboxCountAggregateInputType | true
    }

  export interface NotificationOutboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationOutbox'], meta: { name: 'NotificationOutbox' } }
    /**
     * Find zero or one NotificationOutbox that matches the filter.
     * @param {NotificationOutboxFindUniqueArgs} args - Arguments to find a NotificationOutbox
     * @example
     * // Get one NotificationOutbox
     * const notificationOutbox = await prisma.notificationOutbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationOutboxFindUniqueArgs>(args: SelectSubset<T, NotificationOutboxFindUniqueArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationOutbox that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationOutboxFindUniqueOrThrowArgs} args - Arguments to find a NotificationOutbox
     * @example
     * // Get one NotificationOutbox
     * const notificationOutbox = await prisma.notificationOutbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationOutboxFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationOutboxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationOutbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxFindFirstArgs} args - Arguments to find a NotificationOutbox
     * @example
     * // Get one NotificationOutbox
     * const notificationOutbox = await prisma.notificationOutbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationOutboxFindFirstArgs>(args?: SelectSubset<T, NotificationOutboxFindFirstArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationOutbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxFindFirstOrThrowArgs} args - Arguments to find a NotificationOutbox
     * @example
     * // Get one NotificationOutbox
     * const notificationOutbox = await prisma.notificationOutbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationOutboxFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationOutboxFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationOutboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationOutboxes
     * const notificationOutboxes = await prisma.notificationOutbox.findMany()
     * 
     * // Get first 10 NotificationOutboxes
     * const notificationOutboxes = await prisma.notificationOutbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationOutboxWithIdOnly = await prisma.notificationOutbox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationOutboxFindManyArgs>(args?: SelectSubset<T, NotificationOutboxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationOutbox.
     * @param {NotificationOutboxCreateArgs} args - Arguments to create a NotificationOutbox.
     * @example
     * // Create one NotificationOutbox
     * const NotificationOutbox = await prisma.notificationOutbox.create({
     *   data: {
     *     // ... data to create a NotificationOutbox
     *   }
     * })
     * 
     */
    create<T extends NotificationOutboxCreateArgs>(args: SelectSubset<T, NotificationOutboxCreateArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationOutboxes.
     * @param {NotificationOutboxCreateManyArgs} args - Arguments to create many NotificationOutboxes.
     * @example
     * // Create many NotificationOutboxes
     * const notificationOutbox = await prisma.notificationOutbox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationOutboxCreateManyArgs>(args?: SelectSubset<T, NotificationOutboxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationOutboxes and returns the data saved in the database.
     * @param {NotificationOutboxCreateManyAndReturnArgs} args - Arguments to create many NotificationOutboxes.
     * @example
     * // Create many NotificationOutboxes
     * const notificationOutbox = await prisma.notificationOutbox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationOutboxes and only return the `id`
     * const notificationOutboxWithIdOnly = await prisma.notificationOutbox.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationOutboxCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationOutboxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationOutbox.
     * @param {NotificationOutboxDeleteArgs} args - Arguments to delete one NotificationOutbox.
     * @example
     * // Delete one NotificationOutbox
     * const NotificationOutbox = await prisma.notificationOutbox.delete({
     *   where: {
     *     // ... filter to delete one NotificationOutbox
     *   }
     * })
     * 
     */
    delete<T extends NotificationOutboxDeleteArgs>(args: SelectSubset<T, NotificationOutboxDeleteArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationOutbox.
     * @param {NotificationOutboxUpdateArgs} args - Arguments to update one NotificationOutbox.
     * @example
     * // Update one NotificationOutbox
     * const notificationOutbox = await prisma.notificationOutbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationOutboxUpdateArgs>(args: SelectSubset<T, NotificationOutboxUpdateArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationOutboxes.
     * @param {NotificationOutboxDeleteManyArgs} args - Arguments to filter NotificationOutboxes to delete.
     * @example
     * // Delete a few NotificationOutboxes
     * const { count } = await prisma.notificationOutbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationOutboxDeleteManyArgs>(args?: SelectSubset<T, NotificationOutboxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationOutboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationOutboxes
     * const notificationOutbox = await prisma.notificationOutbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationOutboxUpdateManyArgs>(args: SelectSubset<T, NotificationOutboxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationOutboxes and returns the data updated in the database.
     * @param {NotificationOutboxUpdateManyAndReturnArgs} args - Arguments to update many NotificationOutboxes.
     * @example
     * // Update many NotificationOutboxes
     * const notificationOutbox = await prisma.notificationOutbox.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationOutboxes and only return the `id`
     * const notificationOutboxWithIdOnly = await prisma.notificationOutbox.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationOutboxUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationOutboxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationOutbox.
     * @param {NotificationOutboxUpsertArgs} args - Arguments to update or create a NotificationOutbox.
     * @example
     * // Update or create a NotificationOutbox
     * const notificationOutbox = await prisma.notificationOutbox.upsert({
     *   create: {
     *     // ... data to create a NotificationOutbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationOutbox we want to update
     *   }
     * })
     */
    upsert<T extends NotificationOutboxUpsertArgs>(args: SelectSubset<T, NotificationOutboxUpsertArgs<ExtArgs>>): Prisma__NotificationOutboxClient<$Result.GetResult<Prisma.$NotificationOutboxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationOutboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxCountArgs} args - Arguments to filter NotificationOutboxes to count.
     * @example
     * // Count the number of NotificationOutboxes
     * const count = await prisma.notificationOutbox.count({
     *   where: {
     *     // ... the filter for the NotificationOutboxes we want to count
     *   }
     * })
    **/
    count<T extends NotificationOutboxCountArgs>(
      args?: Subset<T, NotificationOutboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationOutboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationOutbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationOutboxAggregateArgs>(args: Subset<T, NotificationOutboxAggregateArgs>): Prisma.PrismaPromise<GetNotificationOutboxAggregateType<T>>

    /**
     * Group by NotificationOutbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationOutboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationOutboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationOutboxGroupByArgs['orderBy'] }
        : { orderBy?: NotificationOutboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationOutboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationOutboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationOutbox model
   */
  readonly fields: NotificationOutboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationOutbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationOutboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationOutbox$notificationArgs<ExtArgs> = {}>(args?: Subset<T, NotificationOutbox$notificationArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationOutbox model
   */
  interface NotificationOutboxFieldRefs {
    readonly id: FieldRef<"NotificationOutbox", 'String'>
    readonly notificationId: FieldRef<"NotificationOutbox", 'String'>
    readonly payload: FieldRef<"NotificationOutbox", 'Json'>
    readonly channel: FieldRef<"NotificationOutbox", 'String'>
    readonly attempts: FieldRef<"NotificationOutbox", 'Int'>
    readonly maxAttempts: FieldRef<"NotificationOutbox", 'Int'>
    readonly lockedUntil: FieldRef<"NotificationOutbox", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationOutbox", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationOutbox", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationOutbox findUnique
   */
  export type NotificationOutboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * Filter, which NotificationOutbox to fetch.
     */
    where: NotificationOutboxWhereUniqueInput
  }

  /**
   * NotificationOutbox findUniqueOrThrow
   */
  export type NotificationOutboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * Filter, which NotificationOutbox to fetch.
     */
    where: NotificationOutboxWhereUniqueInput
  }

  /**
   * NotificationOutbox findFirst
   */
  export type NotificationOutboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * Filter, which NotificationOutbox to fetch.
     */
    where?: NotificationOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationOutboxes to fetch.
     */
    orderBy?: NotificationOutboxOrderByWithRelationInput | NotificationOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationOutboxes.
     */
    cursor?: NotificationOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationOutboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationOutboxes.
     */
    distinct?: NotificationOutboxScalarFieldEnum | NotificationOutboxScalarFieldEnum[]
  }

  /**
   * NotificationOutbox findFirstOrThrow
   */
  export type NotificationOutboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * Filter, which NotificationOutbox to fetch.
     */
    where?: NotificationOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationOutboxes to fetch.
     */
    orderBy?: NotificationOutboxOrderByWithRelationInput | NotificationOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationOutboxes.
     */
    cursor?: NotificationOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationOutboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationOutboxes.
     */
    distinct?: NotificationOutboxScalarFieldEnum | NotificationOutboxScalarFieldEnum[]
  }

  /**
   * NotificationOutbox findMany
   */
  export type NotificationOutboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * Filter, which NotificationOutboxes to fetch.
     */
    where?: NotificationOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationOutboxes to fetch.
     */
    orderBy?: NotificationOutboxOrderByWithRelationInput | NotificationOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationOutboxes.
     */
    cursor?: NotificationOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationOutboxes.
     */
    skip?: number
    distinct?: NotificationOutboxScalarFieldEnum | NotificationOutboxScalarFieldEnum[]
  }

  /**
   * NotificationOutbox create
   */
  export type NotificationOutboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationOutbox.
     */
    data: XOR<NotificationOutboxCreateInput, NotificationOutboxUncheckedCreateInput>
  }

  /**
   * NotificationOutbox createMany
   */
  export type NotificationOutboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationOutboxes.
     */
    data: NotificationOutboxCreateManyInput | NotificationOutboxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationOutbox createManyAndReturn
   */
  export type NotificationOutboxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationOutboxes.
     */
    data: NotificationOutboxCreateManyInput | NotificationOutboxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationOutbox update
   */
  export type NotificationOutboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationOutbox.
     */
    data: XOR<NotificationOutboxUpdateInput, NotificationOutboxUncheckedUpdateInput>
    /**
     * Choose, which NotificationOutbox to update.
     */
    where: NotificationOutboxWhereUniqueInput
  }

  /**
   * NotificationOutbox updateMany
   */
  export type NotificationOutboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationOutboxes.
     */
    data: XOR<NotificationOutboxUpdateManyMutationInput, NotificationOutboxUncheckedUpdateManyInput>
    /**
     * Filter which NotificationOutboxes to update
     */
    where?: NotificationOutboxWhereInput
    /**
     * Limit how many NotificationOutboxes to update.
     */
    limit?: number
  }

  /**
   * NotificationOutbox updateManyAndReturn
   */
  export type NotificationOutboxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * The data used to update NotificationOutboxes.
     */
    data: XOR<NotificationOutboxUpdateManyMutationInput, NotificationOutboxUncheckedUpdateManyInput>
    /**
     * Filter which NotificationOutboxes to update
     */
    where?: NotificationOutboxWhereInput
    /**
     * Limit how many NotificationOutboxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationOutbox upsert
   */
  export type NotificationOutboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationOutbox to update in case it exists.
     */
    where: NotificationOutboxWhereUniqueInput
    /**
     * In case the NotificationOutbox found by the `where` argument doesn't exist, create a new NotificationOutbox with this data.
     */
    create: XOR<NotificationOutboxCreateInput, NotificationOutboxUncheckedCreateInput>
    /**
     * In case the NotificationOutbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationOutboxUpdateInput, NotificationOutboxUncheckedUpdateInput>
  }

  /**
   * NotificationOutbox delete
   */
  export type NotificationOutboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
    /**
     * Filter which NotificationOutbox to delete.
     */
    where: NotificationOutboxWhereUniqueInput
  }

  /**
   * NotificationOutbox deleteMany
   */
  export type NotificationOutboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationOutboxes to delete
     */
    where?: NotificationOutboxWhereInput
    /**
     * Limit how many NotificationOutboxes to delete.
     */
    limit?: number
  }

  /**
   * NotificationOutbox.notification
   */
  export type NotificationOutbox$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
  }

  /**
   * NotificationOutbox without action
   */
  export type NotificationOutboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationOutbox
     */
    select?: NotificationOutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationOutbox
     */
    omit?: NotificationOutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationOutboxInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceAvgAggregateOutputType = {
    quietHoursStart: number | null
    quietHoursEnd: number | null
  }

  export type NotificationPreferenceSumAggregateOutputType = {
    quietHoursStart: number | null
    quietHoursEnd: number | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
    digestEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    quietHoursStart: number | null
    quietHoursEnd: number | null
    digestEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    channels: number
    quietHoursStart: number
    quietHoursEnd: number
    digestEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceAvgAggregateInputType = {
    quietHoursStart?: true
    quietHoursEnd?: true
  }

  export type NotificationPreferenceSumAggregateInputType = {
    quietHoursStart?: true
    quietHoursEnd?: true
  }

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    digestEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    digestEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    channels?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    digestEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _avg?: NotificationPreferenceAvgAggregateInputType
    _sum?: NotificationPreferenceSumAggregateInputType
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    channels: string[]
    quietHoursStart: number | null
    quietHoursEnd: number | null
    digestEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channels?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    digestEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channels?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    digestEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channels?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    digestEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    channels?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    digestEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "channels" | "quietHoursStart" | "quietHoursEnd" | "digestEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      channels: string[]
      quietHoursStart: number | null
      quietHoursEnd: number | null
      digestEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly channels: FieldRef<"NotificationPreference", 'String[]'>
    readonly quietHoursStart: FieldRef<"NotificationPreference", 'Int'>
    readonly quietHoursEnd: FieldRef<"NotificationPreference", 'Int'>
    readonly digestEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    path: string | null
    documentType: $Enums.DocumentType | null
    description: string | null
    expiryDate: Date | null
    employeeId: string | null
    orderId: string | null
    assignmentId: string | null
    uploadedBy: string | null
    isVerified: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    path: string | null
    documentType: $Enums.DocumentType | null
    description: string | null
    expiryDate: Date | null
    employeeId: string | null
    orderId: string | null
    assignmentId: string | null
    uploadedBy: string | null
    isVerified: boolean | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    path: number
    documentType: number
    description: number
    expiryDate: number
    employeeId: number
    orderId: number
    assignmentId: number
    uploadedBy: number
    isVerified: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    documentType?: true
    description?: true
    expiryDate?: true
    employeeId?: true
    orderId?: true
    assignmentId?: true
    uploadedBy?: true
    isVerified?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    documentType?: true
    description?: true
    expiryDate?: true
    employeeId?: true
    orderId?: true
    assignmentId?: true
    uploadedBy?: true
    isVerified?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    path?: true
    documentType?: true
    description?: true
    expiryDate?: true
    employeeId?: true
    orderId?: true
    assignmentId?: true
    uploadedBy?: true
    isVerified?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType: $Enums.DocumentType
    description: string | null
    expiryDate: Date | null
    employeeId: string | null
    orderId: string | null
    assignmentId: string | null
    uploadedBy: string | null
    isVerified: boolean
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    documentType?: boolean
    description?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    orderId?: boolean
    assignmentId?: boolean
    uploadedBy?: boolean
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | File$employeeArgs<ExtArgs>
    order?: boolean | File$orderArgs<ExtArgs>
    assignment?: boolean | File$assignmentArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    documentType?: boolean
    description?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    orderId?: boolean
    assignmentId?: boolean
    uploadedBy?: boolean
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | File$employeeArgs<ExtArgs>
    order?: boolean | File$orderArgs<ExtArgs>
    assignment?: boolean | File$assignmentArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    documentType?: boolean
    description?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    orderId?: boolean
    assignmentId?: boolean
    uploadedBy?: boolean
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | File$employeeArgs<ExtArgs>
    order?: boolean | File$orderArgs<ExtArgs>
    assignment?: boolean | File$assignmentArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    path?: boolean
    documentType?: boolean
    description?: boolean
    expiryDate?: boolean
    employeeId?: boolean
    orderId?: boolean
    assignmentId?: boolean
    uploadedBy?: boolean
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "path" | "documentType" | "description" | "expiryDate" | "employeeId" | "orderId" | "assignmentId" | "uploadedBy" | "isVerified" | "isPublic" | "createdAt" | "updatedAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | File$employeeArgs<ExtArgs>
    order?: boolean | File$orderArgs<ExtArgs>
    assignment?: boolean | File$assignmentArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | File$employeeArgs<ExtArgs>
    order?: boolean | File$orderArgs<ExtArgs>
    assignment?: boolean | File$assignmentArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | File$employeeArgs<ExtArgs>
    order?: boolean | File$orderArgs<ExtArgs>
    assignment?: boolean | File$assignmentArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
      assignment: Prisma.$AssignmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: number
      path: string
      documentType: $Enums.DocumentType
      description: string | null
      expiryDate: Date | null
      employeeId: string | null
      orderId: string | null
      assignmentId: string | null
      uploadedBy: string | null
      isVerified: boolean
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends File$employeeArgs<ExtArgs> = {}>(args?: Subset<T, File$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends File$orderArgs<ExtArgs> = {}>(args?: Subset<T, File$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignment<T extends File$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, File$assignmentArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly originalName: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly path: FieldRef<"File", 'String'>
    readonly documentType: FieldRef<"File", 'DocumentType'>
    readonly description: FieldRef<"File", 'String'>
    readonly expiryDate: FieldRef<"File", 'DateTime'>
    readonly employeeId: FieldRef<"File", 'String'>
    readonly orderId: FieldRef<"File", 'String'>
    readonly assignmentId: FieldRef<"File", 'String'>
    readonly uploadedBy: FieldRef<"File", 'String'>
    readonly isVerified: FieldRef<"File", 'Boolean'>
    readonly isPublic: FieldRef<"File", 'Boolean'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.employee
   */
  export type File$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * File.order
   */
  export type File$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * File.assignment
   */
  export type File$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly isActive: FieldRef<"SystemConfig", 'Boolean'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    action: string | null
    userId: string | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    action: string | null
    userId: string | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    action: number
    oldData: number
    newData: number
    changes: number
    userId: number
    timestamp: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    oldData?: true
    newData?: true
    changes?: true
    userId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    action: string
    oldData: JsonValue | null
    newData: JsonValue | null
    changes: JsonValue | null
    userId: string | null
    timestamp: Date
    ipAddress: string | null
    userAgent: string | null
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changes?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changes?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changes?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    oldData?: boolean
    newData?: boolean
    changes?: boolean
    userId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "action" | "oldData" | "newData" | "changes" | "userId" | "timestamp" | "ipAddress" | "userAgent", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      action: string
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      changes: Prisma.JsonValue | null
      userId: string | null
      timestamp: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tableName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    refreshToken: 'refreshToken',
    emailVerificationToken: 'emailVerificationToken',
    emailVerificationExpires: 'emailVerificationExpires',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    emailVerified: 'emailVerified',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeCode: 'employeeCode',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    dateOfBirth: 'dateOfBirth',
    address: 'address',
    emergencyContact: 'emergencyContact',
    hireDate: 'hireDate',
    terminationDate: 'terminationDate',
    departmentId: 'departmentId',
    positionId: 'positionId',
    managerId: 'managerId',
    scheduleType: 'scheduleType',
    hourlyRate: 'hourlyRate',
    salary: 'salary',
    isAvailable: 'isAvailable',
    priority: 'priority',
    blockedAt: 'blockedAt',
    blockedReason: 'blockedReason',
    performanceScore: 'performanceScore',
    trafficLight: 'trafficLight',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EmployeePerformanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    score: 'score',
    trafficLight: 'trafficLight',
    trafficLightReason: 'trafficLightReason',
    metrics: 'metrics',
    manualOverride: 'manualOverride',
    manualOverrideById: 'manualOverrideById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeePerformanceScalarFieldEnum = (typeof EmployeePerformanceScalarFieldEnum)[keyof typeof EmployeePerformanceScalarFieldEnum]


  export const PerformanceThresholdScalarFieldEnum: {
    id: 'id',
    departmentId: 'departmentId',
    redMin: 'redMin',
    redMax: 'redMax',
    yellowMin: 'yellowMin',
    yellowMax: 'yellowMax',
    greenMin: 'greenMin',
    greenMax: 'greenMax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceThresholdScalarFieldEnum = (typeof PerformanceThresholdScalarFieldEnum)[keyof typeof PerformanceThresholdScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    code: 'code',
    isActive: 'isActive',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    level: 'level',
    isActive: 'isActive',
    departmentId: 'departmentId',
    minSalary: 'minSalary',
    maxSalary: 'maxSalary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    isActive: 'isActive',
    industry: 'industry',
    taxNumber: 'taxNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SubAccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    isActive: 'isActive',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubAccountScalarFieldEnum = (typeof SubAccountScalarFieldEnum)[keyof typeof SubAccountScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    description: 'description',
    scheduledDate: 'scheduledDate',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    location: 'location',
    requiredEmployees: 'requiredEmployees',
    priority: 'priority',
    specialInstructions: 'specialInstructions',
    status: 'status',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const QualificationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    isActive: 'isActive',
    requiresCertificate: 'requiresCertificate',
    expiryMonths: 'expiryMonths',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QualificationScalarFieldEnum = (typeof QualificationScalarFieldEnum)[keyof typeof QualificationScalarFieldEnum]


  export const EmployeeQualificationScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    qualificationId: 'qualificationId',
    acquiredDate: 'acquiredDate',
    expiryDate: 'expiryDate',
    certificateUrl: 'certificateUrl',
    isVerified: 'isVerified',
    proficiencyLevel: 'proficiencyLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeQualificationScalarFieldEnum = (typeof EmployeeQualificationScalarFieldEnum)[keyof typeof EmployeeQualificationScalarFieldEnum]


  export const OrderQualificationScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    qualificationId: 'qualificationId',
    required: 'required',
    minProficiency: 'minProficiency'
  };

  export type OrderQualificationScalarFieldEnum = (typeof OrderQualificationScalarFieldEnum)[keyof typeof OrderQualificationScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    employeeId: 'employeeId',
    assignedDate: 'assignedDate',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    tier: 'tier',
    estimatedHours: 'estimatedHours',
    actualHours: 'actualHours',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const OrderAssignmentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    employeeId: 'employeeId',
    role: 'role',
    hourlyRate: 'hourlyRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderAssignmentScalarFieldEnum = (typeof OrderAssignmentScalarFieldEnum)[keyof typeof OrderAssignmentScalarFieldEnum]


  export const AbsenceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    type: 'type',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedBy: 'rejectedBy',
    rejectedAt: 'rejectedAt',
    rejectionReason: 'rejectionReason',
    documentUrls: 'documentUrls',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AbsenceScalarFieldEnum = (typeof AbsenceScalarFieldEnum)[keyof typeof AbsenceScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    employeeId: 'employeeId',
    customerId: 'customerId',
    rating: 'rating',
    comment: 'comment',
    category: 'category',
    status: 'status',
    ratedBy: 'ratedBy',
    ratingDate: 'ratingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const WorkStatisticScalarFieldEnum: {
    id: 'id',
    date: 'date',
    employeeId: 'employeeId',
    hoursWorked: 'hoursWorked',
    overtimeHours: 'overtimeHours',
    location: 'location',
    projects: 'projects',
    efficiency: 'efficiency',
    qualityScore: 'qualityScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkStatisticScalarFieldEnum = (typeof WorkStatisticScalarFieldEnum)[keyof typeof WorkStatisticScalarFieldEnum]


  export const NotificationTemplateScalarFieldEnum: {
    id: 'id',
    key: 'key',
    title: 'title',
    body: 'body',
    defaultChannels: 'defaultChannels',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationTemplateScalarFieldEnum = (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    templateKey: 'templateKey',
    title: 'title',
    body: 'body',
    data: 'data',
    category: 'category',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    deliveredAt: 'deliveredAt',
    status: 'status'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationRecipientScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    channels: 'channels',
    readAt: 'readAt',
    seenAt: 'seenAt',
    isArchived: 'isArchived',
    status: 'status',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type NotificationRecipientScalarFieldEnum = (typeof NotificationRecipientScalarFieldEnum)[keyof typeof NotificationRecipientScalarFieldEnum]


  export const NotificationOutboxScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    payload: 'payload',
    channel: 'channel',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationOutboxScalarFieldEnum = (typeof NotificationOutboxScalarFieldEnum)[keyof typeof NotificationOutboxScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channels: 'channels',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    digestEnabled: 'digestEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    path: 'path',
    documentType: 'documentType',
    description: 'description',
    expiryDate: 'expiryDate',
    employeeId: 'employeeId',
    orderId: 'orderId',
    assignmentId: 'assignmentId',
    uploadedBy: 'uploadedBy',
    isVerified: 'isVerified',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    action: 'action',
    oldData: 'oldData',
    newData: 'newData',
    changes: 'changes',
    userId: 'userId',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'WorkScheduleType'
   */
  export type EnumWorkScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkScheduleType'>
    


  /**
   * Reference to a field of type 'WorkScheduleType[]'
   */
  export type ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkScheduleType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TrafficLight'
   */
  export type EnumTrafficLightFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrafficLight'>
    


  /**
   * Reference to a field of type 'TrafficLight[]'
   */
  export type ListEnumTrafficLightFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrafficLight[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    


  /**
   * Reference to a field of type 'AssignmentTier'
   */
  export type EnumAssignmentTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentTier'>
    


  /**
   * Reference to a field of type 'AssignmentTier[]'
   */
  export type ListEnumAssignmentTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentTier[]'>
    


  /**
   * Reference to a field of type 'AbsenceType'
   */
  export type EnumAbsenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbsenceType'>
    


  /**
   * Reference to a field of type 'AbsenceType[]'
   */
  export type ListEnumAbsenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbsenceType[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'RatingStatus'
   */
  export type EnumRatingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RatingStatus'>
    


  /**
   * Reference to a field of type 'RatingStatus[]'
   */
  export type ListEnumRatingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RatingStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    manualOverrides?: EmployeePerformanceListRelationFilter
    subordinates?: EmployeeListRelationFilter
    notificationRecipients?: NotificationRecipientListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    manualOverrides?: EmployeePerformanceOrderByRelationAggregateInput
    subordinates?: EmployeeOrderByRelationAggregateInput
    notificationRecipients?: NotificationRecipientOrderByRelationAggregateInput
    notificationPreferences?: NotificationPreferenceOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringNullableFilter<"User"> | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    manualOverrides?: EmployeePerformanceListRelationFilter
    subordinates?: EmployeeListRelationFilter
    notificationRecipients?: NotificationRecipientListRelationFilter
    notificationPreferences?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeCode?: StringFilter<"Employee"> | string
    firstName?: StringNullableFilter<"Employee"> | string | null
    lastName?: StringNullableFilter<"Employee"> | string | null
    phoneNumber?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: JsonNullableFilter<"Employee">
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    terminationDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    scheduleType?: EnumWorkScheduleTypeFilter<"Employee"> | $Enums.WorkScheduleType
    hourlyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFilter<"Employee"> | boolean
    priority?: IntFilter<"Employee"> | number
    blockedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    blockedReason?: StringNullableFilter<"Employee"> | string | null
    performanceScore?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    trafficLight?: EnumTrafficLightNullableFilter<"Employee"> | $Enums.TrafficLight | null
    userId?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    createdBy?: StringNullableFilter<"Employee"> | string | null
    updatedBy?: StringNullableFilter<"Employee"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    performanceRecords?: EmployeePerformanceListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    qualifications?: EmployeeQualificationListRelationFilter
    assignments?: AssignmentListRelationFilter
    absences?: AbsenceListRelationFilter
    ratings?: RatingListRelationFilter
    workStatistics?: WorkStatisticListRelationFilter
    orderAssignments?: OrderAssignmentListRelationFilter
    files?: FileListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    terminationDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    scheduleType?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    priority?: SortOrder
    blockedAt?: SortOrderInput | SortOrder
    blockedReason?: SortOrderInput | SortOrder
    performanceScore?: SortOrderInput | SortOrder
    trafficLight?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    performanceRecords?: EmployeePerformanceOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    qualifications?: EmployeeQualificationOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    absences?: AbsenceOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    workStatistics?: WorkStatisticOrderByRelationAggregateInput
    orderAssignments?: OrderAssignmentOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeCode?: string
    userId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    firstName?: StringNullableFilter<"Employee"> | string | null
    lastName?: StringNullableFilter<"Employee"> | string | null
    phoneNumber?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: JsonNullableFilter<"Employee">
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    terminationDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    scheduleType?: EnumWorkScheduleTypeFilter<"Employee"> | $Enums.WorkScheduleType
    hourlyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFilter<"Employee"> | boolean
    priority?: IntFilter<"Employee"> | number
    blockedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    blockedReason?: StringNullableFilter<"Employee"> | string | null
    performanceScore?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    trafficLight?: EnumTrafficLightNullableFilter<"Employee"> | $Enums.TrafficLight | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    createdBy?: StringNullableFilter<"Employee"> | string | null
    updatedBy?: StringNullableFilter<"Employee"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    performanceRecords?: EmployeePerformanceListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    qualifications?: EmployeeQualificationListRelationFilter
    assignments?: AssignmentListRelationFilter
    absences?: AbsenceListRelationFilter
    ratings?: RatingListRelationFilter
    workStatistics?: WorkStatisticListRelationFilter
    orderAssignments?: OrderAssignmentListRelationFilter
    files?: FileListRelationFilter
  }, "id" | "employeeCode" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    terminationDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    scheduleType?: SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    priority?: SortOrder
    blockedAt?: SortOrderInput | SortOrder
    blockedReason?: SortOrderInput | SortOrder
    performanceScore?: SortOrderInput | SortOrder
    trafficLight?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    employeeCode?: StringWithAggregatesFilter<"Employee"> | string
    firstName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContact?: JsonNullableWithAggregatesFilter<"Employee">
    hireDate?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    terminationDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    scheduleType?: EnumWorkScheduleTypeWithAggregatesFilter<"Employee"> | $Enums.WorkScheduleType
    hourlyRate?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    salary?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolWithAggregatesFilter<"Employee"> | boolean
    priority?: IntWithAggregatesFilter<"Employee"> | number
    blockedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    blockedReason?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    performanceScore?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    trafficLight?: EnumTrafficLightNullableWithAggregatesFilter<"Employee"> | $Enums.TrafficLight | null
    userId?: StringWithAggregatesFilter<"Employee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Employee"> | string | null
  }

  export type EmployeePerformanceWhereInput = {
    AND?: EmployeePerformanceWhereInput | EmployeePerformanceWhereInput[]
    OR?: EmployeePerformanceWhereInput[]
    NOT?: EmployeePerformanceWhereInput | EmployeePerformanceWhereInput[]
    id?: StringFilter<"EmployeePerformance"> | string
    employeeId?: StringFilter<"EmployeePerformance"> | string
    periodStart?: DateTimeFilter<"EmployeePerformance"> | Date | string
    periodEnd?: DateTimeFilter<"EmployeePerformance"> | Date | string
    score?: DecimalFilter<"EmployeePerformance"> | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFilter<"EmployeePerformance"> | $Enums.TrafficLight
    trafficLightReason?: StringNullableFilter<"EmployeePerformance"> | string | null
    metrics?: JsonNullableFilter<"EmployeePerformance">
    manualOverride?: BoolFilter<"EmployeePerformance"> | boolean
    manualOverrideById?: StringNullableFilter<"EmployeePerformance"> | string | null
    createdAt?: DateTimeFilter<"EmployeePerformance"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePerformance"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    manualOverrideBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type EmployeePerformanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    score?: SortOrder
    trafficLight?: SortOrder
    trafficLightReason?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    manualOverride?: SortOrder
    manualOverrideById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    manualOverrideBy?: UserOrderByWithRelationInput
  }

  export type EmployeePerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeePerformanceWhereInput | EmployeePerformanceWhereInput[]
    OR?: EmployeePerformanceWhereInput[]
    NOT?: EmployeePerformanceWhereInput | EmployeePerformanceWhereInput[]
    employeeId?: StringFilter<"EmployeePerformance"> | string
    periodStart?: DateTimeFilter<"EmployeePerformance"> | Date | string
    periodEnd?: DateTimeFilter<"EmployeePerformance"> | Date | string
    score?: DecimalFilter<"EmployeePerformance"> | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFilter<"EmployeePerformance"> | $Enums.TrafficLight
    trafficLightReason?: StringNullableFilter<"EmployeePerformance"> | string | null
    metrics?: JsonNullableFilter<"EmployeePerformance">
    manualOverride?: BoolFilter<"EmployeePerformance"> | boolean
    manualOverrideById?: StringNullableFilter<"EmployeePerformance"> | string | null
    createdAt?: DateTimeFilter<"EmployeePerformance"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePerformance"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    manualOverrideBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type EmployeePerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    score?: SortOrder
    trafficLight?: SortOrder
    trafficLightReason?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    manualOverride?: SortOrder
    manualOverrideById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeePerformanceCountOrderByAggregateInput
    _avg?: EmployeePerformanceAvgOrderByAggregateInput
    _max?: EmployeePerformanceMaxOrderByAggregateInput
    _min?: EmployeePerformanceMinOrderByAggregateInput
    _sum?: EmployeePerformanceSumOrderByAggregateInput
  }

  export type EmployeePerformanceScalarWhereWithAggregatesInput = {
    AND?: EmployeePerformanceScalarWhereWithAggregatesInput | EmployeePerformanceScalarWhereWithAggregatesInput[]
    OR?: EmployeePerformanceScalarWhereWithAggregatesInput[]
    NOT?: EmployeePerformanceScalarWhereWithAggregatesInput | EmployeePerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeePerformance"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeePerformance"> | string
    periodStart?: DateTimeWithAggregatesFilter<"EmployeePerformance"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"EmployeePerformance"> | Date | string
    score?: DecimalWithAggregatesFilter<"EmployeePerformance"> | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightWithAggregatesFilter<"EmployeePerformance"> | $Enums.TrafficLight
    trafficLightReason?: StringNullableWithAggregatesFilter<"EmployeePerformance"> | string | null
    metrics?: JsonNullableWithAggregatesFilter<"EmployeePerformance">
    manualOverride?: BoolWithAggregatesFilter<"EmployeePerformance"> | boolean
    manualOverrideById?: StringNullableWithAggregatesFilter<"EmployeePerformance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeePerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeePerformance"> | Date | string
  }

  export type PerformanceThresholdWhereInput = {
    AND?: PerformanceThresholdWhereInput | PerformanceThresholdWhereInput[]
    OR?: PerformanceThresholdWhereInput[]
    NOT?: PerformanceThresholdWhereInput | PerformanceThresholdWhereInput[]
    id?: StringFilter<"PerformanceThreshold"> | string
    departmentId?: StringFilter<"PerformanceThreshold"> | string
    redMin?: IntFilter<"PerformanceThreshold"> | number
    redMax?: IntFilter<"PerformanceThreshold"> | number
    yellowMin?: IntFilter<"PerformanceThreshold"> | number
    yellowMax?: IntFilter<"PerformanceThreshold"> | number
    greenMin?: IntFilter<"PerformanceThreshold"> | number
    greenMax?: IntFilter<"PerformanceThreshold"> | number
    createdAt?: DateTimeFilter<"PerformanceThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceThreshold"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }

  export type PerformanceThresholdOrderByWithRelationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
  }

  export type PerformanceThresholdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    departmentId?: string
    AND?: PerformanceThresholdWhereInput | PerformanceThresholdWhereInput[]
    OR?: PerformanceThresholdWhereInput[]
    NOT?: PerformanceThresholdWhereInput | PerformanceThresholdWhereInput[]
    redMin?: IntFilter<"PerformanceThreshold"> | number
    redMax?: IntFilter<"PerformanceThreshold"> | number
    yellowMin?: IntFilter<"PerformanceThreshold"> | number
    yellowMax?: IntFilter<"PerformanceThreshold"> | number
    greenMin?: IntFilter<"PerformanceThreshold"> | number
    greenMax?: IntFilter<"PerformanceThreshold"> | number
    createdAt?: DateTimeFilter<"PerformanceThreshold"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceThreshold"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
  }, "id" | "departmentId">

  export type PerformanceThresholdOrderByWithAggregationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceThresholdCountOrderByAggregateInput
    _avg?: PerformanceThresholdAvgOrderByAggregateInput
    _max?: PerformanceThresholdMaxOrderByAggregateInput
    _min?: PerformanceThresholdMinOrderByAggregateInput
    _sum?: PerformanceThresholdSumOrderByAggregateInput
  }

  export type PerformanceThresholdScalarWhereWithAggregatesInput = {
    AND?: PerformanceThresholdScalarWhereWithAggregatesInput | PerformanceThresholdScalarWhereWithAggregatesInput[]
    OR?: PerformanceThresholdScalarWhereWithAggregatesInput[]
    NOT?: PerformanceThresholdScalarWhereWithAggregatesInput | PerformanceThresholdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceThreshold"> | string
    departmentId?: StringWithAggregatesFilter<"PerformanceThreshold"> | string
    redMin?: IntWithAggregatesFilter<"PerformanceThreshold"> | number
    redMax?: IntWithAggregatesFilter<"PerformanceThreshold"> | number
    yellowMin?: IntWithAggregatesFilter<"PerformanceThreshold"> | number
    yellowMax?: IntWithAggregatesFilter<"PerformanceThreshold"> | number
    greenMin?: IntWithAggregatesFilter<"PerformanceThreshold"> | number
    greenMax?: IntWithAggregatesFilter<"PerformanceThreshold"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceThreshold"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceThreshold"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    code?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    parentId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    parentDepartment?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    childDepartments?: DepartmentListRelationFilter
    employees?: EmployeeListRelationFilter
    positions?: PositionListRelationFilter
    performanceThreshold?: XOR<PerformanceThresholdNullableScalarRelationFilter, PerformanceThresholdWhereInput> | null
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentDepartment?: DepartmentOrderByWithRelationInput
    childDepartments?: DepartmentOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    positions?: PositionOrderByRelationAggregateInput
    performanceThreshold?: PerformanceThresholdOrderByWithRelationInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    parentId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    parentDepartment?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    childDepartments?: DepartmentListRelationFilter
    employees?: EmployeeListRelationFilter
    positions?: PositionListRelationFilter
    performanceThreshold?: XOR<PerformanceThresholdNullableScalarRelationFilter, PerformanceThresholdWhereInput> | null
  }, "id" | "name" | "code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    code?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    code?: StringWithAggregatesFilter<"Department"> | string
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    parentId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: StringFilter<"Position"> | string
    title?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    level?: IntFilter<"Position"> | number
    isActive?: BoolFilter<"Position"> | boolean
    departmentId?: StringFilter<"Position"> | string
    minSalary?: DecimalNullableFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    maxSalary?: DecimalNullableFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    employees?: EmployeeListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
    minSalary?: SortOrderInput | SortOrder
    maxSalary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title_departmentId?: PositionTitleDepartmentIdCompoundUniqueInput
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    title?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    level?: IntFilter<"Position"> | number
    isActive?: BoolFilter<"Position"> | boolean
    departmentId?: StringFilter<"Position"> | string
    minSalary?: DecimalNullableFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    maxSalary?: DecimalNullableFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    employees?: EmployeeListRelationFilter
  }, "id" | "title_departmentId">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
    minSalary?: SortOrderInput | SortOrder
    maxSalary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Position"> | string
    title?: StringWithAggregatesFilter<"Position"> | string
    description?: StringNullableWithAggregatesFilter<"Position"> | string | null
    level?: IntWithAggregatesFilter<"Position"> | number
    isActive?: BoolWithAggregatesFilter<"Position"> | boolean
    departmentId?: StringWithAggregatesFilter<"Position"> | string
    minSalary?: DecimalNullableWithAggregatesFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    maxSalary?: DecimalNullableWithAggregatesFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    companyName?: StringFilter<"Customer"> | string
    contactEmail?: StringNullableFilter<"Customer"> | string | null
    contactPhone?: StringNullableFilter<"Customer"> | string | null
    address?: JsonNullableFilter<"Customer">
    isActive?: BoolFilter<"Customer"> | boolean
    industry?: StringNullableFilter<"Customer"> | string | null
    taxNumber?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    subAccounts?: SubAccountListRelationFilter
    orders?: OrderListRelationFilter
    ratings?: RatingListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    industry?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccounts?: SubAccountOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taxNumber?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    companyName?: StringFilter<"Customer"> | string
    contactEmail?: StringNullableFilter<"Customer"> | string | null
    contactPhone?: StringNullableFilter<"Customer"> | string | null
    address?: JsonNullableFilter<"Customer">
    isActive?: BoolFilter<"Customer"> | boolean
    industry?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    subAccounts?: SubAccountListRelationFilter
    orders?: OrderListRelationFilter
    ratings?: RatingListRelationFilter
  }, "id" | "taxNumber">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    industry?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    companyName?: StringWithAggregatesFilter<"Customer"> | string
    contactEmail?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Customer">
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    industry?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SubAccountWhereInput = {
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    name?: StringFilter<"SubAccount"> | string
    code?: StringNullableFilter<"SubAccount"> | string | null
    isActive?: BoolFilter<"SubAccount"> | boolean
    customerId?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type SubAccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type SubAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_name?: SubAccountCustomerIdNameCompoundUniqueInput
    AND?: SubAccountWhereInput | SubAccountWhereInput[]
    OR?: SubAccountWhereInput[]
    NOT?: SubAccountWhereInput | SubAccountWhereInput[]
    name?: StringFilter<"SubAccount"> | string
    code?: StringNullableFilter<"SubAccount"> | string | null
    isActive?: BoolFilter<"SubAccount"> | boolean
    customerId?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customerId_name">

  export type SubAccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubAccountCountOrderByAggregateInput
    _max?: SubAccountMaxOrderByAggregateInput
    _min?: SubAccountMinOrderByAggregateInput
  }

  export type SubAccountScalarWhereWithAggregatesInput = {
    AND?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    OR?: SubAccountScalarWhereWithAggregatesInput[]
    NOT?: SubAccountScalarWhereWithAggregatesInput | SubAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccount"> | string
    name?: StringWithAggregatesFilter<"SubAccount"> | string
    code?: StringNullableWithAggregatesFilter<"SubAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"SubAccount"> | boolean
    customerId?: StringWithAggregatesFilter<"SubAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccount"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    description?: StringNullableFilter<"Order"> | string | null
    scheduledDate?: DateTimeFilter<"Order"> | Date | string
    startTime?: DateTimeNullableFilter<"Order"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Order"> | Date | string | null
    duration?: IntNullableFilter<"Order"> | number | null
    location?: StringNullableFilter<"Order"> | string | null
    requiredEmployees?: IntFilter<"Order"> | number
    priority?: IntFilter<"Order"> | number
    specialInstructions?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    customerId?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    createdBy?: StringNullableFilter<"Order"> | string | null
    updatedBy?: StringNullableFilter<"Order"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    qualifications?: OrderQualificationListRelationFilter
    orderAssignments?: OrderAssignmentListRelationFilter
    employeeAssignments?: AssignmentListRelationFilter
    ratings?: RatingListRelationFilter
    files?: FileListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    description?: SortOrderInput | SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    status?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    qualifications?: OrderQualificationOrderByRelationAggregateInput
    orderAssignments?: OrderAssignmentOrderByRelationAggregateInput
    employeeAssignments?: AssignmentOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    description?: StringNullableFilter<"Order"> | string | null
    scheduledDate?: DateTimeFilter<"Order"> | Date | string
    startTime?: DateTimeNullableFilter<"Order"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Order"> | Date | string | null
    duration?: IntNullableFilter<"Order"> | number | null
    location?: StringNullableFilter<"Order"> | string | null
    requiredEmployees?: IntFilter<"Order"> | number
    priority?: IntFilter<"Order"> | number
    specialInstructions?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    customerId?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    createdBy?: StringNullableFilter<"Order"> | string | null
    updatedBy?: StringNullableFilter<"Order"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    qualifications?: OrderQualificationListRelationFilter
    orderAssignments?: OrderAssignmentListRelationFilter
    employeeAssignments?: AssignmentListRelationFilter
    ratings?: RatingListRelationFilter
    files?: FileListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    description?: SortOrderInput | SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    status?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    description?: StringNullableWithAggregatesFilter<"Order"> | string | null
    scheduledDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"Order"> | number | null
    location?: StringNullableWithAggregatesFilter<"Order"> | string | null
    requiredEmployees?: IntWithAggregatesFilter<"Order"> | number
    priority?: IntWithAggregatesFilter<"Order"> | number
    specialInstructions?: StringNullableWithAggregatesFilter<"Order"> | string | null
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    customerId?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Order"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type QualificationWhereInput = {
    AND?: QualificationWhereInput | QualificationWhereInput[]
    OR?: QualificationWhereInput[]
    NOT?: QualificationWhereInput | QualificationWhereInput[]
    id?: StringFilter<"Qualification"> | string
    name?: StringFilter<"Qualification"> | string
    description?: StringNullableFilter<"Qualification"> | string | null
    category?: StringNullableFilter<"Qualification"> | string | null
    isActive?: BoolFilter<"Qualification"> | boolean
    requiresCertificate?: BoolFilter<"Qualification"> | boolean
    expiryMonths?: IntNullableFilter<"Qualification"> | number | null
    createdAt?: DateTimeFilter<"Qualification"> | Date | string
    updatedAt?: DateTimeFilter<"Qualification"> | Date | string
    employeeQualifications?: EmployeeQualificationListRelationFilter
    orderQualifications?: OrderQualificationListRelationFilter
  }

  export type QualificationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresCertificate?: SortOrder
    expiryMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeQualifications?: EmployeeQualificationOrderByRelationAggregateInput
    orderQualifications?: OrderQualificationOrderByRelationAggregateInput
  }

  export type QualificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: QualificationWhereInput | QualificationWhereInput[]
    OR?: QualificationWhereInput[]
    NOT?: QualificationWhereInput | QualificationWhereInput[]
    description?: StringNullableFilter<"Qualification"> | string | null
    category?: StringNullableFilter<"Qualification"> | string | null
    isActive?: BoolFilter<"Qualification"> | boolean
    requiresCertificate?: BoolFilter<"Qualification"> | boolean
    expiryMonths?: IntNullableFilter<"Qualification"> | number | null
    createdAt?: DateTimeFilter<"Qualification"> | Date | string
    updatedAt?: DateTimeFilter<"Qualification"> | Date | string
    employeeQualifications?: EmployeeQualificationListRelationFilter
    orderQualifications?: OrderQualificationListRelationFilter
  }, "id" | "name">

  export type QualificationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresCertificate?: SortOrder
    expiryMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QualificationCountOrderByAggregateInput
    _avg?: QualificationAvgOrderByAggregateInput
    _max?: QualificationMaxOrderByAggregateInput
    _min?: QualificationMinOrderByAggregateInput
    _sum?: QualificationSumOrderByAggregateInput
  }

  export type QualificationScalarWhereWithAggregatesInput = {
    AND?: QualificationScalarWhereWithAggregatesInput | QualificationScalarWhereWithAggregatesInput[]
    OR?: QualificationScalarWhereWithAggregatesInput[]
    NOT?: QualificationScalarWhereWithAggregatesInput | QualificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Qualification"> | string
    name?: StringWithAggregatesFilter<"Qualification"> | string
    description?: StringNullableWithAggregatesFilter<"Qualification"> | string | null
    category?: StringNullableWithAggregatesFilter<"Qualification"> | string | null
    isActive?: BoolWithAggregatesFilter<"Qualification"> | boolean
    requiresCertificate?: BoolWithAggregatesFilter<"Qualification"> | boolean
    expiryMonths?: IntNullableWithAggregatesFilter<"Qualification"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Qualification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Qualification"> | Date | string
  }

  export type EmployeeQualificationWhereInput = {
    AND?: EmployeeQualificationWhereInput | EmployeeQualificationWhereInput[]
    OR?: EmployeeQualificationWhereInput[]
    NOT?: EmployeeQualificationWhereInput | EmployeeQualificationWhereInput[]
    id?: StringFilter<"EmployeeQualification"> | string
    employeeId?: StringFilter<"EmployeeQualification"> | string
    qualificationId?: StringFilter<"EmployeeQualification"> | string
    acquiredDate?: DateTimeFilter<"EmployeeQualification"> | Date | string
    expiryDate?: DateTimeNullableFilter<"EmployeeQualification"> | Date | string | null
    certificateUrl?: StringNullableFilter<"EmployeeQualification"> | string | null
    isVerified?: BoolFilter<"EmployeeQualification"> | boolean
    proficiencyLevel?: IntFilter<"EmployeeQualification"> | number
    createdAt?: DateTimeFilter<"EmployeeQualification"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeQualification"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    qualification?: XOR<QualificationScalarRelationFilter, QualificationWhereInput>
  }

  export type EmployeeQualificationOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    qualificationId?: SortOrder
    acquiredDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    proficiencyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    qualification?: QualificationOrderByWithRelationInput
  }

  export type EmployeeQualificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_qualificationId?: EmployeeQualificationEmployeeIdQualificationIdCompoundUniqueInput
    AND?: EmployeeQualificationWhereInput | EmployeeQualificationWhereInput[]
    OR?: EmployeeQualificationWhereInput[]
    NOT?: EmployeeQualificationWhereInput | EmployeeQualificationWhereInput[]
    employeeId?: StringFilter<"EmployeeQualification"> | string
    qualificationId?: StringFilter<"EmployeeQualification"> | string
    acquiredDate?: DateTimeFilter<"EmployeeQualification"> | Date | string
    expiryDate?: DateTimeNullableFilter<"EmployeeQualification"> | Date | string | null
    certificateUrl?: StringNullableFilter<"EmployeeQualification"> | string | null
    isVerified?: BoolFilter<"EmployeeQualification"> | boolean
    proficiencyLevel?: IntFilter<"EmployeeQualification"> | number
    createdAt?: DateTimeFilter<"EmployeeQualification"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeQualification"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    qualification?: XOR<QualificationScalarRelationFilter, QualificationWhereInput>
  }, "id" | "employeeId_qualificationId">

  export type EmployeeQualificationOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    qualificationId?: SortOrder
    acquiredDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    proficiencyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeQualificationCountOrderByAggregateInput
    _avg?: EmployeeQualificationAvgOrderByAggregateInput
    _max?: EmployeeQualificationMaxOrderByAggregateInput
    _min?: EmployeeQualificationMinOrderByAggregateInput
    _sum?: EmployeeQualificationSumOrderByAggregateInput
  }

  export type EmployeeQualificationScalarWhereWithAggregatesInput = {
    AND?: EmployeeQualificationScalarWhereWithAggregatesInput | EmployeeQualificationScalarWhereWithAggregatesInput[]
    OR?: EmployeeQualificationScalarWhereWithAggregatesInput[]
    NOT?: EmployeeQualificationScalarWhereWithAggregatesInput | EmployeeQualificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeQualification"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeQualification"> | string
    qualificationId?: StringWithAggregatesFilter<"EmployeeQualification"> | string
    acquiredDate?: DateTimeWithAggregatesFilter<"EmployeeQualification"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"EmployeeQualification"> | Date | string | null
    certificateUrl?: StringNullableWithAggregatesFilter<"EmployeeQualification"> | string | null
    isVerified?: BoolWithAggregatesFilter<"EmployeeQualification"> | boolean
    proficiencyLevel?: IntWithAggregatesFilter<"EmployeeQualification"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeQualification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeQualification"> | Date | string
  }

  export type OrderQualificationWhereInput = {
    AND?: OrderQualificationWhereInput | OrderQualificationWhereInput[]
    OR?: OrderQualificationWhereInput[]
    NOT?: OrderQualificationWhereInput | OrderQualificationWhereInput[]
    id?: StringFilter<"OrderQualification"> | string
    orderId?: StringFilter<"OrderQualification"> | string
    qualificationId?: StringFilter<"OrderQualification"> | string
    required?: BoolFilter<"OrderQualification"> | boolean
    minProficiency?: IntFilter<"OrderQualification"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    qualification?: XOR<QualificationScalarRelationFilter, QualificationWhereInput>
  }

  export type OrderQualificationOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    qualificationId?: SortOrder
    required?: SortOrder
    minProficiency?: SortOrder
    order?: OrderOrderByWithRelationInput
    qualification?: QualificationOrderByWithRelationInput
  }

  export type OrderQualificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId_qualificationId?: OrderQualificationOrderIdQualificationIdCompoundUniqueInput
    AND?: OrderQualificationWhereInput | OrderQualificationWhereInput[]
    OR?: OrderQualificationWhereInput[]
    NOT?: OrderQualificationWhereInput | OrderQualificationWhereInput[]
    orderId?: StringFilter<"OrderQualification"> | string
    qualificationId?: StringFilter<"OrderQualification"> | string
    required?: BoolFilter<"OrderQualification"> | boolean
    minProficiency?: IntFilter<"OrderQualification"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    qualification?: XOR<QualificationScalarRelationFilter, QualificationWhereInput>
  }, "id" | "orderId_qualificationId">

  export type OrderQualificationOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    qualificationId?: SortOrder
    required?: SortOrder
    minProficiency?: SortOrder
    _count?: OrderQualificationCountOrderByAggregateInput
    _avg?: OrderQualificationAvgOrderByAggregateInput
    _max?: OrderQualificationMaxOrderByAggregateInput
    _min?: OrderQualificationMinOrderByAggregateInput
    _sum?: OrderQualificationSumOrderByAggregateInput
  }

  export type OrderQualificationScalarWhereWithAggregatesInput = {
    AND?: OrderQualificationScalarWhereWithAggregatesInput | OrderQualificationScalarWhereWithAggregatesInput[]
    OR?: OrderQualificationScalarWhereWithAggregatesInput[]
    NOT?: OrderQualificationScalarWhereWithAggregatesInput | OrderQualificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderQualification"> | string
    orderId?: StringWithAggregatesFilter<"OrderQualification"> | string
    qualificationId?: StringWithAggregatesFilter<"OrderQualification"> | string
    required?: BoolWithAggregatesFilter<"OrderQualification"> | boolean
    minProficiency?: IntWithAggregatesFilter<"OrderQualification"> | number
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    orderId?: StringNullableFilter<"Assignment"> | string | null
    employeeId?: StringFilter<"Assignment"> | string
    assignedDate?: DateTimeFilter<"Assignment"> | Date | string
    startDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    status?: EnumAssignmentStatusFilter<"Assignment"> | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFilter<"Assignment"> | $Enums.AssignmentTier
    estimatedHours?: DecimalNullableFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    actualHours?: DecimalNullableFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Assignment"> | string | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    createdBy?: StringNullableFilter<"Assignment"> | string | null
    updatedBy?: StringNullableFilter<"Assignment"> | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    files?: FileListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    assignedDate?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    tier?: SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    orderId?: StringNullableFilter<"Assignment"> | string | null
    employeeId?: StringFilter<"Assignment"> | string
    assignedDate?: DateTimeFilter<"Assignment"> | Date | string
    startDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    status?: EnumAssignmentStatusFilter<"Assignment"> | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFilter<"Assignment"> | $Enums.AssignmentTier
    estimatedHours?: DecimalNullableFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    actualHours?: DecimalNullableFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Assignment"> | string | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    createdBy?: StringNullableFilter<"Assignment"> | string | null
    updatedBy?: StringNullableFilter<"Assignment"> | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    files?: FileListRelationFilter
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    assignedDate?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    tier?: SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    actualHours?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    orderId?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    employeeId?: StringWithAggregatesFilter<"Assignment"> | string
    assignedDate?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    status?: EnumAssignmentStatusWithAggregatesFilter<"Assignment"> | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierWithAggregatesFilter<"Assignment"> | $Enums.AssignmentTier
    estimatedHours?: DecimalNullableWithAggregatesFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    actualHours?: DecimalNullableWithAggregatesFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
  }

  export type OrderAssignmentWhereInput = {
    AND?: OrderAssignmentWhereInput | OrderAssignmentWhereInput[]
    OR?: OrderAssignmentWhereInput[]
    NOT?: OrderAssignmentWhereInput | OrderAssignmentWhereInput[]
    id?: StringFilter<"OrderAssignment"> | string
    orderId?: StringFilter<"OrderAssignment"> | string
    employeeId?: StringFilter<"OrderAssignment"> | string
    role?: StringNullableFilter<"OrderAssignment"> | string | null
    hourlyRate?: DecimalNullableFilter<"OrderAssignment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OrderAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"OrderAssignment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type OrderAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    role?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type OrderAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId_employeeId?: OrderAssignmentOrderIdEmployeeIdCompoundUniqueInput
    AND?: OrderAssignmentWhereInput | OrderAssignmentWhereInput[]
    OR?: OrderAssignmentWhereInput[]
    NOT?: OrderAssignmentWhereInput | OrderAssignmentWhereInput[]
    orderId?: StringFilter<"OrderAssignment"> | string
    employeeId?: StringFilter<"OrderAssignment"> | string
    role?: StringNullableFilter<"OrderAssignment"> | string | null
    hourlyRate?: DecimalNullableFilter<"OrderAssignment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OrderAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"OrderAssignment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "orderId_employeeId">

  export type OrderAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    role?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderAssignmentCountOrderByAggregateInput
    _avg?: OrderAssignmentAvgOrderByAggregateInput
    _max?: OrderAssignmentMaxOrderByAggregateInput
    _min?: OrderAssignmentMinOrderByAggregateInput
    _sum?: OrderAssignmentSumOrderByAggregateInput
  }

  export type OrderAssignmentScalarWhereWithAggregatesInput = {
    AND?: OrderAssignmentScalarWhereWithAggregatesInput | OrderAssignmentScalarWhereWithAggregatesInput[]
    OR?: OrderAssignmentScalarWhereWithAggregatesInput[]
    NOT?: OrderAssignmentScalarWhereWithAggregatesInput | OrderAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderAssignment"> | string
    orderId?: StringWithAggregatesFilter<"OrderAssignment"> | string
    employeeId?: StringWithAggregatesFilter<"OrderAssignment"> | string
    role?: StringNullableWithAggregatesFilter<"OrderAssignment"> | string | null
    hourlyRate?: DecimalNullableWithAggregatesFilter<"OrderAssignment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderAssignment"> | Date | string
  }

  export type AbsenceWhereInput = {
    AND?: AbsenceWhereInput | AbsenceWhereInput[]
    OR?: AbsenceWhereInput[]
    NOT?: AbsenceWhereInput | AbsenceWhereInput[]
    id?: StringFilter<"Absence"> | string
    employeeId?: StringFilter<"Absence"> | string
    type?: EnumAbsenceTypeFilter<"Absence"> | $Enums.AbsenceType
    startDate?: DateTimeFilter<"Absence"> | Date | string
    endDate?: DateTimeFilter<"Absence"> | Date | string
    reason?: StringNullableFilter<"Absence"> | string | null
    status?: EnumRequestStatusFilter<"Absence"> | $Enums.RequestStatus
    approvedBy?: StringNullableFilter<"Absence"> | string | null
    approvedAt?: DateTimeNullableFilter<"Absence"> | Date | string | null
    rejectedBy?: StringNullableFilter<"Absence"> | string | null
    rejectedAt?: DateTimeNullableFilter<"Absence"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Absence"> | string | null
    documentUrls?: StringNullableListFilter<"Absence">
    createdAt?: DateTimeFilter<"Absence"> | Date | string
    updatedAt?: DateTimeFilter<"Absence"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type AbsenceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AbsenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AbsenceWhereInput | AbsenceWhereInput[]
    OR?: AbsenceWhereInput[]
    NOT?: AbsenceWhereInput | AbsenceWhereInput[]
    employeeId?: StringFilter<"Absence"> | string
    type?: EnumAbsenceTypeFilter<"Absence"> | $Enums.AbsenceType
    startDate?: DateTimeFilter<"Absence"> | Date | string
    endDate?: DateTimeFilter<"Absence"> | Date | string
    reason?: StringNullableFilter<"Absence"> | string | null
    status?: EnumRequestStatusFilter<"Absence"> | $Enums.RequestStatus
    approvedBy?: StringNullableFilter<"Absence"> | string | null
    approvedAt?: DateTimeNullableFilter<"Absence"> | Date | string | null
    rejectedBy?: StringNullableFilter<"Absence"> | string | null
    rejectedAt?: DateTimeNullableFilter<"Absence"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Absence"> | string | null
    documentUrls?: StringNullableListFilter<"Absence">
    createdAt?: DateTimeFilter<"Absence"> | Date | string
    updatedAt?: DateTimeFilter<"Absence"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type AbsenceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AbsenceCountOrderByAggregateInput
    _max?: AbsenceMaxOrderByAggregateInput
    _min?: AbsenceMinOrderByAggregateInput
  }

  export type AbsenceScalarWhereWithAggregatesInput = {
    AND?: AbsenceScalarWhereWithAggregatesInput | AbsenceScalarWhereWithAggregatesInput[]
    OR?: AbsenceScalarWhereWithAggregatesInput[]
    NOT?: AbsenceScalarWhereWithAggregatesInput | AbsenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Absence"> | string
    employeeId?: StringWithAggregatesFilter<"Absence"> | string
    type?: EnumAbsenceTypeWithAggregatesFilter<"Absence"> | $Enums.AbsenceType
    startDate?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    status?: EnumRequestStatusWithAggregatesFilter<"Absence"> | $Enums.RequestStatus
    approvedBy?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Absence"> | Date | string | null
    rejectedBy?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Absence"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    documentUrls?: StringNullableListFilter<"Absence">
    createdAt?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: StringFilter<"Rating"> | string
    orderId?: StringNullableFilter<"Rating"> | string | null
    employeeId?: StringNullableFilter<"Rating"> | string | null
    customerId?: StringNullableFilter<"Rating"> | string | null
    rating?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    category?: StringNullableFilter<"Rating"> | string | null
    status?: EnumRatingStatusFilter<"Rating"> | $Enums.RatingStatus
    ratedBy?: StringNullableFilter<"Rating"> | string | null
    ratingDate?: DateTimeFilter<"Rating"> | Date | string
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    ratedBy?: SortOrderInput | SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    orderId?: StringNullableFilter<"Rating"> | string | null
    employeeId?: StringNullableFilter<"Rating"> | string | null
    customerId?: StringNullableFilter<"Rating"> | string | null
    rating?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    category?: StringNullableFilter<"Rating"> | string | null
    status?: EnumRatingStatusFilter<"Rating"> | $Enums.RatingStatus
    ratedBy?: StringNullableFilter<"Rating"> | string | null
    ratingDate?: DateTimeFilter<"Rating"> | Date | string
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    ratedBy?: SortOrderInput | SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rating"> | string
    orderId?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    rating?: IntWithAggregatesFilter<"Rating"> | number
    comment?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    category?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    status?: EnumRatingStatusWithAggregatesFilter<"Rating"> | $Enums.RatingStatus
    ratedBy?: StringNullableWithAggregatesFilter<"Rating"> | string | null
    ratingDate?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Rating"> | Date | string
  }

  export type WorkStatisticWhereInput = {
    AND?: WorkStatisticWhereInput | WorkStatisticWhereInput[]
    OR?: WorkStatisticWhereInput[]
    NOT?: WorkStatisticWhereInput | WorkStatisticWhereInput[]
    id?: StringFilter<"WorkStatistic"> | string
    date?: DateTimeFilter<"WorkStatistic"> | Date | string
    employeeId?: StringFilter<"WorkStatistic"> | string
    hoursWorked?: DecimalFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableFilter<"WorkStatistic"> | string | null
    projects?: StringNullableListFilter<"WorkStatistic">
    efficiency?: DecimalNullableFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: DecimalNullableFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"WorkStatistic"> | Date | string
    updatedAt?: DateTimeFilter<"WorkStatistic"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type WorkStatisticOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    location?: SortOrderInput | SortOrder
    projects?: SortOrder
    efficiency?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type WorkStatisticWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_date?: WorkStatisticEmployeeIdDateCompoundUniqueInput
    AND?: WorkStatisticWhereInput | WorkStatisticWhereInput[]
    OR?: WorkStatisticWhereInput[]
    NOT?: WorkStatisticWhereInput | WorkStatisticWhereInput[]
    date?: DateTimeFilter<"WorkStatistic"> | Date | string
    employeeId?: StringFilter<"WorkStatistic"> | string
    hoursWorked?: DecimalFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableFilter<"WorkStatistic"> | string | null
    projects?: StringNullableListFilter<"WorkStatistic">
    efficiency?: DecimalNullableFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: DecimalNullableFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"WorkStatistic"> | Date | string
    updatedAt?: DateTimeFilter<"WorkStatistic"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_date">

  export type WorkStatisticOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    location?: SortOrderInput | SortOrder
    projects?: SortOrder
    efficiency?: SortOrderInput | SortOrder
    qualityScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkStatisticCountOrderByAggregateInput
    _avg?: WorkStatisticAvgOrderByAggregateInput
    _max?: WorkStatisticMaxOrderByAggregateInput
    _min?: WorkStatisticMinOrderByAggregateInput
    _sum?: WorkStatisticSumOrderByAggregateInput
  }

  export type WorkStatisticScalarWhereWithAggregatesInput = {
    AND?: WorkStatisticScalarWhereWithAggregatesInput | WorkStatisticScalarWhereWithAggregatesInput[]
    OR?: WorkStatisticScalarWhereWithAggregatesInput[]
    NOT?: WorkStatisticScalarWhereWithAggregatesInput | WorkStatisticScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkStatistic"> | string
    date?: DateTimeWithAggregatesFilter<"WorkStatistic"> | Date | string
    employeeId?: StringWithAggregatesFilter<"WorkStatistic"> | string
    hoursWorked?: DecimalWithAggregatesFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalWithAggregatesFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableWithAggregatesFilter<"WorkStatistic"> | string | null
    projects?: StringNullableListFilter<"WorkStatistic">
    efficiency?: DecimalNullableWithAggregatesFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: DecimalNullableWithAggregatesFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkStatistic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkStatistic"> | Date | string
  }

  export type NotificationTemplateWhereInput = {
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    key?: StringFilter<"NotificationTemplate"> | string
    title?: StringFilter<"NotificationTemplate"> | string
    body?: StringFilter<"NotificationTemplate"> | string
    defaultChannels?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolFilter<"NotificationTemplate"> | boolean
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    body?: SortOrder
    defaultChannels?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    title?: StringFilter<"NotificationTemplate"> | string
    body?: StringFilter<"NotificationTemplate"> | string
    defaultChannels?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolFilter<"NotificationTemplate"> | boolean
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
  }, "id" | "key">

  export type NotificationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    body?: SortOrder
    defaultChannels?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationTemplateCountOrderByAggregateInput
    _max?: NotificationTemplateMaxOrderByAggregateInput
    _min?: NotificationTemplateMinOrderByAggregateInput
  }

  export type NotificationTemplateScalarWhereWithAggregatesInput = {
    AND?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    OR?: NotificationTemplateScalarWhereWithAggregatesInput[]
    NOT?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    key?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    title?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    body?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    defaultChannels?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolWithAggregatesFilter<"NotificationTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    templateKey?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    category?: StringNullableFilter<"Notification"> | string | null
    createdBy?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: StringFilter<"Notification"> | string
    recipients?: NotificationRecipientListRelationFilter
    NotificationOutbox?: NotificationOutboxListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    templateKey?: SortOrderInput | SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    status?: SortOrder
    recipients?: NotificationRecipientOrderByRelationAggregateInput
    NotificationOutbox?: NotificationOutboxOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    templateKey?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    category?: StringNullableFilter<"Notification"> | string | null
    createdBy?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: StringFilter<"Notification"> | string
    recipients?: NotificationRecipientListRelationFilter
    NotificationOutbox?: NotificationOutboxListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    templateKey?: SortOrderInput | SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    templateKey?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    category?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    status?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type NotificationRecipientWhereInput = {
    AND?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    OR?: NotificationRecipientWhereInput[]
    NOT?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    id?: StringFilter<"NotificationRecipient"> | string
    notificationId?: StringFilter<"NotificationRecipient"> | string
    userId?: StringNullableFilter<"NotificationRecipient"> | string | null
    channels?: StringNullableListFilter<"NotificationRecipient">
    readAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    seenAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    isArchived?: BoolFilter<"NotificationRecipient"> | boolean
    status?: StringFilter<"NotificationRecipient"> | string
    error?: StringNullableFilter<"NotificationRecipient"> | string | null
    createdAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationRecipientOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    channels?: SortOrder
    readAt?: SortOrderInput | SortOrder
    seenAt?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    OR?: NotificationRecipientWhereInput[]
    NOT?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    notificationId?: StringFilter<"NotificationRecipient"> | string
    userId?: StringNullableFilter<"NotificationRecipient"> | string | null
    channels?: StringNullableListFilter<"NotificationRecipient">
    readAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    seenAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    isArchived?: BoolFilter<"NotificationRecipient"> | boolean
    status?: StringFilter<"NotificationRecipient"> | string
    error?: StringNullableFilter<"NotificationRecipient"> | string | null
    createdAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    channels?: SortOrder
    readAt?: SortOrderInput | SortOrder
    seenAt?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationRecipientCountOrderByAggregateInput
    _max?: NotificationRecipientMaxOrderByAggregateInput
    _min?: NotificationRecipientMinOrderByAggregateInput
  }

  export type NotificationRecipientScalarWhereWithAggregatesInput = {
    AND?: NotificationRecipientScalarWhereWithAggregatesInput | NotificationRecipientScalarWhereWithAggregatesInput[]
    OR?: NotificationRecipientScalarWhereWithAggregatesInput[]
    NOT?: NotificationRecipientScalarWhereWithAggregatesInput | NotificationRecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationRecipient"> | string
    notificationId?: StringWithAggregatesFilter<"NotificationRecipient"> | string
    userId?: StringNullableWithAggregatesFilter<"NotificationRecipient"> | string | null
    channels?: StringNullableListFilter<"NotificationRecipient">
    readAt?: DateTimeNullableWithAggregatesFilter<"NotificationRecipient"> | Date | string | null
    seenAt?: DateTimeNullableWithAggregatesFilter<"NotificationRecipient"> | Date | string | null
    isArchived?: BoolWithAggregatesFilter<"NotificationRecipient"> | boolean
    status?: StringWithAggregatesFilter<"NotificationRecipient"> | string
    error?: StringNullableWithAggregatesFilter<"NotificationRecipient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationRecipient"> | Date | string
  }

  export type NotificationOutboxWhereInput = {
    AND?: NotificationOutboxWhereInput | NotificationOutboxWhereInput[]
    OR?: NotificationOutboxWhereInput[]
    NOT?: NotificationOutboxWhereInput | NotificationOutboxWhereInput[]
    id?: StringFilter<"NotificationOutbox"> | string
    notificationId?: StringNullableFilter<"NotificationOutbox"> | string | null
    payload?: JsonFilter<"NotificationOutbox">
    channel?: StringFilter<"NotificationOutbox"> | string
    attempts?: IntFilter<"NotificationOutbox"> | number
    maxAttempts?: IntFilter<"NotificationOutbox"> | number
    lockedUntil?: DateTimeNullableFilter<"NotificationOutbox"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationOutbox"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationOutbox"> | Date | string
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
  }

  export type NotificationOutboxOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrderInput | SortOrder
    payload?: SortOrder
    channel?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
  }

  export type NotificationOutboxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationOutboxWhereInput | NotificationOutboxWhereInput[]
    OR?: NotificationOutboxWhereInput[]
    NOT?: NotificationOutboxWhereInput | NotificationOutboxWhereInput[]
    notificationId?: StringNullableFilter<"NotificationOutbox"> | string | null
    payload?: JsonFilter<"NotificationOutbox">
    channel?: StringFilter<"NotificationOutbox"> | string
    attempts?: IntFilter<"NotificationOutbox"> | number
    maxAttempts?: IntFilter<"NotificationOutbox"> | number
    lockedUntil?: DateTimeNullableFilter<"NotificationOutbox"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationOutbox"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationOutbox"> | Date | string
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
  }, "id">

  export type NotificationOutboxOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrderInput | SortOrder
    payload?: SortOrder
    channel?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationOutboxCountOrderByAggregateInput
    _avg?: NotificationOutboxAvgOrderByAggregateInput
    _max?: NotificationOutboxMaxOrderByAggregateInput
    _min?: NotificationOutboxMinOrderByAggregateInput
    _sum?: NotificationOutboxSumOrderByAggregateInput
  }

  export type NotificationOutboxScalarWhereWithAggregatesInput = {
    AND?: NotificationOutboxScalarWhereWithAggregatesInput | NotificationOutboxScalarWhereWithAggregatesInput[]
    OR?: NotificationOutboxScalarWhereWithAggregatesInput[]
    NOT?: NotificationOutboxScalarWhereWithAggregatesInput | NotificationOutboxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationOutbox"> | string
    notificationId?: StringNullableWithAggregatesFilter<"NotificationOutbox"> | string | null
    payload?: JsonWithAggregatesFilter<"NotificationOutbox">
    channel?: StringWithAggregatesFilter<"NotificationOutbox"> | string
    attempts?: IntWithAggregatesFilter<"NotificationOutbox"> | number
    maxAttempts?: IntWithAggregatesFilter<"NotificationOutbox"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"NotificationOutbox"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationOutbox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationOutbox"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    channels?: StringNullableListFilter<"NotificationPreference">
    quietHoursStart?: IntNullableFilter<"NotificationPreference"> | number | null
    quietHoursEnd?: IntNullableFilter<"NotificationPreference"> | number | null
    digestEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    channels?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    digestEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    channels?: StringNullableListFilter<"NotificationPreference">
    quietHoursStart?: IntNullableFilter<"NotificationPreference"> | number | null
    quietHoursEnd?: IntNullableFilter<"NotificationPreference"> | number | null
    digestEnabled?: BoolFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channels?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    digestEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _avg?: NotificationPreferenceAvgOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
    _sum?: NotificationPreferenceSumOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    channels?: StringNullableListFilter<"NotificationPreference">
    quietHoursStart?: IntNullableWithAggregatesFilter<"NotificationPreference"> | number | null
    quietHoursEnd?: IntNullableWithAggregatesFilter<"NotificationPreference"> | number | null
    digestEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    path?: StringFilter<"File"> | string
    documentType?: EnumDocumentTypeFilter<"File"> | $Enums.DocumentType
    description?: StringNullableFilter<"File"> | string | null
    expiryDate?: DateTimeNullableFilter<"File"> | Date | string | null
    employeeId?: StringNullableFilter<"File"> | string | null
    orderId?: StringNullableFilter<"File"> | string | null
    assignmentId?: StringNullableFilter<"File"> | string | null
    uploadedBy?: StringNullableFilter<"File"> | string | null
    isVerified?: BoolFilter<"File"> | boolean
    isPublic?: BoolFilter<"File"> | boolean
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    documentType?: SortOrder
    description?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    assignmentId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    assignment?: AssignmentOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    path?: StringFilter<"File"> | string
    documentType?: EnumDocumentTypeFilter<"File"> | $Enums.DocumentType
    description?: StringNullableFilter<"File"> | string | null
    expiryDate?: DateTimeNullableFilter<"File"> | Date | string | null
    employeeId?: StringNullableFilter<"File"> | string | null
    orderId?: StringNullableFilter<"File"> | string | null
    assignmentId?: StringNullableFilter<"File"> | string | null
    uploadedBy?: StringNullableFilter<"File"> | string | null
    isVerified?: BoolFilter<"File"> | boolean
    isPublic?: BoolFilter<"File"> | boolean
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    assignment?: XOR<AssignmentNullableScalarRelationFilter, AssignmentWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    documentType?: SortOrder
    description?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    assignmentId?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    originalName?: StringWithAggregatesFilter<"File"> | string
    mimeType?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    path?: StringWithAggregatesFilter<"File"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"File"> | $Enums.DocumentType
    description?: StringNullableWithAggregatesFilter<"File"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
    employeeId?: StringNullableWithAggregatesFilter<"File"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"File"> | string | null
    assignmentId?: StringNullableWithAggregatesFilter<"File"> | string | null
    uploadedBy?: StringNullableWithAggregatesFilter<"File"> | string | null
    isVerified?: BoolWithAggregatesFilter<"File"> | boolean
    isPublic?: BoolWithAggregatesFilter<"File"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    isActive?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    isActive?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    changes?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tableName?: StringFilter<"AuditLog"> | string
    recordId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    changes?: JsonNullableFilter<"AuditLog">
    userId?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tableName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceUncheckedCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeePerformanceCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPerformanceRecordsInput
    manualOverrideBy?: UserCreateNestedOneWithoutManualOverridesInput
  }

  export type EmployeePerformanceUncheckedCreateInput = {
    id?: string
    employeeId: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    manualOverrideById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPerformanceRecordsNestedInput
    manualOverrideBy?: UserUpdateOneWithoutManualOverridesNestedInput
  }

  export type EmployeePerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    manualOverrideById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePerformanceCreateManyInput = {
    id?: string
    employeeId: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    manualOverrideById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    manualOverrideById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceThresholdCreateInput = {
    id?: string
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPerformanceThresholdInput
  }

  export type PerformanceThresholdUncheckedCreateInput = {
    id?: string
    departmentId: string
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceThresholdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    redMin?: IntFieldUpdateOperationsInput | number
    redMax?: IntFieldUpdateOperationsInput | number
    yellowMin?: IntFieldUpdateOperationsInput | number
    yellowMax?: IntFieldUpdateOperationsInput | number
    greenMin?: IntFieldUpdateOperationsInput | number
    greenMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPerformanceThresholdNestedInput
  }

  export type PerformanceThresholdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    redMin?: IntFieldUpdateOperationsInput | number
    redMax?: IntFieldUpdateOperationsInput | number
    yellowMin?: IntFieldUpdateOperationsInput | number
    yellowMax?: IntFieldUpdateOperationsInput | number
    greenMin?: IntFieldUpdateOperationsInput | number
    greenMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceThresholdCreateManyInput = {
    id?: string
    departmentId: string
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceThresholdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    redMin?: IntFieldUpdateOperationsInput | number
    redMax?: IntFieldUpdateOperationsInput | number
    yellowMin?: IntFieldUpdateOperationsInput | number
    yellowMax?: IntFieldUpdateOperationsInput | number
    greenMin?: IntFieldUpdateOperationsInput | number
    greenMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceThresholdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    redMin?: IntFieldUpdateOperationsInput | number
    redMax?: IntFieldUpdateOperationsInput | number
    yellowMin?: IntFieldUpdateOperationsInput | number
    yellowMax?: IntFieldUpdateOperationsInput | number
    greenMin?: IntFieldUpdateOperationsInput | number
    greenMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentDepartment?: DepartmentCreateNestedOneWithoutChildDepartmentsInput
    childDepartments?: DepartmentCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    positions?: PositionCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDepartment?: DepartmentUpdateOneWithoutChildDepartmentsNestedInput
    childDepartments?: DepartmentUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDepartments?: DepartmentUncheckedUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUncheckedUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPositionsInput
    employees?: EmployeeCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    departmentId: string
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPositionsNestedInput
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: StringFieldUpdateOperationsInput | string
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    departmentId: string
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: StringFieldUpdateOperationsInput | string
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccounts?: SubAccountCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    ratings?: RatingCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccounts?: SubAccountUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    ratings?: RatingUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccounts?: SubAccountUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountCreateInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSubAccountsInput
  }

  export type SubAccountUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSubAccountsNestedInput
  }

  export type SubAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    qualifications?: OrderQualificationCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentCreateNestedManyWithoutOrderInput
    ratings?: RatingCreateNestedManyWithoutOrderInput
    files?: FileCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationUncheckedCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentUncheckedCreateNestedManyWithoutOrderInput
    ratings?: RatingUncheckedCreateNestedManyWithoutOrderInput
    files?: FileUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    qualifications?: OrderQualificationUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUpdateManyWithoutOrderNestedInput
    ratings?: RatingUpdateManyWithoutOrderNestedInput
    files?: FileUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutOrderNestedInput
    files?: FileUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QualificationCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeQualifications?: EmployeeQualificationCreateNestedManyWithoutQualificationInput
    orderQualifications?: OrderQualificationCreateNestedManyWithoutQualificationInput
  }

  export type QualificationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeQualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutQualificationInput
    orderQualifications?: OrderQualificationUncheckedCreateNestedManyWithoutQualificationInput
  }

  export type QualificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeQualifications?: EmployeeQualificationUpdateManyWithoutQualificationNestedInput
    orderQualifications?: OrderQualificationUpdateManyWithoutQualificationNestedInput
  }

  export type QualificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeQualifications?: EmployeeQualificationUncheckedUpdateManyWithoutQualificationNestedInput
    orderQualifications?: OrderQualificationUncheckedUpdateManyWithoutQualificationNestedInput
  }

  export type QualificationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationCreateInput = {
    id?: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutQualificationsInput
    qualification: QualificationCreateNestedOneWithoutEmployeeQualificationsInput
  }

  export type EmployeeQualificationUncheckedCreateInput = {
    id?: string
    employeeId: string
    qualificationId: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeQualificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutQualificationsNestedInput
    qualification?: QualificationUpdateOneRequiredWithoutEmployeeQualificationsNestedInput
  }

  export type EmployeeQualificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationCreateManyInput = {
    id?: string
    employeeId: string
    qualificationId: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeQualificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderQualificationCreateInput = {
    id?: string
    required?: boolean
    minProficiency?: number
    order: OrderCreateNestedOneWithoutQualificationsInput
    qualification: QualificationCreateNestedOneWithoutOrderQualificationsInput
  }

  export type OrderQualificationUncheckedCreateInput = {
    id?: string
    orderId: string
    qualificationId: string
    required?: boolean
    minProficiency?: number
  }

  export type OrderQualificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutQualificationsNestedInput
    qualification?: QualificationUpdateOneRequiredWithoutOrderQualificationsNestedInput
  }

  export type OrderQualificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type OrderQualificationCreateManyInput = {
    id?: string
    orderId: string
    qualificationId: string
    required?: boolean
    minProficiency?: number
  }

  export type OrderQualificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type OrderQualificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentCreateInput = {
    id?: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    order?: OrderCreateNestedOneWithoutEmployeeAssignmentsInput
    employee: EmployeeCreateNestedOneWithoutAssignmentsInput
    files?: FileCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    orderId?: string | null
    employeeId: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    files?: FileUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutEmployeeAssignmentsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutAssignmentsNestedInput
    files?: FileUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: string
    orderId?: string | null
    employeeId: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderAssignmentCreateInput = {
    id?: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderAssignmentsInput
    employee: EmployeeCreateNestedOneWithoutOrderAssignmentsInput
  }

  export type OrderAssignmentUncheckedCreateInput = {
    id?: string
    orderId: string
    employeeId: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderAssignmentsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutOrderAssignmentsNestedInput
  }

  export type OrderAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAssignmentCreateManyInput = {
    id?: string
    orderId: string
    employeeId: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceCreateInput = {
    id?: string
    type: $Enums.AbsenceType
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.RequestStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    documentUrls?: AbsenceCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAbsencesInput
  }

  export type AbsenceUncheckedCreateInput = {
    id?: string
    employeeId: string
    type: $Enums.AbsenceType
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.RequestStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    documentUrls?: AbsenceCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AbsenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAbsencesNestedInput
  }

  export type AbsenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceCreateManyInput = {
    id?: string
    employeeId: string
    type: $Enums.AbsenceType
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.RequestStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    documentUrls?: AbsenceCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AbsenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutRatingsInput
    employee?: EmployeeCreateNestedOneWithoutRatingsInput
    customer?: CustomerCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: string
    orderId?: string | null
    employeeId?: string | null
    customerId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutRatingsNestedInput
    employee?: EmployeeUpdateOneWithoutRatingsNestedInput
    customer?: CustomerUpdateOneWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: string
    orderId?: string | null
    employeeId?: string | null
    customerId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkStatisticCreateInput = {
    id?: string
    date: Date | string
    hoursWorked: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    location?: string | null
    projects?: WorkStatisticCreateprojectsInput | string[]
    efficiency?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutWorkStatisticsInput
  }

  export type WorkStatisticUncheckedCreateInput = {
    id?: string
    date: Date | string
    employeeId: string
    hoursWorked: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    location?: string | null
    projects?: WorkStatisticCreateprojectsInput | string[]
    efficiency?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkStatisticUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutWorkStatisticsNestedInput
  }

  export type WorkStatisticUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkStatisticCreateManyInput = {
    id?: string
    date: Date | string
    employeeId: string
    hoursWorked: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    location?: string | null
    projects?: WorkStatisticCreateprojectsInput | string[]
    efficiency?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkStatisticUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkStatisticUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateCreateInput = {
    id?: string
    key: string
    title: string
    body: string
    defaultChannels?: NotificationTemplateCreatedefaultChannelsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUncheckedCreateInput = {
    id?: string
    key: string
    title: string
    body: string
    defaultChannels?: NotificationTemplateCreatedefaultChannelsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    defaultChannels?: NotificationTemplateUpdatedefaultChannelsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    defaultChannels?: NotificationTemplateUpdatedefaultChannelsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateCreateManyInput = {
    id?: string
    key: string
    title: string
    body: string
    defaultChannels?: NotificationTemplateCreatedefaultChannelsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    defaultChannels?: NotificationTemplateUpdatedefaultChannelsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    defaultChannels?: NotificationTemplateUpdatedefaultChannelsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
    recipients?: NotificationRecipientCreateNestedManyWithoutNotificationInput
    NotificationOutbox?: NotificationOutboxCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
    recipients?: NotificationRecipientUncheckedCreateNestedManyWithoutNotificationInput
    NotificationOutbox?: NotificationOutboxUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NotificationRecipientUpdateManyWithoutNotificationNestedInput
    NotificationOutbox?: NotificationOutboxUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NotificationRecipientUncheckedUpdateManyWithoutNotificationNestedInput
    NotificationOutbox?: NotificationOutboxUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationRecipientCreateInput = {
    id?: string
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
    notification: NotificationCreateNestedOneWithoutRecipientsInput
    user?: UserCreateNestedOneWithoutNotificationRecipientsInput
  }

  export type NotificationRecipientUncheckedCreateInput = {
    id?: string
    notificationId: string
    userId?: string | null
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutRecipientsNestedInput
    user?: UserUpdateOneWithoutNotificationRecipientsNestedInput
  }

  export type NotificationRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientCreateManyInput = {
    id?: string
    notificationId: string
    userId?: string | null
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationOutboxCreateInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    channel: string
    attempts?: number
    maxAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notification?: NotificationCreateNestedOneWithoutNotificationOutboxInput
  }

  export type NotificationOutboxUncheckedCreateInput = {
    id?: string
    notificationId?: string | null
    payload: JsonNullValueInput | InputJsonValue
    channel: string
    attempts?: number
    maxAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationOutboxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneWithoutNotificationOutboxNestedInput
  }

  export type NotificationOutboxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationOutboxCreateManyInput = {
    id?: string
    notificationId?: string | null
    payload: JsonNullValueInput | InputJsonValue
    channel: string
    attempts?: number
    maxAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationOutboxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationOutboxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    channels?: NotificationPreferenceCreatechannelsInput | string[]
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    digestEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    channels?: NotificationPreferenceCreatechannelsInput | string[]
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    digestEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationPreferenceUpdatechannelsInput | string[]
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channels?: NotificationPreferenceUpdatechannelsInput | string[]
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    channels?: NotificationPreferenceCreatechannelsInput | string[]
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    digestEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationPreferenceUpdatechannelsInput | string[]
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channels?: NotificationPreferenceUpdatechannelsInput | string[]
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutFilesInput
    order?: OrderCreateNestedOneWithoutFilesInput
    assignment?: AssignmentCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    employeeId?: string | null
    orderId?: string | null
    assignmentId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutFilesNestedInput
    order?: OrderUpdateOneWithoutFilesNestedInput
    assignment?: AssignmentUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    employeeId?: string | null
    orderId?: string | null
    assignmentId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    tableName: string
    recordId: string
    action: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    action: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    action: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    changes?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type EmployeePerformanceListRelationFilter = {
    every?: EmployeePerformanceWhereInput
    some?: EmployeePerformanceWhereInput
    none?: EmployeePerformanceWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type NotificationRecipientListRelationFilter = {
    every?: NotificationRecipientWhereInput
    some?: NotificationRecipientWhereInput
    none?: NotificationRecipientWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmployeePerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    refreshToken?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpires?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    refreshToken?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpires?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    refreshToken?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationExpires?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    emailVerified?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumWorkScheduleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkScheduleType | EnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkScheduleTypeFilter<$PrismaModel> | $Enums.WorkScheduleType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTrafficLightNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLightNullableFilter<$PrismaModel> | $Enums.TrafficLight | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type PositionNullableScalarRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeQualificationListRelationFilter = {
    every?: EmployeeQualificationWhereInput
    some?: EmployeeQualificationWhereInput
    none?: EmployeeQualificationWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type AbsenceListRelationFilter = {
    every?: AbsenceWhereInput
    some?: AbsenceWhereInput
    none?: AbsenceWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type WorkStatisticListRelationFilter = {
    every?: WorkStatisticWhereInput
    some?: WorkStatisticWhereInput
    none?: WorkStatisticWhereInput
  }

  export type OrderAssignmentListRelationFilter = {
    every?: OrderAssignmentWhereInput
    some?: OrderAssignmentWhereInput
    none?: OrderAssignmentWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type EmployeeQualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbsenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkStatisticOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    emergencyContact?: SortOrder
    hireDate?: SortOrder
    terminationDate?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    managerId?: SortOrder
    scheduleType?: SortOrder
    hourlyRate?: SortOrder
    salary?: SortOrder
    isAvailable?: SortOrder
    priority?: SortOrder
    blockedAt?: SortOrder
    blockedReason?: SortOrder
    performanceScore?: SortOrder
    trafficLight?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
    salary?: SortOrder
    priority?: SortOrder
    performanceScore?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    hireDate?: SortOrder
    terminationDate?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    managerId?: SortOrder
    scheduleType?: SortOrder
    hourlyRate?: SortOrder
    salary?: SortOrder
    isAvailable?: SortOrder
    priority?: SortOrder
    blockedAt?: SortOrder
    blockedReason?: SortOrder
    performanceScore?: SortOrder
    trafficLight?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    dateOfBirth?: SortOrder
    address?: SortOrder
    hireDate?: SortOrder
    terminationDate?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    managerId?: SortOrder
    scheduleType?: SortOrder
    hourlyRate?: SortOrder
    salary?: SortOrder
    isAvailable?: SortOrder
    priority?: SortOrder
    blockedAt?: SortOrder
    blockedReason?: SortOrder
    performanceScore?: SortOrder
    trafficLight?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
    salary?: SortOrder
    priority?: SortOrder
    performanceScore?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumWorkScheduleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkScheduleType | EnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkScheduleTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkScheduleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkScheduleTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkScheduleTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumTrafficLightNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLightNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrafficLight | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrafficLightNullableFilter<$PrismaModel>
    _max?: NestedEnumTrafficLightNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumTrafficLightFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    not?: NestedEnumTrafficLightFilter<$PrismaModel> | $Enums.TrafficLight
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type EmployeePerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    score?: SortOrder
    trafficLight?: SortOrder
    trafficLightReason?: SortOrder
    metrics?: SortOrder
    manualOverride?: SortOrder
    manualOverrideById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeePerformanceAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EmployeePerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    score?: SortOrder
    trafficLight?: SortOrder
    trafficLightReason?: SortOrder
    manualOverride?: SortOrder
    manualOverrideById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeePerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    score?: SortOrder
    trafficLight?: SortOrder
    trafficLightReason?: SortOrder
    manualOverride?: SortOrder
    manualOverrideById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeePerformanceSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumTrafficLightWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    not?: NestedEnumTrafficLightWithAggregatesFilter<$PrismaModel> | $Enums.TrafficLight
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrafficLightFilter<$PrismaModel>
    _max?: NestedEnumTrafficLightFilter<$PrismaModel>
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type PerformanceThresholdCountOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceThresholdAvgOrderByAggregateInput = {
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
  }

  export type PerformanceThresholdMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceThresholdMinOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceThresholdSumOrderByAggregateInput = {
    redMin?: SortOrder
    redMax?: SortOrder
    yellowMin?: SortOrder
    yellowMax?: SortOrder
    greenMin?: SortOrder
    greenMax?: SortOrder
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type PositionListRelationFilter = {
    every?: PositionWhereInput
    some?: PositionWhereInput
    none?: PositionWhereInput
  }

  export type PerformanceThresholdNullableScalarRelationFilter = {
    is?: PerformanceThresholdWhereInput | null
    isNot?: PerformanceThresholdWhereInput | null
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionTitleDepartmentIdCompoundUniqueInput = {
    title: string
    departmentId: string
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    level?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    level?: SortOrder
    minSalary?: SortOrder
    maxSalary?: SortOrder
  }

  export type SubAccountListRelationFilter = {
    every?: SubAccountWhereInput
    some?: SubAccountWhereInput
    none?: SubAccountWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SubAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    industry?: SortOrder
    taxNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    industry?: SortOrder
    taxNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    isActive?: SortOrder
    industry?: SortOrder
    taxNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SubAccountCustomerIdNameCompoundUniqueInput = {
    customerId: string
    name: string
  }

  export type SubAccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubAccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type OrderQualificationListRelationFilter = {
    every?: OrderQualificationWhereInput
    some?: OrderQualificationWhereInput
    none?: OrderQualificationWhereInput
  }

  export type OrderQualificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
    specialInstructions?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    duration?: SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
    specialInstructions?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
    specialInstructions?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    duration?: SortOrder
    requiredEmployees?: SortOrder
    priority?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type QualificationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresCertificate?: SortOrder
    expiryMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualificationAvgOrderByAggregateInput = {
    expiryMonths?: SortOrder
  }

  export type QualificationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresCertificate?: SortOrder
    expiryMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualificationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresCertificate?: SortOrder
    expiryMonths?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualificationSumOrderByAggregateInput = {
    expiryMonths?: SortOrder
  }

  export type QualificationScalarRelationFilter = {
    is?: QualificationWhereInput
    isNot?: QualificationWhereInput
  }

  export type EmployeeQualificationEmployeeIdQualificationIdCompoundUniqueInput = {
    employeeId: string
    qualificationId: string
  }

  export type EmployeeQualificationCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    qualificationId?: SortOrder
    acquiredDate?: SortOrder
    expiryDate?: SortOrder
    certificateUrl?: SortOrder
    isVerified?: SortOrder
    proficiencyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeQualificationAvgOrderByAggregateInput = {
    proficiencyLevel?: SortOrder
  }

  export type EmployeeQualificationMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    qualificationId?: SortOrder
    acquiredDate?: SortOrder
    expiryDate?: SortOrder
    certificateUrl?: SortOrder
    isVerified?: SortOrder
    proficiencyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeQualificationMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    qualificationId?: SortOrder
    acquiredDate?: SortOrder
    expiryDate?: SortOrder
    certificateUrl?: SortOrder
    isVerified?: SortOrder
    proficiencyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeQualificationSumOrderByAggregateInput = {
    proficiencyLevel?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderQualificationOrderIdQualificationIdCompoundUniqueInput = {
    orderId: string
    qualificationId: string
  }

  export type OrderQualificationCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    qualificationId?: SortOrder
    required?: SortOrder
    minProficiency?: SortOrder
  }

  export type OrderQualificationAvgOrderByAggregateInput = {
    minProficiency?: SortOrder
  }

  export type OrderQualificationMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    qualificationId?: SortOrder
    required?: SortOrder
    minProficiency?: SortOrder
  }

  export type OrderQualificationMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    qualificationId?: SortOrder
    required?: SortOrder
    minProficiency?: SortOrder
  }

  export type OrderQualificationSumOrderByAggregateInput = {
    minProficiency?: SortOrder
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type EnumAssignmentTierFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentTier | EnumAssignmentTierFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTierFilter<$PrismaModel> | $Enums.AssignmentTier
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    assignedDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    estimatedHours?: SortOrder
    actualHours?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    assignedDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    assignedDate?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    estimatedHours?: SortOrder
    actualHours?: SortOrder
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type EnumAssignmentTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentTier | EnumAssignmentTierFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTierWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentTierFilter<$PrismaModel>
    _max?: NestedEnumAssignmentTierFilter<$PrismaModel>
  }

  export type OrderAssignmentOrderIdEmployeeIdCompoundUniqueInput = {
    orderId: string
    employeeId: string
  }

  export type OrderAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    role?: SortOrder
    hourlyRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAssignmentAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
  }

  export type OrderAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    role?: SortOrder
    hourlyRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    role?: SortOrder
    hourlyRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAssignmentSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
  }

  export type EnumAbsenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AbsenceType | EnumAbsenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAbsenceTypeFilter<$PrismaModel> | $Enums.AbsenceType
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AbsenceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedBy?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AbsenceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedBy?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AbsenceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedBy?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAbsenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbsenceType | EnumAbsenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAbsenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AbsenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbsenceTypeFilter<$PrismaModel>
    _max?: NestedEnumAbsenceTypeFilter<$PrismaModel>
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type EnumRatingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatus | EnumRatingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusFilter<$PrismaModel> | $Enums.RatingStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    status?: SortOrder
    ratedBy?: SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    status?: SortOrder
    ratedBy?: SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    customerId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    category?: SortOrder
    status?: SortOrder
    ratedBy?: SortOrder
    ratingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumRatingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatus | EnumRatingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RatingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRatingStatusFilter<$PrismaModel>
    _max?: NestedEnumRatingStatusFilter<$PrismaModel>
  }

  export type WorkStatisticEmployeeIdDateCompoundUniqueInput = {
    employeeId: string
    date: Date | string
  }

  export type WorkStatisticCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    location?: SortOrder
    projects?: SortOrder
    efficiency?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkStatisticAvgOrderByAggregateInput = {
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    efficiency?: SortOrder
    qualityScore?: SortOrder
  }

  export type WorkStatisticMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    location?: SortOrder
    efficiency?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkStatisticMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    employeeId?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    location?: SortOrder
    efficiency?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkStatisticSumOrderByAggregateInput = {
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    efficiency?: SortOrder
    qualityScore?: SortOrder
  }

  export type NotificationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    body?: SortOrder
    defaultChannels?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    title?: SortOrder
    body?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationOutboxListRelationFilter = {
    every?: NotificationOutboxWhereInput
    some?: NotificationOutboxWhereInput
    none?: NotificationOutboxWhereInput
  }

  export type NotificationOutboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    templateKey?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    category?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deliveredAt?: SortOrder
    status?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    templateKey?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deliveredAt?: SortOrder
    status?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    templateKey?: SortOrder
    title?: SortOrder
    body?: SortOrder
    category?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deliveredAt?: SortOrder
    status?: SortOrder
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    channels?: SortOrder
    readAt?: SortOrder
    seenAt?: SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    seenAt?: SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    seenAt?: SortOrder
    isArchived?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationNullableScalarRelationFilter = {
    is?: NotificationWhereInput | null
    isNot?: NotificationWhereInput | null
  }

  export type NotificationOutboxCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    payload?: SortOrder
    channel?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationOutboxAvgOrderByAggregateInput = {
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type NotificationOutboxMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationOutboxMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    channel?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationOutboxSumOrderByAggregateInput = {
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channels?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    digestEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceAvgOrderByAggregateInput = {
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    digestEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    digestEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceSumOrderByAggregateInput = {
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type AssignmentNullableScalarRelationFilter = {
    is?: AssignmentWhereInput | null
    isNot?: AssignmentWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    documentType?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    employeeId?: SortOrder
    orderId?: SortOrder
    assignmentId?: SortOrder
    uploadedBy?: SortOrder
    isVerified?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    documentType?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    employeeId?: SortOrder
    orderId?: SortOrder
    assignmentId?: SortOrder
    uploadedBy?: SortOrder
    isVerified?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    path?: SortOrder
    documentType?: SortOrder
    description?: SortOrder
    expiryDate?: SortOrder
    employeeId?: SortOrder
    orderId?: SortOrder
    assignmentId?: SortOrder
    uploadedBy?: SortOrder
    isVerified?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    changes?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeePerformanceCreateNestedManyWithoutManualOverrideByInput = {
    create?: XOR<EmployeePerformanceCreateWithoutManualOverrideByInput, EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput> | EmployeePerformanceCreateWithoutManualOverrideByInput[] | EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput | EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput[]
    createMany?: EmployeePerformanceCreateManyManualOverrideByInputEnvelope
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type NotificationRecipientCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationRecipientCreateWithoutUserInput, NotificationRecipientUncheckedCreateWithoutUserInput> | NotificationRecipientCreateWithoutUserInput[] | NotificationRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutUserInput | NotificationRecipientCreateOrConnectWithoutUserInput[]
    createMany?: NotificationRecipientCreateManyUserInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeePerformanceUncheckedCreateNestedManyWithoutManualOverrideByInput = {
    create?: XOR<EmployeePerformanceCreateWithoutManualOverrideByInput, EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput> | EmployeePerformanceCreateWithoutManualOverrideByInput[] | EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput | EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput[]
    createMany?: EmployeePerformanceCreateManyManualOverrideByInputEnvelope
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type NotificationRecipientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationRecipientCreateWithoutUserInput, NotificationRecipientUncheckedCreateWithoutUserInput> | NotificationRecipientCreateWithoutUserInput[] | NotificationRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutUserInput | NotificationRecipientCreateOrConnectWithoutUserInput[]
    createMany?: NotificationRecipientCreateManyUserInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeePerformanceUpdateManyWithoutManualOverrideByNestedInput = {
    create?: XOR<EmployeePerformanceCreateWithoutManualOverrideByInput, EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput> | EmployeePerformanceCreateWithoutManualOverrideByInput[] | EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput | EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput[]
    upsert?: EmployeePerformanceUpsertWithWhereUniqueWithoutManualOverrideByInput | EmployeePerformanceUpsertWithWhereUniqueWithoutManualOverrideByInput[]
    createMany?: EmployeePerformanceCreateManyManualOverrideByInputEnvelope
    set?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    disconnect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    delete?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    update?: EmployeePerformanceUpdateWithWhereUniqueWithoutManualOverrideByInput | EmployeePerformanceUpdateWithWhereUniqueWithoutManualOverrideByInput[]
    updateMany?: EmployeePerformanceUpdateManyWithWhereWithoutManualOverrideByInput | EmployeePerformanceUpdateManyWithWhereWithoutManualOverrideByInput[]
    deleteMany?: EmployeePerformanceScalarWhereInput | EmployeePerformanceScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutManagerInput | EmployeeUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutManagerInput | EmployeeUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutManagerInput | EmployeeUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type NotificationRecipientUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutUserInput, NotificationRecipientUncheckedCreateWithoutUserInput> | NotificationRecipientCreateWithoutUserInput[] | NotificationRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutUserInput | NotificationRecipientCreateOrConnectWithoutUserInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutUserInput | NotificationRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationRecipientCreateManyUserInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutUserInput | NotificationRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutUserInput | NotificationRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByNestedInput = {
    create?: XOR<EmployeePerformanceCreateWithoutManualOverrideByInput, EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput> | EmployeePerformanceCreateWithoutManualOverrideByInput[] | EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput | EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput[]
    upsert?: EmployeePerformanceUpsertWithWhereUniqueWithoutManualOverrideByInput | EmployeePerformanceUpsertWithWhereUniqueWithoutManualOverrideByInput[]
    createMany?: EmployeePerformanceCreateManyManualOverrideByInputEnvelope
    set?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    disconnect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    delete?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    update?: EmployeePerformanceUpdateWithWhereUniqueWithoutManualOverrideByInput | EmployeePerformanceUpdateWithWhereUniqueWithoutManualOverrideByInput[]
    updateMany?: EmployeePerformanceUpdateManyWithWhereWithoutManualOverrideByInput | EmployeePerformanceUpdateManyWithWhereWithoutManualOverrideByInput[]
    deleteMany?: EmployeePerformanceScalarWhereInput | EmployeePerformanceScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutManagerInput | EmployeeUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutManagerInput | EmployeeUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutManagerInput | EmployeeUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutUserInput, NotificationRecipientUncheckedCreateWithoutUserInput> | NotificationRecipientCreateWithoutUserInput[] | NotificationRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutUserInput | NotificationRecipientCreateOrConnectWithoutUserInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutUserInput | NotificationRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationRecipientCreateManyUserInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutUserInput | NotificationRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutUserInput | NotificationRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmployeesInput
    connect?: PositionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeePerformanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeePerformanceCreateWithoutEmployeeInput, EmployeePerformanceUncheckedCreateWithoutEmployeeInput> | EmployeePerformanceCreateWithoutEmployeeInput[] | EmployeePerformanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutEmployeeInput | EmployeePerformanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeePerformanceCreateManyEmployeeInputEnvelope
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeQualificationCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeQualificationCreateWithoutEmployeeInput, EmployeeQualificationUncheckedCreateWithoutEmployeeInput> | EmployeeQualificationCreateWithoutEmployeeInput[] | EmployeeQualificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutEmployeeInput | EmployeeQualificationCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeQualificationCreateManyEmployeeInputEnvelope
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AssignmentCreateWithoutEmployeeInput, AssignmentUncheckedCreateWithoutEmployeeInput> | AssignmentCreateWithoutEmployeeInput[] | AssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEmployeeInput | AssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: AssignmentCreateManyEmployeeInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type AbsenceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AbsenceCreateWithoutEmployeeInput, AbsenceUncheckedCreateWithoutEmployeeInput> | AbsenceCreateWithoutEmployeeInput[] | AbsenceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeeInput | AbsenceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AbsenceCreateManyEmployeeInputEnvelope
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<RatingCreateWithoutEmployeeInput, RatingUncheckedCreateWithoutEmployeeInput> | RatingCreateWithoutEmployeeInput[] | RatingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutEmployeeInput | RatingCreateOrConnectWithoutEmployeeInput[]
    createMany?: RatingCreateManyEmployeeInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type WorkStatisticCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkStatisticCreateWithoutEmployeeInput, WorkStatisticUncheckedCreateWithoutEmployeeInput> | WorkStatisticCreateWithoutEmployeeInput[] | WorkStatisticUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkStatisticCreateOrConnectWithoutEmployeeInput | WorkStatisticCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkStatisticCreateManyEmployeeInputEnvelope
    connect?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
  }

  export type OrderAssignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OrderAssignmentCreateWithoutEmployeeInput, OrderAssignmentUncheckedCreateWithoutEmployeeInput> | OrderAssignmentCreateWithoutEmployeeInput[] | OrderAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutEmployeeInput | OrderAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: OrderAssignmentCreateManyEmployeeInputEnvelope
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<FileCreateWithoutEmployeeInput, FileUncheckedCreateWithoutEmployeeInput> | FileCreateWithoutEmployeeInput[] | FileUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FileCreateOrConnectWithoutEmployeeInput | FileCreateOrConnectWithoutEmployeeInput[]
    createMany?: FileCreateManyEmployeeInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeePerformanceCreateWithoutEmployeeInput, EmployeePerformanceUncheckedCreateWithoutEmployeeInput> | EmployeePerformanceCreateWithoutEmployeeInput[] | EmployeePerformanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutEmployeeInput | EmployeePerformanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeePerformanceCreateManyEmployeeInputEnvelope
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
  }

  export type EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeQualificationCreateWithoutEmployeeInput, EmployeeQualificationUncheckedCreateWithoutEmployeeInput> | EmployeeQualificationCreateWithoutEmployeeInput[] | EmployeeQualificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutEmployeeInput | EmployeeQualificationCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeQualificationCreateManyEmployeeInputEnvelope
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AssignmentCreateWithoutEmployeeInput, AssignmentUncheckedCreateWithoutEmployeeInput> | AssignmentCreateWithoutEmployeeInput[] | AssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEmployeeInput | AssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: AssignmentCreateManyEmployeeInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type AbsenceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AbsenceCreateWithoutEmployeeInput, AbsenceUncheckedCreateWithoutEmployeeInput> | AbsenceCreateWithoutEmployeeInput[] | AbsenceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeeInput | AbsenceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AbsenceCreateManyEmployeeInputEnvelope
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<RatingCreateWithoutEmployeeInput, RatingUncheckedCreateWithoutEmployeeInput> | RatingCreateWithoutEmployeeInput[] | RatingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutEmployeeInput | RatingCreateOrConnectWithoutEmployeeInput[]
    createMany?: RatingCreateManyEmployeeInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<WorkStatisticCreateWithoutEmployeeInput, WorkStatisticUncheckedCreateWithoutEmployeeInput> | WorkStatisticCreateWithoutEmployeeInput[] | WorkStatisticUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkStatisticCreateOrConnectWithoutEmployeeInput | WorkStatisticCreateOrConnectWithoutEmployeeInput[]
    createMany?: WorkStatisticCreateManyEmployeeInputEnvelope
    connect?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
  }

  export type OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OrderAssignmentCreateWithoutEmployeeInput, OrderAssignmentUncheckedCreateWithoutEmployeeInput> | OrderAssignmentCreateWithoutEmployeeInput[] | OrderAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutEmployeeInput | OrderAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: OrderAssignmentCreateManyEmployeeInputEnvelope
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<FileCreateWithoutEmployeeInput, FileUncheckedCreateWithoutEmployeeInput> | FileCreateWithoutEmployeeInput[] | FileUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FileCreateOrConnectWithoutEmployeeInput | FileCreateOrConnectWithoutEmployeeInput[]
    createMany?: FileCreateManyEmployeeInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EnumWorkScheduleTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkScheduleType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTrafficLightFieldUpdateOperationsInput = {
    set?: $Enums.TrafficLight | null
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmployeesInput
    upsert?: PositionUpsertWithoutEmployeesInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutEmployeesInput, PositionUpdateWithoutEmployeesInput>, PositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubordinatesInput
    upsert?: UserUpsertWithoutSubordinatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubordinatesInput, UserUpdateWithoutSubordinatesInput>, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type EmployeePerformanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeePerformanceCreateWithoutEmployeeInput, EmployeePerformanceUncheckedCreateWithoutEmployeeInput> | EmployeePerformanceCreateWithoutEmployeeInput[] | EmployeePerformanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutEmployeeInput | EmployeePerformanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeePerformanceUpsertWithWhereUniqueWithoutEmployeeInput | EmployeePerformanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeePerformanceCreateManyEmployeeInputEnvelope
    set?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    disconnect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    delete?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    update?: EmployeePerformanceUpdateWithWhereUniqueWithoutEmployeeInput | EmployeePerformanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeePerformanceUpdateManyWithWhereWithoutEmployeeInput | EmployeePerformanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeePerformanceScalarWhereInput | EmployeePerformanceScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeQualificationUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeQualificationCreateWithoutEmployeeInput, EmployeeQualificationUncheckedCreateWithoutEmployeeInput> | EmployeeQualificationCreateWithoutEmployeeInput[] | EmployeeQualificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutEmployeeInput | EmployeeQualificationCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeQualificationUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeQualificationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeQualificationCreateManyEmployeeInputEnvelope
    set?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    disconnect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    delete?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    update?: EmployeeQualificationUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeQualificationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeQualificationUpdateManyWithWhereWithoutEmployeeInput | EmployeeQualificationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeQualificationScalarWhereInput | EmployeeQualificationScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AssignmentCreateWithoutEmployeeInput, AssignmentUncheckedCreateWithoutEmployeeInput> | AssignmentCreateWithoutEmployeeInput[] | AssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEmployeeInput | AssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutEmployeeInput | AssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AssignmentCreateManyEmployeeInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutEmployeeInput | AssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutEmployeeInput | AssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type AbsenceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AbsenceCreateWithoutEmployeeInput, AbsenceUncheckedCreateWithoutEmployeeInput> | AbsenceCreateWithoutEmployeeInput[] | AbsenceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeeInput | AbsenceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AbsenceUpsertWithWhereUniqueWithoutEmployeeInput | AbsenceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AbsenceCreateManyEmployeeInputEnvelope
    set?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    disconnect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    delete?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    update?: AbsenceUpdateWithWhereUniqueWithoutEmployeeInput | AbsenceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AbsenceUpdateManyWithWhereWithoutEmployeeInput | AbsenceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<RatingCreateWithoutEmployeeInput, RatingUncheckedCreateWithoutEmployeeInput> | RatingCreateWithoutEmployeeInput[] | RatingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutEmployeeInput | RatingCreateOrConnectWithoutEmployeeInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutEmployeeInput | RatingUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: RatingCreateManyEmployeeInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutEmployeeInput | RatingUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutEmployeeInput | RatingUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type WorkStatisticUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkStatisticCreateWithoutEmployeeInput, WorkStatisticUncheckedCreateWithoutEmployeeInput> | WorkStatisticCreateWithoutEmployeeInput[] | WorkStatisticUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkStatisticCreateOrConnectWithoutEmployeeInput | WorkStatisticCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkStatisticUpsertWithWhereUniqueWithoutEmployeeInput | WorkStatisticUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkStatisticCreateManyEmployeeInputEnvelope
    set?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    disconnect?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    delete?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    connect?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    update?: WorkStatisticUpdateWithWhereUniqueWithoutEmployeeInput | WorkStatisticUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkStatisticUpdateManyWithWhereWithoutEmployeeInput | WorkStatisticUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkStatisticScalarWhereInput | WorkStatisticScalarWhereInput[]
  }

  export type OrderAssignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OrderAssignmentCreateWithoutEmployeeInput, OrderAssignmentUncheckedCreateWithoutEmployeeInput> | OrderAssignmentCreateWithoutEmployeeInput[] | OrderAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutEmployeeInput | OrderAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: OrderAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | OrderAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OrderAssignmentCreateManyEmployeeInputEnvelope
    set?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    disconnect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    delete?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    update?: OrderAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | OrderAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OrderAssignmentUpdateManyWithWhereWithoutEmployeeInput | OrderAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OrderAssignmentScalarWhereInput | OrderAssignmentScalarWhereInput[]
  }

  export type FileUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<FileCreateWithoutEmployeeInput, FileUncheckedCreateWithoutEmployeeInput> | FileCreateWithoutEmployeeInput[] | FileUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FileCreateOrConnectWithoutEmployeeInput | FileCreateOrConnectWithoutEmployeeInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutEmployeeInput | FileUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: FileCreateManyEmployeeInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutEmployeeInput | FileUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: FileUpdateManyWithWhereWithoutEmployeeInput | FileUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeePerformanceCreateWithoutEmployeeInput, EmployeePerformanceUncheckedCreateWithoutEmployeeInput> | EmployeePerformanceCreateWithoutEmployeeInput[] | EmployeePerformanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeePerformanceCreateOrConnectWithoutEmployeeInput | EmployeePerformanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeePerformanceUpsertWithWhereUniqueWithoutEmployeeInput | EmployeePerformanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeePerformanceCreateManyEmployeeInputEnvelope
    set?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    disconnect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    delete?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    connect?: EmployeePerformanceWhereUniqueInput | EmployeePerformanceWhereUniqueInput[]
    update?: EmployeePerformanceUpdateWithWhereUniqueWithoutEmployeeInput | EmployeePerformanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeePerformanceUpdateManyWithWhereWithoutEmployeeInput | EmployeePerformanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeePerformanceScalarWhereInput | EmployeePerformanceScalarWhereInput[]
  }

  export type EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeQualificationCreateWithoutEmployeeInput, EmployeeQualificationUncheckedCreateWithoutEmployeeInput> | EmployeeQualificationCreateWithoutEmployeeInput[] | EmployeeQualificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutEmployeeInput | EmployeeQualificationCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeQualificationUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeQualificationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeQualificationCreateManyEmployeeInputEnvelope
    set?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    disconnect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    delete?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    update?: EmployeeQualificationUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeQualificationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeQualificationUpdateManyWithWhereWithoutEmployeeInput | EmployeeQualificationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeQualificationScalarWhereInput | EmployeeQualificationScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AssignmentCreateWithoutEmployeeInput, AssignmentUncheckedCreateWithoutEmployeeInput> | AssignmentCreateWithoutEmployeeInput[] | AssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutEmployeeInput | AssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutEmployeeInput | AssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AssignmentCreateManyEmployeeInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutEmployeeInput | AssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutEmployeeInput | AssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AbsenceCreateWithoutEmployeeInput, AbsenceUncheckedCreateWithoutEmployeeInput> | AbsenceCreateWithoutEmployeeInput[] | AbsenceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeeInput | AbsenceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AbsenceUpsertWithWhereUniqueWithoutEmployeeInput | AbsenceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AbsenceCreateManyEmployeeInputEnvelope
    set?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    disconnect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    delete?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    update?: AbsenceUpdateWithWhereUniqueWithoutEmployeeInput | AbsenceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AbsenceUpdateManyWithWhereWithoutEmployeeInput | AbsenceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<RatingCreateWithoutEmployeeInput, RatingUncheckedCreateWithoutEmployeeInput> | RatingCreateWithoutEmployeeInput[] | RatingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutEmployeeInput | RatingCreateOrConnectWithoutEmployeeInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutEmployeeInput | RatingUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: RatingCreateManyEmployeeInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutEmployeeInput | RatingUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutEmployeeInput | RatingUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<WorkStatisticCreateWithoutEmployeeInput, WorkStatisticUncheckedCreateWithoutEmployeeInput> | WorkStatisticCreateWithoutEmployeeInput[] | WorkStatisticUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: WorkStatisticCreateOrConnectWithoutEmployeeInput | WorkStatisticCreateOrConnectWithoutEmployeeInput[]
    upsert?: WorkStatisticUpsertWithWhereUniqueWithoutEmployeeInput | WorkStatisticUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: WorkStatisticCreateManyEmployeeInputEnvelope
    set?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    disconnect?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    delete?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    connect?: WorkStatisticWhereUniqueInput | WorkStatisticWhereUniqueInput[]
    update?: WorkStatisticUpdateWithWhereUniqueWithoutEmployeeInput | WorkStatisticUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: WorkStatisticUpdateManyWithWhereWithoutEmployeeInput | WorkStatisticUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: WorkStatisticScalarWhereInput | WorkStatisticScalarWhereInput[]
  }

  export type OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OrderAssignmentCreateWithoutEmployeeInput, OrderAssignmentUncheckedCreateWithoutEmployeeInput> | OrderAssignmentCreateWithoutEmployeeInput[] | OrderAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutEmployeeInput | OrderAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: OrderAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | OrderAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OrderAssignmentCreateManyEmployeeInputEnvelope
    set?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    disconnect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    delete?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    update?: OrderAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | OrderAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OrderAssignmentUpdateManyWithWhereWithoutEmployeeInput | OrderAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OrderAssignmentScalarWhereInput | OrderAssignmentScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<FileCreateWithoutEmployeeInput, FileUncheckedCreateWithoutEmployeeInput> | FileCreateWithoutEmployeeInput[] | FileUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: FileCreateOrConnectWithoutEmployeeInput | FileCreateOrConnectWithoutEmployeeInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutEmployeeInput | FileUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: FileCreateManyEmployeeInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutEmployeeInput | FileUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: FileUpdateManyWithWhereWithoutEmployeeInput | FileUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutPerformanceRecordsInput = {
    create?: XOR<EmployeeCreateWithoutPerformanceRecordsInput, EmployeeUncheckedCreateWithoutPerformanceRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPerformanceRecordsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManualOverridesInput = {
    create?: XOR<UserCreateWithoutManualOverridesInput, UserUncheckedCreateWithoutManualOverridesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManualOverridesInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumTrafficLightFieldUpdateOperationsInput = {
    set?: $Enums.TrafficLight
  }

  export type EmployeeUpdateOneRequiredWithoutPerformanceRecordsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPerformanceRecordsInput, EmployeeUncheckedCreateWithoutPerformanceRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPerformanceRecordsInput
    upsert?: EmployeeUpsertWithoutPerformanceRecordsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPerformanceRecordsInput, EmployeeUpdateWithoutPerformanceRecordsInput>, EmployeeUncheckedUpdateWithoutPerformanceRecordsInput>
  }

  export type UserUpdateOneWithoutManualOverridesNestedInput = {
    create?: XOR<UserCreateWithoutManualOverridesInput, UserUncheckedCreateWithoutManualOverridesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManualOverridesInput
    upsert?: UserUpsertWithoutManualOverridesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManualOverridesInput, UserUpdateWithoutManualOverridesInput>, UserUncheckedUpdateWithoutManualOverridesInput>
  }

  export type DepartmentCreateNestedOneWithoutPerformanceThresholdInput = {
    create?: XOR<DepartmentCreateWithoutPerformanceThresholdInput, DepartmentUncheckedCreateWithoutPerformanceThresholdInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPerformanceThresholdInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutPerformanceThresholdNestedInput = {
    create?: XOR<DepartmentCreateWithoutPerformanceThresholdInput, DepartmentUncheckedCreateWithoutPerformanceThresholdInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPerformanceThresholdInput
    upsert?: DepartmentUpsertWithoutPerformanceThresholdInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPerformanceThresholdInput, DepartmentUpdateWithoutPerformanceThresholdInput>, DepartmentUncheckedUpdateWithoutPerformanceThresholdInput>
  }

  export type DepartmentCreateNestedOneWithoutChildDepartmentsInput = {
    create?: XOR<DepartmentCreateWithoutChildDepartmentsInput, DepartmentUncheckedCreateWithoutChildDepartmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutChildDepartmentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutParentDepartmentInput = {
    create?: XOR<DepartmentCreateWithoutParentDepartmentInput, DepartmentUncheckedCreateWithoutParentDepartmentInput> | DepartmentCreateWithoutParentDepartmentInput[] | DepartmentUncheckedCreateWithoutParentDepartmentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentDepartmentInput | DepartmentCreateOrConnectWithoutParentDepartmentInput[]
    createMany?: DepartmentCreateManyParentDepartmentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PositionCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type PerformanceThresholdCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<PerformanceThresholdCreateWithoutDepartmentInput, PerformanceThresholdUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: PerformanceThresholdCreateOrConnectWithoutDepartmentInput
    connect?: PerformanceThresholdWhereUniqueInput
  }

  export type DepartmentUncheckedCreateNestedManyWithoutParentDepartmentInput = {
    create?: XOR<DepartmentCreateWithoutParentDepartmentInput, DepartmentUncheckedCreateWithoutParentDepartmentInput> | DepartmentCreateWithoutParentDepartmentInput[] | DepartmentUncheckedCreateWithoutParentDepartmentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentDepartmentInput | DepartmentCreateOrConnectWithoutParentDepartmentInput[]
    createMany?: DepartmentCreateManyParentDepartmentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PositionUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type PerformanceThresholdUncheckedCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<PerformanceThresholdCreateWithoutDepartmentInput, PerformanceThresholdUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: PerformanceThresholdCreateOrConnectWithoutDepartmentInput
    connect?: PerformanceThresholdWhereUniqueInput
  }

  export type DepartmentUpdateOneWithoutChildDepartmentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutChildDepartmentsInput, DepartmentUncheckedCreateWithoutChildDepartmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutChildDepartmentsInput
    upsert?: DepartmentUpsertWithoutChildDepartmentsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutChildDepartmentsInput, DepartmentUpdateWithoutChildDepartmentsInput>, DepartmentUncheckedUpdateWithoutChildDepartmentsInput>
  }

  export type DepartmentUpdateManyWithoutParentDepartmentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentDepartmentInput, DepartmentUncheckedCreateWithoutParentDepartmentInput> | DepartmentCreateWithoutParentDepartmentInput[] | DepartmentUncheckedCreateWithoutParentDepartmentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentDepartmentInput | DepartmentCreateOrConnectWithoutParentDepartmentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentDepartmentInput | DepartmentUpsertWithWhereUniqueWithoutParentDepartmentInput[]
    createMany?: DepartmentCreateManyParentDepartmentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentDepartmentInput | DepartmentUpdateWithWhereUniqueWithoutParentDepartmentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentDepartmentInput | DepartmentUpdateManyWithWhereWithoutParentDepartmentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PositionUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutDepartmentInput | PositionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutDepartmentInput | PositionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutDepartmentInput | PositionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type PerformanceThresholdUpdateOneWithoutDepartmentNestedInput = {
    create?: XOR<PerformanceThresholdCreateWithoutDepartmentInput, PerformanceThresholdUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: PerformanceThresholdCreateOrConnectWithoutDepartmentInput
    upsert?: PerformanceThresholdUpsertWithoutDepartmentInput
    disconnect?: PerformanceThresholdWhereInput | boolean
    delete?: PerformanceThresholdWhereInput | boolean
    connect?: PerformanceThresholdWhereUniqueInput
    update?: XOR<XOR<PerformanceThresholdUpdateToOneWithWhereWithoutDepartmentInput, PerformanceThresholdUpdateWithoutDepartmentInput>, PerformanceThresholdUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentUncheckedUpdateManyWithoutParentDepartmentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentDepartmentInput, DepartmentUncheckedCreateWithoutParentDepartmentInput> | DepartmentCreateWithoutParentDepartmentInput[] | DepartmentUncheckedCreateWithoutParentDepartmentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentDepartmentInput | DepartmentCreateOrConnectWithoutParentDepartmentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentDepartmentInput | DepartmentUpsertWithWhereUniqueWithoutParentDepartmentInput[]
    createMany?: DepartmentCreateManyParentDepartmentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentDepartmentInput | DepartmentUpdateWithWhereUniqueWithoutParentDepartmentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentDepartmentInput | DepartmentUpdateManyWithWhereWithoutParentDepartmentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PositionUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutDepartmentInput | PositionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutDepartmentInput | PositionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutDepartmentInput | PositionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type PerformanceThresholdUncheckedUpdateOneWithoutDepartmentNestedInput = {
    create?: XOR<PerformanceThresholdCreateWithoutDepartmentInput, PerformanceThresholdUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: PerformanceThresholdCreateOrConnectWithoutDepartmentInput
    upsert?: PerformanceThresholdUpsertWithoutDepartmentInput
    disconnect?: PerformanceThresholdWhereInput | boolean
    delete?: PerformanceThresholdWhereInput | boolean
    connect?: PerformanceThresholdWhereUniqueInput
    update?: XOR<XOR<PerformanceThresholdUpdateToOneWithWhereWithoutDepartmentInput, PerformanceThresholdUpdateWithoutDepartmentInput>, PerformanceThresholdUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentCreateNestedOneWithoutPositionsInput = {
    create?: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPositionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutPositionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPositionsInput
    upsert?: DepartmentUpsertWithoutPositionsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPositionsInput, DepartmentUpdateWithoutPositionsInput>, DepartmentUncheckedUpdateWithoutPositionsInput>
  }

  export type EmployeeUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type SubAccountCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubAccountCreateWithoutCustomerInput, SubAccountUncheckedCreateWithoutCustomerInput> | SubAccountCreateWithoutCustomerInput[] | SubAccountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutCustomerInput | SubAccountCreateOrConnectWithoutCustomerInput[]
    createMany?: SubAccountCreateManyCustomerInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RatingCreateWithoutCustomerInput, RatingUncheckedCreateWithoutCustomerInput> | RatingCreateWithoutCustomerInput[] | RatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCustomerInput | RatingCreateOrConnectWithoutCustomerInput[]
    createMany?: RatingCreateManyCustomerInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type SubAccountUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubAccountCreateWithoutCustomerInput, SubAccountUncheckedCreateWithoutCustomerInput> | SubAccountCreateWithoutCustomerInput[] | SubAccountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutCustomerInput | SubAccountCreateOrConnectWithoutCustomerInput[]
    createMany?: SubAccountCreateManyCustomerInputEnvelope
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RatingCreateWithoutCustomerInput, RatingUncheckedCreateWithoutCustomerInput> | RatingCreateWithoutCustomerInput[] | RatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCustomerInput | RatingCreateOrConnectWithoutCustomerInput[]
    createMany?: RatingCreateManyCustomerInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type SubAccountUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubAccountCreateWithoutCustomerInput, SubAccountUncheckedCreateWithoutCustomerInput> | SubAccountCreateWithoutCustomerInput[] | SubAccountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutCustomerInput | SubAccountCreateOrConnectWithoutCustomerInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutCustomerInput | SubAccountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubAccountCreateManyCustomerInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutCustomerInput | SubAccountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutCustomerInput | SubAccountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RatingCreateWithoutCustomerInput, RatingUncheckedCreateWithoutCustomerInput> | RatingCreateWithoutCustomerInput[] | RatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCustomerInput | RatingCreateOrConnectWithoutCustomerInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutCustomerInput | RatingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RatingCreateManyCustomerInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutCustomerInput | RatingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutCustomerInput | RatingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type SubAccountUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubAccountCreateWithoutCustomerInput, SubAccountUncheckedCreateWithoutCustomerInput> | SubAccountCreateWithoutCustomerInput[] | SubAccountUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubAccountCreateOrConnectWithoutCustomerInput | SubAccountCreateOrConnectWithoutCustomerInput[]
    upsert?: SubAccountUpsertWithWhereUniqueWithoutCustomerInput | SubAccountUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubAccountCreateManyCustomerInputEnvelope
    set?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    disconnect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    delete?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    connect?: SubAccountWhereUniqueInput | SubAccountWhereUniqueInput[]
    update?: SubAccountUpdateWithWhereUniqueWithoutCustomerInput | SubAccountUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubAccountUpdateManyWithWhereWithoutCustomerInput | SubAccountUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RatingCreateWithoutCustomerInput, RatingUncheckedCreateWithoutCustomerInput> | RatingCreateWithoutCustomerInput[] | RatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutCustomerInput | RatingCreateOrConnectWithoutCustomerInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutCustomerInput | RatingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RatingCreateManyCustomerInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutCustomerInput | RatingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutCustomerInput | RatingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutSubAccountsInput = {
    create?: XOR<CustomerCreateWithoutSubAccountsInput, CustomerUncheckedCreateWithoutSubAccountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubAccountsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutSubAccountsNestedInput = {
    create?: XOR<CustomerCreateWithoutSubAccountsInput, CustomerUncheckedCreateWithoutSubAccountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubAccountsInput
    upsert?: CustomerUpsertWithoutSubAccountsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubAccountsInput, CustomerUpdateWithoutSubAccountsInput>, CustomerUncheckedUpdateWithoutSubAccountsInput>
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderQualificationCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderQualificationCreateWithoutOrderInput, OrderQualificationUncheckedCreateWithoutOrderInput> | OrderQualificationCreateWithoutOrderInput[] | OrderQualificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutOrderInput | OrderQualificationCreateOrConnectWithoutOrderInput[]
    createMany?: OrderQualificationCreateManyOrderInputEnvelope
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
  }

  export type OrderAssignmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAssignmentCreateWithoutOrderInput, OrderAssignmentUncheckedCreateWithoutOrderInput> | OrderAssignmentCreateWithoutOrderInput[] | OrderAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutOrderInput | OrderAssignmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAssignmentCreateManyOrderInputEnvelope
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<AssignmentCreateWithoutOrderInput, AssignmentUncheckedCreateWithoutOrderInput> | AssignmentCreateWithoutOrderInput[] | AssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutOrderInput | AssignmentCreateOrConnectWithoutOrderInput[]
    createMany?: AssignmentCreateManyOrderInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutOrderInput = {
    create?: XOR<RatingCreateWithoutOrderInput, RatingUncheckedCreateWithoutOrderInput> | RatingCreateWithoutOrderInput[] | RatingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutOrderInput | RatingCreateOrConnectWithoutOrderInput[]
    createMany?: RatingCreateManyOrderInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutOrderInput = {
    create?: XOR<FileCreateWithoutOrderInput, FileUncheckedCreateWithoutOrderInput> | FileCreateWithoutOrderInput[] | FileUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOrderInput | FileCreateOrConnectWithoutOrderInput[]
    createMany?: FileCreateManyOrderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type OrderQualificationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderQualificationCreateWithoutOrderInput, OrderQualificationUncheckedCreateWithoutOrderInput> | OrderQualificationCreateWithoutOrderInput[] | OrderQualificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutOrderInput | OrderQualificationCreateOrConnectWithoutOrderInput[]
    createMany?: OrderQualificationCreateManyOrderInputEnvelope
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
  }

  export type OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderAssignmentCreateWithoutOrderInput, OrderAssignmentUncheckedCreateWithoutOrderInput> | OrderAssignmentCreateWithoutOrderInput[] | OrderAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutOrderInput | OrderAssignmentCreateOrConnectWithoutOrderInput[]
    createMany?: OrderAssignmentCreateManyOrderInputEnvelope
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<AssignmentCreateWithoutOrderInput, AssignmentUncheckedCreateWithoutOrderInput> | AssignmentCreateWithoutOrderInput[] | AssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutOrderInput | AssignmentCreateOrConnectWithoutOrderInput[]
    createMany?: AssignmentCreateManyOrderInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<RatingCreateWithoutOrderInput, RatingUncheckedCreateWithoutOrderInput> | RatingCreateWithoutOrderInput[] | RatingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutOrderInput | RatingCreateOrConnectWithoutOrderInput[]
    createMany?: RatingCreateManyOrderInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<FileCreateWithoutOrderInput, FileUncheckedCreateWithoutOrderInput> | FileCreateWithoutOrderInput[] | FileUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOrderInput | FileCreateOrConnectWithoutOrderInput[]
    createMany?: FileCreateManyOrderInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderQualificationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderQualificationCreateWithoutOrderInput, OrderQualificationUncheckedCreateWithoutOrderInput> | OrderQualificationCreateWithoutOrderInput[] | OrderQualificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutOrderInput | OrderQualificationCreateOrConnectWithoutOrderInput[]
    upsert?: OrderQualificationUpsertWithWhereUniqueWithoutOrderInput | OrderQualificationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderQualificationCreateManyOrderInputEnvelope
    set?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    disconnect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    delete?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    update?: OrderQualificationUpdateWithWhereUniqueWithoutOrderInput | OrderQualificationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderQualificationUpdateManyWithWhereWithoutOrderInput | OrderQualificationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderQualificationScalarWhereInput | OrderQualificationScalarWhereInput[]
  }

  export type OrderAssignmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAssignmentCreateWithoutOrderInput, OrderAssignmentUncheckedCreateWithoutOrderInput> | OrderAssignmentCreateWithoutOrderInput[] | OrderAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutOrderInput | OrderAssignmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAssignmentUpsertWithWhereUniqueWithoutOrderInput | OrderAssignmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAssignmentCreateManyOrderInputEnvelope
    set?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    disconnect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    delete?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    update?: OrderAssignmentUpdateWithWhereUniqueWithoutOrderInput | OrderAssignmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAssignmentUpdateManyWithWhereWithoutOrderInput | OrderAssignmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAssignmentScalarWhereInput | OrderAssignmentScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AssignmentCreateWithoutOrderInput, AssignmentUncheckedCreateWithoutOrderInput> | AssignmentCreateWithoutOrderInput[] | AssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutOrderInput | AssignmentCreateOrConnectWithoutOrderInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutOrderInput | AssignmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AssignmentCreateManyOrderInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutOrderInput | AssignmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutOrderInput | AssignmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RatingCreateWithoutOrderInput, RatingUncheckedCreateWithoutOrderInput> | RatingCreateWithoutOrderInput[] | RatingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutOrderInput | RatingCreateOrConnectWithoutOrderInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutOrderInput | RatingUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RatingCreateManyOrderInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutOrderInput | RatingUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutOrderInput | RatingUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type FileUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FileCreateWithoutOrderInput, FileUncheckedCreateWithoutOrderInput> | FileCreateWithoutOrderInput[] | FileUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOrderInput | FileCreateOrConnectWithoutOrderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutOrderInput | FileUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FileCreateManyOrderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutOrderInput | FileUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutOrderInput | FileUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderQualificationCreateWithoutOrderInput, OrderQualificationUncheckedCreateWithoutOrderInput> | OrderQualificationCreateWithoutOrderInput[] | OrderQualificationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutOrderInput | OrderQualificationCreateOrConnectWithoutOrderInput[]
    upsert?: OrderQualificationUpsertWithWhereUniqueWithoutOrderInput | OrderQualificationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderQualificationCreateManyOrderInputEnvelope
    set?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    disconnect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    delete?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    update?: OrderQualificationUpdateWithWhereUniqueWithoutOrderInput | OrderQualificationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderQualificationUpdateManyWithWhereWithoutOrderInput | OrderQualificationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderQualificationScalarWhereInput | OrderQualificationScalarWhereInput[]
  }

  export type OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderAssignmentCreateWithoutOrderInput, OrderAssignmentUncheckedCreateWithoutOrderInput> | OrderAssignmentCreateWithoutOrderInput[] | OrderAssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderAssignmentCreateOrConnectWithoutOrderInput | OrderAssignmentCreateOrConnectWithoutOrderInput[]
    upsert?: OrderAssignmentUpsertWithWhereUniqueWithoutOrderInput | OrderAssignmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderAssignmentCreateManyOrderInputEnvelope
    set?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    disconnect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    delete?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    connect?: OrderAssignmentWhereUniqueInput | OrderAssignmentWhereUniqueInput[]
    update?: OrderAssignmentUpdateWithWhereUniqueWithoutOrderInput | OrderAssignmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderAssignmentUpdateManyWithWhereWithoutOrderInput | OrderAssignmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderAssignmentScalarWhereInput | OrderAssignmentScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<AssignmentCreateWithoutOrderInput, AssignmentUncheckedCreateWithoutOrderInput> | AssignmentCreateWithoutOrderInput[] | AssignmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutOrderInput | AssignmentCreateOrConnectWithoutOrderInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutOrderInput | AssignmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: AssignmentCreateManyOrderInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutOrderInput | AssignmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutOrderInput | AssignmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RatingCreateWithoutOrderInput, RatingUncheckedCreateWithoutOrderInput> | RatingCreateWithoutOrderInput[] | RatingUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutOrderInput | RatingCreateOrConnectWithoutOrderInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutOrderInput | RatingUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RatingCreateManyOrderInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutOrderInput | RatingUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutOrderInput | RatingUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<FileCreateWithoutOrderInput, FileUncheckedCreateWithoutOrderInput> | FileCreateWithoutOrderInput[] | FileUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOrderInput | FileCreateOrConnectWithoutOrderInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutOrderInput | FileUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: FileCreateManyOrderInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutOrderInput | FileUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: FileUpdateManyWithWhereWithoutOrderInput | FileUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type EmployeeQualificationCreateNestedManyWithoutQualificationInput = {
    create?: XOR<EmployeeQualificationCreateWithoutQualificationInput, EmployeeQualificationUncheckedCreateWithoutQualificationInput> | EmployeeQualificationCreateWithoutQualificationInput[] | EmployeeQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutQualificationInput | EmployeeQualificationCreateOrConnectWithoutQualificationInput[]
    createMany?: EmployeeQualificationCreateManyQualificationInputEnvelope
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
  }

  export type OrderQualificationCreateNestedManyWithoutQualificationInput = {
    create?: XOR<OrderQualificationCreateWithoutQualificationInput, OrderQualificationUncheckedCreateWithoutQualificationInput> | OrderQualificationCreateWithoutQualificationInput[] | OrderQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutQualificationInput | OrderQualificationCreateOrConnectWithoutQualificationInput[]
    createMany?: OrderQualificationCreateManyQualificationInputEnvelope
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
  }

  export type EmployeeQualificationUncheckedCreateNestedManyWithoutQualificationInput = {
    create?: XOR<EmployeeQualificationCreateWithoutQualificationInput, EmployeeQualificationUncheckedCreateWithoutQualificationInput> | EmployeeQualificationCreateWithoutQualificationInput[] | EmployeeQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutQualificationInput | EmployeeQualificationCreateOrConnectWithoutQualificationInput[]
    createMany?: EmployeeQualificationCreateManyQualificationInputEnvelope
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
  }

  export type OrderQualificationUncheckedCreateNestedManyWithoutQualificationInput = {
    create?: XOR<OrderQualificationCreateWithoutQualificationInput, OrderQualificationUncheckedCreateWithoutQualificationInput> | OrderQualificationCreateWithoutQualificationInput[] | OrderQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutQualificationInput | OrderQualificationCreateOrConnectWithoutQualificationInput[]
    createMany?: OrderQualificationCreateManyQualificationInputEnvelope
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
  }

  export type EmployeeQualificationUpdateManyWithoutQualificationNestedInput = {
    create?: XOR<EmployeeQualificationCreateWithoutQualificationInput, EmployeeQualificationUncheckedCreateWithoutQualificationInput> | EmployeeQualificationCreateWithoutQualificationInput[] | EmployeeQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutQualificationInput | EmployeeQualificationCreateOrConnectWithoutQualificationInput[]
    upsert?: EmployeeQualificationUpsertWithWhereUniqueWithoutQualificationInput | EmployeeQualificationUpsertWithWhereUniqueWithoutQualificationInput[]
    createMany?: EmployeeQualificationCreateManyQualificationInputEnvelope
    set?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    disconnect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    delete?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    update?: EmployeeQualificationUpdateWithWhereUniqueWithoutQualificationInput | EmployeeQualificationUpdateWithWhereUniqueWithoutQualificationInput[]
    updateMany?: EmployeeQualificationUpdateManyWithWhereWithoutQualificationInput | EmployeeQualificationUpdateManyWithWhereWithoutQualificationInput[]
    deleteMany?: EmployeeQualificationScalarWhereInput | EmployeeQualificationScalarWhereInput[]
  }

  export type OrderQualificationUpdateManyWithoutQualificationNestedInput = {
    create?: XOR<OrderQualificationCreateWithoutQualificationInput, OrderQualificationUncheckedCreateWithoutQualificationInput> | OrderQualificationCreateWithoutQualificationInput[] | OrderQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutQualificationInput | OrderQualificationCreateOrConnectWithoutQualificationInput[]
    upsert?: OrderQualificationUpsertWithWhereUniqueWithoutQualificationInput | OrderQualificationUpsertWithWhereUniqueWithoutQualificationInput[]
    createMany?: OrderQualificationCreateManyQualificationInputEnvelope
    set?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    disconnect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    delete?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    update?: OrderQualificationUpdateWithWhereUniqueWithoutQualificationInput | OrderQualificationUpdateWithWhereUniqueWithoutQualificationInput[]
    updateMany?: OrderQualificationUpdateManyWithWhereWithoutQualificationInput | OrderQualificationUpdateManyWithWhereWithoutQualificationInput[]
    deleteMany?: OrderQualificationScalarWhereInput | OrderQualificationScalarWhereInput[]
  }

  export type EmployeeQualificationUncheckedUpdateManyWithoutQualificationNestedInput = {
    create?: XOR<EmployeeQualificationCreateWithoutQualificationInput, EmployeeQualificationUncheckedCreateWithoutQualificationInput> | EmployeeQualificationCreateWithoutQualificationInput[] | EmployeeQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: EmployeeQualificationCreateOrConnectWithoutQualificationInput | EmployeeQualificationCreateOrConnectWithoutQualificationInput[]
    upsert?: EmployeeQualificationUpsertWithWhereUniqueWithoutQualificationInput | EmployeeQualificationUpsertWithWhereUniqueWithoutQualificationInput[]
    createMany?: EmployeeQualificationCreateManyQualificationInputEnvelope
    set?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    disconnect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    delete?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    connect?: EmployeeQualificationWhereUniqueInput | EmployeeQualificationWhereUniqueInput[]
    update?: EmployeeQualificationUpdateWithWhereUniqueWithoutQualificationInput | EmployeeQualificationUpdateWithWhereUniqueWithoutQualificationInput[]
    updateMany?: EmployeeQualificationUpdateManyWithWhereWithoutQualificationInput | EmployeeQualificationUpdateManyWithWhereWithoutQualificationInput[]
    deleteMany?: EmployeeQualificationScalarWhereInput | EmployeeQualificationScalarWhereInput[]
  }

  export type OrderQualificationUncheckedUpdateManyWithoutQualificationNestedInput = {
    create?: XOR<OrderQualificationCreateWithoutQualificationInput, OrderQualificationUncheckedCreateWithoutQualificationInput> | OrderQualificationCreateWithoutQualificationInput[] | OrderQualificationUncheckedCreateWithoutQualificationInput[]
    connectOrCreate?: OrderQualificationCreateOrConnectWithoutQualificationInput | OrderQualificationCreateOrConnectWithoutQualificationInput[]
    upsert?: OrderQualificationUpsertWithWhereUniqueWithoutQualificationInput | OrderQualificationUpsertWithWhereUniqueWithoutQualificationInput[]
    createMany?: OrderQualificationCreateManyQualificationInputEnvelope
    set?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    disconnect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    delete?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    connect?: OrderQualificationWhereUniqueInput | OrderQualificationWhereUniqueInput[]
    update?: OrderQualificationUpdateWithWhereUniqueWithoutQualificationInput | OrderQualificationUpdateWithWhereUniqueWithoutQualificationInput[]
    updateMany?: OrderQualificationUpdateManyWithWhereWithoutQualificationInput | OrderQualificationUpdateManyWithWhereWithoutQualificationInput[]
    deleteMany?: OrderQualificationScalarWhereInput | OrderQualificationScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutQualificationsInput = {
    create?: XOR<EmployeeCreateWithoutQualificationsInput, EmployeeUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutQualificationsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type QualificationCreateNestedOneWithoutEmployeeQualificationsInput = {
    create?: XOR<QualificationCreateWithoutEmployeeQualificationsInput, QualificationUncheckedCreateWithoutEmployeeQualificationsInput>
    connectOrCreate?: QualificationCreateOrConnectWithoutEmployeeQualificationsInput
    connect?: QualificationWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutQualificationsNestedInput = {
    create?: XOR<EmployeeCreateWithoutQualificationsInput, EmployeeUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutQualificationsInput
    upsert?: EmployeeUpsertWithoutQualificationsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutQualificationsInput, EmployeeUpdateWithoutQualificationsInput>, EmployeeUncheckedUpdateWithoutQualificationsInput>
  }

  export type QualificationUpdateOneRequiredWithoutEmployeeQualificationsNestedInput = {
    create?: XOR<QualificationCreateWithoutEmployeeQualificationsInput, QualificationUncheckedCreateWithoutEmployeeQualificationsInput>
    connectOrCreate?: QualificationCreateOrConnectWithoutEmployeeQualificationsInput
    upsert?: QualificationUpsertWithoutEmployeeQualificationsInput
    connect?: QualificationWhereUniqueInput
    update?: XOR<XOR<QualificationUpdateToOneWithWhereWithoutEmployeeQualificationsInput, QualificationUpdateWithoutEmployeeQualificationsInput>, QualificationUncheckedUpdateWithoutEmployeeQualificationsInput>
  }

  export type OrderCreateNestedOneWithoutQualificationsInput = {
    create?: XOR<OrderCreateWithoutQualificationsInput, OrderUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutQualificationsInput
    connect?: OrderWhereUniqueInput
  }

  export type QualificationCreateNestedOneWithoutOrderQualificationsInput = {
    create?: XOR<QualificationCreateWithoutOrderQualificationsInput, QualificationUncheckedCreateWithoutOrderQualificationsInput>
    connectOrCreate?: QualificationCreateOrConnectWithoutOrderQualificationsInput
    connect?: QualificationWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutQualificationsNestedInput = {
    create?: XOR<OrderCreateWithoutQualificationsInput, OrderUncheckedCreateWithoutQualificationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutQualificationsInput
    upsert?: OrderUpsertWithoutQualificationsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutQualificationsInput, OrderUpdateWithoutQualificationsInput>, OrderUncheckedUpdateWithoutQualificationsInput>
  }

  export type QualificationUpdateOneRequiredWithoutOrderQualificationsNestedInput = {
    create?: XOR<QualificationCreateWithoutOrderQualificationsInput, QualificationUncheckedCreateWithoutOrderQualificationsInput>
    connectOrCreate?: QualificationCreateOrConnectWithoutOrderQualificationsInput
    upsert?: QualificationUpsertWithoutOrderQualificationsInput
    connect?: QualificationWhereUniqueInput
    update?: XOR<XOR<QualificationUpdateToOneWithWhereWithoutOrderQualificationsInput, QualificationUpdateWithoutOrderQualificationsInput>, QualificationUncheckedUpdateWithoutOrderQualificationsInput>
  }

  export type OrderCreateNestedOneWithoutEmployeeAssignmentsInput = {
    create?: XOR<OrderCreateWithoutEmployeeAssignmentsInput, OrderUncheckedCreateWithoutEmployeeAssignmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutEmployeeAssignmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutAssignmentsInput, EmployeeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<FileCreateWithoutAssignmentInput, FileUncheckedCreateWithoutAssignmentInput> | FileCreateWithoutAssignmentInput[] | FileUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssignmentInput | FileCreateOrConnectWithoutAssignmentInput[]
    createMany?: FileCreateManyAssignmentInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<FileCreateWithoutAssignmentInput, FileUncheckedCreateWithoutAssignmentInput> | FileCreateWithoutAssignmentInput[] | FileUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssignmentInput | FileCreateOrConnectWithoutAssignmentInput[]
    createMany?: FileCreateManyAssignmentInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type EnumAssignmentTierFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentTier
  }

  export type OrderUpdateOneWithoutEmployeeAssignmentsNestedInput = {
    create?: XOR<OrderCreateWithoutEmployeeAssignmentsInput, OrderUncheckedCreateWithoutEmployeeAssignmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutEmployeeAssignmentsInput
    upsert?: OrderUpsertWithoutEmployeeAssignmentsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutEmployeeAssignmentsInput, OrderUpdateWithoutEmployeeAssignmentsInput>, OrderUncheckedUpdateWithoutEmployeeAssignmentsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAssignmentsInput, EmployeeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAssignmentsInput
    upsert?: EmployeeUpsertWithoutAssignmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAssignmentsInput, EmployeeUpdateWithoutAssignmentsInput>, EmployeeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type FileUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<FileCreateWithoutAssignmentInput, FileUncheckedCreateWithoutAssignmentInput> | FileCreateWithoutAssignmentInput[] | FileUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssignmentInput | FileCreateOrConnectWithoutAssignmentInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAssignmentInput | FileUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: FileCreateManyAssignmentInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAssignmentInput | FileUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAssignmentInput | FileUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<FileCreateWithoutAssignmentInput, FileUncheckedCreateWithoutAssignmentInput> | FileCreateWithoutAssignmentInput[] | FileUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAssignmentInput | FileCreateOrConnectWithoutAssignmentInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAssignmentInput | FileUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: FileCreateManyAssignmentInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAssignmentInput | FileUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAssignmentInput | FileUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderAssignmentsInput = {
    create?: XOR<OrderCreateWithoutOrderAssignmentsInput, OrderUncheckedCreateWithoutOrderAssignmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderAssignmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutOrderAssignmentsInput = {
    create?: XOR<EmployeeCreateWithoutOrderAssignmentsInput, EmployeeUncheckedCreateWithoutOrderAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrderAssignmentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderAssignmentsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderAssignmentsInput, OrderUncheckedCreateWithoutOrderAssignmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderAssignmentsInput
    upsert?: OrderUpsertWithoutOrderAssignmentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderAssignmentsInput, OrderUpdateWithoutOrderAssignmentsInput>, OrderUncheckedUpdateWithoutOrderAssignmentsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutOrderAssignmentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutOrderAssignmentsInput, EmployeeUncheckedCreateWithoutOrderAssignmentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrderAssignmentsInput
    upsert?: EmployeeUpsertWithoutOrderAssignmentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutOrderAssignmentsInput, EmployeeUpdateWithoutOrderAssignmentsInput>, EmployeeUncheckedUpdateWithoutOrderAssignmentsInput>
  }

  export type AbsenceCreatedocumentUrlsInput = {
    set: string[]
  }

  export type EmployeeCreateNestedOneWithoutAbsencesInput = {
    create?: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAbsencesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumAbsenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AbsenceType
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type AbsenceUpdatedocumentUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmployeeUpdateOneRequiredWithoutAbsencesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAbsencesInput
    upsert?: EmployeeUpsertWithoutAbsencesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAbsencesInput, EmployeeUpdateWithoutAbsencesInput>, EmployeeUncheckedUpdateWithoutAbsencesInput>
  }

  export type OrderCreateNestedOneWithoutRatingsInput = {
    create?: XOR<OrderCreateWithoutRatingsInput, OrderUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRatingsInput
    connect?: OrderWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutRatingsInput = {
    create?: XOR<EmployeeCreateWithoutRatingsInput, EmployeeUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRatingsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutRatingsInput = {
    create?: XOR<CustomerCreateWithoutRatingsInput, CustomerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRatingsInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumRatingStatusFieldUpdateOperationsInput = {
    set?: $Enums.RatingStatus
  }

  export type OrderUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<OrderCreateWithoutRatingsInput, OrderUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRatingsInput
    upsert?: OrderUpsertWithoutRatingsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutRatingsInput, OrderUpdateWithoutRatingsInput>, OrderUncheckedUpdateWithoutRatingsInput>
  }

  export type EmployeeUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<EmployeeCreateWithoutRatingsInput, EmployeeUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutRatingsInput
    upsert?: EmployeeUpsertWithoutRatingsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutRatingsInput, EmployeeUpdateWithoutRatingsInput>, EmployeeUncheckedUpdateWithoutRatingsInput>
  }

  export type CustomerUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<CustomerCreateWithoutRatingsInput, CustomerUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRatingsInput
    upsert?: CustomerUpsertWithoutRatingsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRatingsInput, CustomerUpdateWithoutRatingsInput>, CustomerUncheckedUpdateWithoutRatingsInput>
  }

  export type WorkStatisticCreateprojectsInput = {
    set: string[]
  }

  export type EmployeeCreateNestedOneWithoutWorkStatisticsInput = {
    create?: XOR<EmployeeCreateWithoutWorkStatisticsInput, EmployeeUncheckedCreateWithoutWorkStatisticsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkStatisticsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type WorkStatisticUpdateprojectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmployeeUpdateOneRequiredWithoutWorkStatisticsNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkStatisticsInput, EmployeeUncheckedCreateWithoutWorkStatisticsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkStatisticsInput
    upsert?: EmployeeUpsertWithoutWorkStatisticsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutWorkStatisticsInput, EmployeeUpdateWithoutWorkStatisticsInput>, EmployeeUncheckedUpdateWithoutWorkStatisticsInput>
  }

  export type NotificationTemplateCreatedefaultChannelsInput = {
    set: string[]
  }

  export type NotificationTemplateUpdatedefaultChannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationRecipientCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type NotificationOutboxCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationOutboxCreateWithoutNotificationInput, NotificationOutboxUncheckedCreateWithoutNotificationInput> | NotificationOutboxCreateWithoutNotificationInput[] | NotificationOutboxUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationOutboxCreateOrConnectWithoutNotificationInput | NotificationOutboxCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationOutboxCreateManyNotificationInputEnvelope
    connect?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
  }

  export type NotificationRecipientUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type NotificationOutboxUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationOutboxCreateWithoutNotificationInput, NotificationOutboxUncheckedCreateWithoutNotificationInput> | NotificationOutboxCreateWithoutNotificationInput[] | NotificationOutboxUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationOutboxCreateOrConnectWithoutNotificationInput | NotificationOutboxCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationOutboxCreateManyNotificationInputEnvelope
    connect?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
  }

  export type NotificationRecipientUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutNotificationInput | NotificationRecipientUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type NotificationOutboxUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationOutboxCreateWithoutNotificationInput, NotificationOutboxUncheckedCreateWithoutNotificationInput> | NotificationOutboxCreateWithoutNotificationInput[] | NotificationOutboxUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationOutboxCreateOrConnectWithoutNotificationInput | NotificationOutboxCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationOutboxUpsertWithWhereUniqueWithoutNotificationInput | NotificationOutboxUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationOutboxCreateManyNotificationInputEnvelope
    set?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    disconnect?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    delete?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    connect?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    update?: NotificationOutboxUpdateWithWhereUniqueWithoutNotificationInput | NotificationOutboxUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationOutboxUpdateManyWithWhereWithoutNotificationInput | NotificationOutboxUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationOutboxScalarWhereInput | NotificationOutboxScalarWhereInput[]
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutNotificationInput | NotificationRecipientUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type NotificationOutboxUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationOutboxCreateWithoutNotificationInput, NotificationOutboxUncheckedCreateWithoutNotificationInput> | NotificationOutboxCreateWithoutNotificationInput[] | NotificationOutboxUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationOutboxCreateOrConnectWithoutNotificationInput | NotificationOutboxCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationOutboxUpsertWithWhereUniqueWithoutNotificationInput | NotificationOutboxUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationOutboxCreateManyNotificationInputEnvelope
    set?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    disconnect?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    delete?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    connect?: NotificationOutboxWhereUniqueInput | NotificationOutboxWhereUniqueInput[]
    update?: NotificationOutboxUpdateWithWhereUniqueWithoutNotificationInput | NotificationOutboxUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationOutboxUpdateManyWithWhereWithoutNotificationInput | NotificationOutboxUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationOutboxScalarWhereInput | NotificationOutboxScalarWhereInput[]
  }

  export type NotificationRecipientCreatechannelsInput = {
    set: string[]
  }

  export type NotificationCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationRecipientsInput = {
    create?: XOR<UserCreateWithoutNotificationRecipientsInput, UserUncheckedCreateWithoutNotificationRecipientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationRecipientsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationRecipientUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientsInput
    upsert?: NotificationUpsertWithoutRecipientsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutRecipientsInput, NotificationUpdateWithoutRecipientsInput>, NotificationUncheckedUpdateWithoutRecipientsInput>
  }

  export type UserUpdateOneWithoutNotificationRecipientsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationRecipientsInput, UserUncheckedCreateWithoutNotificationRecipientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationRecipientsInput
    upsert?: UserUpsertWithoutNotificationRecipientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationRecipientsInput, UserUpdateWithoutNotificationRecipientsInput>, UserUncheckedUpdateWithoutNotificationRecipientsInput>
  }

  export type NotificationCreateNestedOneWithoutNotificationOutboxInput = {
    create?: XOR<NotificationCreateWithoutNotificationOutboxInput, NotificationUncheckedCreateWithoutNotificationOutboxInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutNotificationOutboxInput
    connect?: NotificationWhereUniqueInput
  }

  export type NotificationUpdateOneWithoutNotificationOutboxNestedInput = {
    create?: XOR<NotificationCreateWithoutNotificationOutboxInput, NotificationUncheckedCreateWithoutNotificationOutboxInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutNotificationOutboxInput
    upsert?: NotificationUpsertWithoutNotificationOutboxInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutNotificationOutboxInput, NotificationUpdateWithoutNotificationOutboxInput>, NotificationUncheckedUpdateWithoutNotificationOutboxInput>
  }

  export type NotificationPreferenceCreatechannelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationPreferenceUpdatechannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: UserUpsertWithoutNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferencesInput, UserUpdateWithoutNotificationPreferencesInput>, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type EmployeeCreateNestedOneWithoutFilesInput = {
    create?: XOR<EmployeeCreateWithoutFilesInput, EmployeeUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFilesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutFilesInput = {
    create?: XOR<OrderCreateWithoutFilesInput, OrderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutFilesInput
    connect?: OrderWhereUniqueInput
  }

  export type AssignmentCreateNestedOneWithoutFilesInput = {
    create?: XOR<AssignmentCreateWithoutFilesInput, AssignmentUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutFilesInput
    connect?: AssignmentWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EmployeeUpdateOneWithoutFilesNestedInput = {
    create?: XOR<EmployeeCreateWithoutFilesInput, EmployeeUncheckedCreateWithoutFilesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFilesInput
    upsert?: EmployeeUpsertWithoutFilesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutFilesInput, EmployeeUpdateWithoutFilesInput>, EmployeeUncheckedUpdateWithoutFilesInput>
  }

  export type OrderUpdateOneWithoutFilesNestedInput = {
    create?: XOR<OrderCreateWithoutFilesInput, OrderUncheckedCreateWithoutFilesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutFilesInput
    upsert?: OrderUpsertWithoutFilesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutFilesInput, OrderUpdateWithoutFilesInput>, OrderUncheckedUpdateWithoutFilesInput>
  }

  export type AssignmentUpdateOneWithoutFilesNestedInput = {
    create?: XOR<AssignmentCreateWithoutFilesInput, AssignmentUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutFilesInput
    upsert?: AssignmentUpsertWithoutFilesInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutFilesInput, AssignmentUpdateWithoutFilesInput>, AssignmentUncheckedUpdateWithoutFilesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumWorkScheduleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkScheduleType | EnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkScheduleTypeFilter<$PrismaModel> | $Enums.WorkScheduleType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumTrafficLightNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLightNullableFilter<$PrismaModel> | $Enums.TrafficLight | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumWorkScheduleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkScheduleType | EnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkScheduleType[] | ListEnumWorkScheduleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkScheduleTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkScheduleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkScheduleTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkScheduleTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTrafficLightNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLightNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrafficLight | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrafficLightNullableFilter<$PrismaModel>
    _max?: NestedEnumTrafficLightNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumTrafficLightFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    not?: NestedEnumTrafficLightFilter<$PrismaModel> | $Enums.TrafficLight
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTrafficLightWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLight | EnumTrafficLightFieldRefInput<$PrismaModel>
    in?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrafficLight[] | ListEnumTrafficLightFieldRefInput<$PrismaModel>
    not?: NestedEnumTrafficLightWithAggregatesFilter<$PrismaModel> | $Enums.TrafficLight
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrafficLightFilter<$PrismaModel>
    _max?: NestedEnumTrafficLightFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedEnumAssignmentTierFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentTier | EnumAssignmentTierFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTierFilter<$PrismaModel> | $Enums.AssignmentTier
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentTier | EnumAssignmentTierFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentTier[] | ListEnumAssignmentTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTierWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentTierFilter<$PrismaModel>
    _max?: NestedEnumAssignmentTierFilter<$PrismaModel>
  }

  export type NestedEnumAbsenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AbsenceType | EnumAbsenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAbsenceTypeFilter<$PrismaModel> | $Enums.AbsenceType
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumAbsenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbsenceType | EnumAbsenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AbsenceType[] | ListEnumAbsenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAbsenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.AbsenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbsenceTypeFilter<$PrismaModel>
    _max?: NestedEnumAbsenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumRatingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatus | EnumRatingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusFilter<$PrismaModel> | $Enums.RatingStatus
  }

  export type NestedEnumRatingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RatingStatus | EnumRatingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RatingStatus[] | ListEnumRatingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRatingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RatingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRatingStatusFilter<$PrismaModel>
    _max?: NestedEnumRatingStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeePerformanceCreateWithoutManualOverrideByInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPerformanceRecordsInput
  }

  export type EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput = {
    id?: string
    employeeId: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePerformanceCreateOrConnectWithoutManualOverrideByInput = {
    where: EmployeePerformanceWhereUniqueInput
    create: XOR<EmployeePerformanceCreateWithoutManualOverrideByInput, EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput>
  }

  export type EmployeePerformanceCreateManyManualOverrideByInputEnvelope = {
    data: EmployeePerformanceCreateManyManualOverrideByInput | EmployeePerformanceCreateManyManualOverrideByInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutManagerInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutManagerInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeCreateManyManagerInputEnvelope = {
    data: EmployeeCreateManyManagerInput | EmployeeCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationRecipientCreateWithoutUserInput = {
    id?: string
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
    notification: NotificationCreateNestedOneWithoutRecipientsInput
  }

  export type NotificationRecipientUncheckedCreateWithoutUserInput = {
    id?: string
    notificationId: string
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationRecipientCreateOrConnectWithoutUserInput = {
    where: NotificationRecipientWhereUniqueInput
    create: XOR<NotificationRecipientCreateWithoutUserInput, NotificationRecipientUncheckedCreateWithoutUserInput>
  }

  export type NotificationRecipientCreateManyUserInputEnvelope = {
    data: NotificationRecipientCreateManyUserInput | NotificationRecipientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    channels?: NotificationPreferenceCreatechannelsInput | string[]
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    digestEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    channels?: NotificationPreferenceCreatechannelsInput | string[]
    quietHoursStart?: number | null
    quietHoursEnd?: number | null
    digestEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeePerformanceUpsertWithWhereUniqueWithoutManualOverrideByInput = {
    where: EmployeePerformanceWhereUniqueInput
    update: XOR<EmployeePerformanceUpdateWithoutManualOverrideByInput, EmployeePerformanceUncheckedUpdateWithoutManualOverrideByInput>
    create: XOR<EmployeePerformanceCreateWithoutManualOverrideByInput, EmployeePerformanceUncheckedCreateWithoutManualOverrideByInput>
  }

  export type EmployeePerformanceUpdateWithWhereUniqueWithoutManualOverrideByInput = {
    where: EmployeePerformanceWhereUniqueInput
    data: XOR<EmployeePerformanceUpdateWithoutManualOverrideByInput, EmployeePerformanceUncheckedUpdateWithoutManualOverrideByInput>
  }

  export type EmployeePerformanceUpdateManyWithWhereWithoutManualOverrideByInput = {
    where: EmployeePerformanceScalarWhereInput
    data: XOR<EmployeePerformanceUpdateManyMutationInput, EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByInput>
  }

  export type EmployeePerformanceScalarWhereInput = {
    AND?: EmployeePerformanceScalarWhereInput | EmployeePerformanceScalarWhereInput[]
    OR?: EmployeePerformanceScalarWhereInput[]
    NOT?: EmployeePerformanceScalarWhereInput | EmployeePerformanceScalarWhereInput[]
    id?: StringFilter<"EmployeePerformance"> | string
    employeeId?: StringFilter<"EmployeePerformance"> | string
    periodStart?: DateTimeFilter<"EmployeePerformance"> | Date | string
    periodEnd?: DateTimeFilter<"EmployeePerformance"> | Date | string
    score?: DecimalFilter<"EmployeePerformance"> | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFilter<"EmployeePerformance"> | $Enums.TrafficLight
    trafficLightReason?: StringNullableFilter<"EmployeePerformance"> | string | null
    metrics?: JsonNullableFilter<"EmployeePerformance">
    manualOverride?: BoolFilter<"EmployeePerformance"> | boolean
    manualOverrideById?: StringNullableFilter<"EmployeePerformance"> | string | null
    createdAt?: DateTimeFilter<"EmployeePerformance"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePerformance"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutManagerInput, EmployeeUncheckedUpdateWithoutManagerInput>
    create: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutManagerInput, EmployeeUncheckedUpdateWithoutManagerInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutManagerInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutManagerInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeCode?: StringFilter<"Employee"> | string
    firstName?: StringNullableFilter<"Employee"> | string | null
    lastName?: StringNullableFilter<"Employee"> | string | null
    phoneNumber?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: JsonNullableFilter<"Employee">
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    terminationDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    scheduleType?: EnumWorkScheduleTypeFilter<"Employee"> | $Enums.WorkScheduleType
    hourlyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFilter<"Employee"> | boolean
    priority?: IntFilter<"Employee"> | number
    blockedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    blockedReason?: StringNullableFilter<"Employee"> | string | null
    performanceScore?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    trafficLight?: EnumTrafficLightNullableFilter<"Employee"> | $Enums.TrafficLight | null
    userId?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    createdBy?: StringNullableFilter<"Employee"> | string | null
    updatedBy?: StringNullableFilter<"Employee"> | string | null
  }

  export type NotificationRecipientUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationRecipientWhereUniqueInput
    update: XOR<NotificationRecipientUpdateWithoutUserInput, NotificationRecipientUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationRecipientCreateWithoutUserInput, NotificationRecipientUncheckedCreateWithoutUserInput>
  }

  export type NotificationRecipientUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationRecipientWhereUniqueInput
    data: XOR<NotificationRecipientUpdateWithoutUserInput, NotificationRecipientUncheckedUpdateWithoutUserInput>
  }

  export type NotificationRecipientUpdateManyWithWhereWithoutUserInput = {
    where: NotificationRecipientScalarWhereInput
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationRecipientScalarWhereInput = {
    AND?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
    OR?: NotificationRecipientScalarWhereInput[]
    NOT?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
    id?: StringFilter<"NotificationRecipient"> | string
    notificationId?: StringFilter<"NotificationRecipient"> | string
    userId?: StringNullableFilter<"NotificationRecipient"> | string | null
    channels?: StringNullableListFilter<"NotificationRecipient">
    readAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    seenAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    isArchived?: BoolFilter<"NotificationRecipient"> | boolean
    status?: StringFilter<"NotificationRecipient"> | string
    error?: StringNullableFilter<"NotificationRecipient"> | string | null
    createdAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationPreferenceUpdatechannelsInput | string[]
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationPreferenceUpdatechannelsInput | string[]
    quietHoursStart?: NullableIntFieldUpdateOperationsInput | number | null
    quietHoursEnd?: NullableIntFieldUpdateOperationsInput | number | null
    digestEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentDepartment?: DepartmentCreateNestedOneWithoutChildDepartmentsInput
    childDepartments?: DepartmentCreateNestedManyWithoutParentDepartmentInput
    positions?: PositionCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentDepartmentInput
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type PositionCreateWithoutEmployeesInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPositionsInput
  }

  export type PositionUncheckedCreateWithoutEmployeesInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    departmentId: string
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateOrConnectWithoutEmployeesInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutSubordinatesInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceCreateNestedManyWithoutManualOverrideByInput
    notificationRecipients?: NotificationRecipientCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceUncheckedCreateNestedManyWithoutManualOverrideByInput
    notificationRecipients?: NotificationRecipientUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubordinatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
  }

  export type EmployeePerformanceCreateWithoutEmployeeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    manualOverrideBy?: UserCreateNestedOneWithoutManualOverridesInput
  }

  export type EmployeePerformanceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    manualOverrideById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePerformanceCreateOrConnectWithoutEmployeeInput = {
    where: EmployeePerformanceWhereUniqueInput
    create: XOR<EmployeePerformanceCreateWithoutEmployeeInput, EmployeePerformanceUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeePerformanceCreateManyEmployeeInputEnvelope = {
    data: EmployeePerformanceCreateManyEmployeeInput | EmployeePerformanceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    manualOverrides?: EmployeePerformanceCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    manualOverrides?: EmployeePerformanceUncheckedCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeQualificationCreateWithoutEmployeeInput = {
    id?: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    qualification: QualificationCreateNestedOneWithoutEmployeeQualificationsInput
  }

  export type EmployeeQualificationUncheckedCreateWithoutEmployeeInput = {
    id?: string
    qualificationId: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeQualificationCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeQualificationWhereUniqueInput
    create: XOR<EmployeeQualificationCreateWithoutEmployeeInput, EmployeeQualificationUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeQualificationCreateManyEmployeeInputEnvelope = {
    data: EmployeeQualificationCreateManyEmployeeInput | EmployeeQualificationCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutEmployeeInput = {
    id?: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    order?: OrderCreateNestedOneWithoutEmployeeAssignmentsInput
    files?: FileCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    orderId?: string | null
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    files?: FileUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutEmployeeInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutEmployeeInput, AssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type AssignmentCreateManyEmployeeInputEnvelope = {
    data: AssignmentCreateManyEmployeeInput | AssignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AbsenceCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.AbsenceType
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.RequestStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    documentUrls?: AbsenceCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AbsenceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    type: $Enums.AbsenceType
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.RequestStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    documentUrls?: AbsenceCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AbsenceCreateOrConnectWithoutEmployeeInput = {
    where: AbsenceWhereUniqueInput
    create: XOR<AbsenceCreateWithoutEmployeeInput, AbsenceUncheckedCreateWithoutEmployeeInput>
  }

  export type AbsenceCreateManyEmployeeInputEnvelope = {
    data: AbsenceCreateManyEmployeeInput | AbsenceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutEmployeeInput = {
    id?: string
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutRatingsInput
    customer?: CustomerCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutEmployeeInput = {
    id?: string
    orderId?: string | null
    customerId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutEmployeeInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutEmployeeInput, RatingUncheckedCreateWithoutEmployeeInput>
  }

  export type RatingCreateManyEmployeeInputEnvelope = {
    data: RatingCreateManyEmployeeInput | RatingCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type WorkStatisticCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    hoursWorked: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    location?: string | null
    projects?: WorkStatisticCreateprojectsInput | string[]
    efficiency?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkStatisticUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    hoursWorked: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    location?: string | null
    projects?: WorkStatisticCreateprojectsInput | string[]
    efficiency?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkStatisticCreateOrConnectWithoutEmployeeInput = {
    where: WorkStatisticWhereUniqueInput
    create: XOR<WorkStatisticCreateWithoutEmployeeInput, WorkStatisticUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkStatisticCreateManyEmployeeInputEnvelope = {
    data: WorkStatisticCreateManyEmployeeInput | WorkStatisticCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type OrderAssignmentCreateWithoutEmployeeInput = {
    id?: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderAssignmentsInput
  }

  export type OrderAssignmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    orderId: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAssignmentCreateOrConnectWithoutEmployeeInput = {
    where: OrderAssignmentWhereUniqueInput
    create: XOR<OrderAssignmentCreateWithoutEmployeeInput, OrderAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type OrderAssignmentCreateManyEmployeeInputEnvelope = {
    data: OrderAssignmentCreateManyEmployeeInput | OrderAssignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutEmployeeInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutFilesInput
    assignment?: AssignmentCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutEmployeeInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    orderId?: string | null
    assignmentId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutEmployeeInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutEmployeeInput, FileUncheckedCreateWithoutEmployeeInput>
  }

  export type FileCreateManyEmployeeInputEnvelope = {
    data: FileCreateManyEmployeeInput | FileCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDepartment?: DepartmentUpdateOneWithoutChildDepartmentsNestedInput
    childDepartments?: DepartmentUpdateManyWithoutParentDepartmentNestedInput
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDepartments?: DepartmentUncheckedUpdateManyWithoutParentDepartmentNestedInput
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUncheckedUpdateOneWithoutDepartmentNestedInput
  }

  export type PositionUpsertWithoutEmployeesInput = {
    update: XOR<PositionUpdateWithoutEmployeesInput, PositionUncheckedUpdateWithoutEmployeesInput>
    create: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutEmployeesInput, PositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPositionsNestedInput
  }

  export type PositionUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: StringFieldUpdateOperationsInput | string
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSubordinatesInput = {
    update: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<UserCreateWithoutSubordinatesInput, UserUncheckedCreateWithoutSubordinatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubordinatesInput, UserUncheckedUpdateWithoutSubordinatesInput>
  }

  export type UserUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUpdateManyWithoutManualOverrideByNestedInput
    notificationRecipients?: NotificationRecipientUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByNestedInput
    notificationRecipients?: NotificationRecipientUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EmployeePerformanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeePerformanceWhereUniqueInput
    update: XOR<EmployeePerformanceUpdateWithoutEmployeeInput, EmployeePerformanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeePerformanceCreateWithoutEmployeeInput, EmployeePerformanceUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeePerformanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeePerformanceWhereUniqueInput
    data: XOR<EmployeePerformanceUpdateWithoutEmployeeInput, EmployeePerformanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeePerformanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeePerformanceScalarWhereInput
    data: XOR<EmployeePerformanceUpdateManyMutationInput, EmployeePerformanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: EmployeePerformanceUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    manualOverrides?: EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EmployeeQualificationUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeQualificationWhereUniqueInput
    update: XOR<EmployeeQualificationUpdateWithoutEmployeeInput, EmployeeQualificationUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeQualificationCreateWithoutEmployeeInput, EmployeeQualificationUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeQualificationUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeQualificationWhereUniqueInput
    data: XOR<EmployeeQualificationUpdateWithoutEmployeeInput, EmployeeQualificationUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeQualificationUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeQualificationScalarWhereInput
    data: XOR<EmployeeQualificationUpdateManyMutationInput, EmployeeQualificationUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeQualificationScalarWhereInput = {
    AND?: EmployeeQualificationScalarWhereInput | EmployeeQualificationScalarWhereInput[]
    OR?: EmployeeQualificationScalarWhereInput[]
    NOT?: EmployeeQualificationScalarWhereInput | EmployeeQualificationScalarWhereInput[]
    id?: StringFilter<"EmployeeQualification"> | string
    employeeId?: StringFilter<"EmployeeQualification"> | string
    qualificationId?: StringFilter<"EmployeeQualification"> | string
    acquiredDate?: DateTimeFilter<"EmployeeQualification"> | Date | string
    expiryDate?: DateTimeNullableFilter<"EmployeeQualification"> | Date | string | null
    certificateUrl?: StringNullableFilter<"EmployeeQualification"> | string | null
    isVerified?: BoolFilter<"EmployeeQualification"> | boolean
    proficiencyLevel?: IntFilter<"EmployeeQualification"> | number
    createdAt?: DateTimeFilter<"EmployeeQualification"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeQualification"> | Date | string
  }

  export type AssignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutEmployeeInput, AssignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AssignmentCreateWithoutEmployeeInput, AssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutEmployeeInput, AssignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    orderId?: StringNullableFilter<"Assignment"> | string | null
    employeeId?: StringFilter<"Assignment"> | string
    assignedDate?: DateTimeFilter<"Assignment"> | Date | string
    startDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    status?: EnumAssignmentStatusFilter<"Assignment"> | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFilter<"Assignment"> | $Enums.AssignmentTier
    estimatedHours?: DecimalNullableFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    actualHours?: DecimalNullableFilter<"Assignment"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Assignment"> | string | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    createdBy?: StringNullableFilter<"Assignment"> | string | null
    updatedBy?: StringNullableFilter<"Assignment"> | string | null
  }

  export type AbsenceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AbsenceWhereUniqueInput
    update: XOR<AbsenceUpdateWithoutEmployeeInput, AbsenceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AbsenceCreateWithoutEmployeeInput, AbsenceUncheckedCreateWithoutEmployeeInput>
  }

  export type AbsenceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AbsenceWhereUniqueInput
    data: XOR<AbsenceUpdateWithoutEmployeeInput, AbsenceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AbsenceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AbsenceScalarWhereInput
    data: XOR<AbsenceUpdateManyMutationInput, AbsenceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AbsenceScalarWhereInput = {
    AND?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
    OR?: AbsenceScalarWhereInput[]
    NOT?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
    id?: StringFilter<"Absence"> | string
    employeeId?: StringFilter<"Absence"> | string
    type?: EnumAbsenceTypeFilter<"Absence"> | $Enums.AbsenceType
    startDate?: DateTimeFilter<"Absence"> | Date | string
    endDate?: DateTimeFilter<"Absence"> | Date | string
    reason?: StringNullableFilter<"Absence"> | string | null
    status?: EnumRequestStatusFilter<"Absence"> | $Enums.RequestStatus
    approvedBy?: StringNullableFilter<"Absence"> | string | null
    approvedAt?: DateTimeNullableFilter<"Absence"> | Date | string | null
    rejectedBy?: StringNullableFilter<"Absence"> | string | null
    rejectedAt?: DateTimeNullableFilter<"Absence"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Absence"> | string | null
    documentUrls?: StringNullableListFilter<"Absence">
    createdAt?: DateTimeFilter<"Absence"> | Date | string
    updatedAt?: DateTimeFilter<"Absence"> | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutEmployeeInput, RatingUncheckedUpdateWithoutEmployeeInput>
    create: XOR<RatingCreateWithoutEmployeeInput, RatingUncheckedCreateWithoutEmployeeInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutEmployeeInput, RatingUncheckedUpdateWithoutEmployeeInput>
  }

  export type RatingUpdateManyWithWhereWithoutEmployeeInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: StringFilter<"Rating"> | string
    orderId?: StringNullableFilter<"Rating"> | string | null
    employeeId?: StringNullableFilter<"Rating"> | string | null
    customerId?: StringNullableFilter<"Rating"> | string | null
    rating?: IntFilter<"Rating"> | number
    comment?: StringNullableFilter<"Rating"> | string | null
    category?: StringNullableFilter<"Rating"> | string | null
    status?: EnumRatingStatusFilter<"Rating"> | $Enums.RatingStatus
    ratedBy?: StringNullableFilter<"Rating"> | string | null
    ratingDate?: DateTimeFilter<"Rating"> | Date | string
    createdAt?: DateTimeFilter<"Rating"> | Date | string
    updatedAt?: DateTimeFilter<"Rating"> | Date | string
  }

  export type WorkStatisticUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: WorkStatisticWhereUniqueInput
    update: XOR<WorkStatisticUpdateWithoutEmployeeInput, WorkStatisticUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WorkStatisticCreateWithoutEmployeeInput, WorkStatisticUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkStatisticUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: WorkStatisticWhereUniqueInput
    data: XOR<WorkStatisticUpdateWithoutEmployeeInput, WorkStatisticUncheckedUpdateWithoutEmployeeInput>
  }

  export type WorkStatisticUpdateManyWithWhereWithoutEmployeeInput = {
    where: WorkStatisticScalarWhereInput
    data: XOR<WorkStatisticUpdateManyMutationInput, WorkStatisticUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type WorkStatisticScalarWhereInput = {
    AND?: WorkStatisticScalarWhereInput | WorkStatisticScalarWhereInput[]
    OR?: WorkStatisticScalarWhereInput[]
    NOT?: WorkStatisticScalarWhereInput | WorkStatisticScalarWhereInput[]
    id?: StringFilter<"WorkStatistic"> | string
    date?: DateTimeFilter<"WorkStatistic"> | Date | string
    employeeId?: StringFilter<"WorkStatistic"> | string
    hoursWorked?: DecimalFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string
    location?: StringNullableFilter<"WorkStatistic"> | string | null
    projects?: StringNullableListFilter<"WorkStatistic">
    efficiency?: DecimalNullableFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    qualityScore?: DecimalNullableFilter<"WorkStatistic"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"WorkStatistic"> | Date | string
    updatedAt?: DateTimeFilter<"WorkStatistic"> | Date | string
  }

  export type OrderAssignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: OrderAssignmentWhereUniqueInput
    update: XOR<OrderAssignmentUpdateWithoutEmployeeInput, OrderAssignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OrderAssignmentCreateWithoutEmployeeInput, OrderAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type OrderAssignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: OrderAssignmentWhereUniqueInput
    data: XOR<OrderAssignmentUpdateWithoutEmployeeInput, OrderAssignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type OrderAssignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: OrderAssignmentScalarWhereInput
    data: XOR<OrderAssignmentUpdateManyMutationInput, OrderAssignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type OrderAssignmentScalarWhereInput = {
    AND?: OrderAssignmentScalarWhereInput | OrderAssignmentScalarWhereInput[]
    OR?: OrderAssignmentScalarWhereInput[]
    NOT?: OrderAssignmentScalarWhereInput | OrderAssignmentScalarWhereInput[]
    id?: StringFilter<"OrderAssignment"> | string
    orderId?: StringFilter<"OrderAssignment"> | string
    employeeId?: StringFilter<"OrderAssignment"> | string
    role?: StringNullableFilter<"OrderAssignment"> | string | null
    hourlyRate?: DecimalNullableFilter<"OrderAssignment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OrderAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"OrderAssignment"> | Date | string
  }

  export type FileUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutEmployeeInput, FileUncheckedUpdateWithoutEmployeeInput>
    create: XOR<FileCreateWithoutEmployeeInput, FileUncheckedCreateWithoutEmployeeInput>
  }

  export type FileUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutEmployeeInput, FileUncheckedUpdateWithoutEmployeeInput>
  }

  export type FileUpdateManyWithWhereWithoutEmployeeInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    path?: StringFilter<"File"> | string
    documentType?: EnumDocumentTypeFilter<"File"> | $Enums.DocumentType
    description?: StringNullableFilter<"File"> | string | null
    expiryDate?: DateTimeNullableFilter<"File"> | Date | string | null
    employeeId?: StringNullableFilter<"File"> | string | null
    orderId?: StringNullableFilter<"File"> | string | null
    assignmentId?: StringNullableFilter<"File"> | string | null
    uploadedBy?: StringNullableFilter<"File"> | string | null
    isVerified?: BoolFilter<"File"> | boolean
    isPublic?: BoolFilter<"File"> | boolean
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
  }

  export type EmployeeCreateWithoutPerformanceRecordsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPerformanceRecordsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPerformanceRecordsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPerformanceRecordsInput, EmployeeUncheckedCreateWithoutPerformanceRecordsInput>
  }

  export type UserCreateWithoutManualOverridesInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeCreateNestedOneWithoutUserInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManualOverridesInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientUncheckedCreateNestedManyWithoutUserInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManualOverridesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManualOverridesInput, UserUncheckedCreateWithoutManualOverridesInput>
  }

  export type EmployeeUpsertWithoutPerformanceRecordsInput = {
    update: XOR<EmployeeUpdateWithoutPerformanceRecordsInput, EmployeeUncheckedUpdateWithoutPerformanceRecordsInput>
    create: XOR<EmployeeCreateWithoutPerformanceRecordsInput, EmployeeUncheckedCreateWithoutPerformanceRecordsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPerformanceRecordsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPerformanceRecordsInput, EmployeeUncheckedUpdateWithoutPerformanceRecordsInput>
  }

  export type EmployeeUpdateWithoutPerformanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPerformanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutManualOverridesInput = {
    update: XOR<UserUpdateWithoutManualOverridesInput, UserUncheckedUpdateWithoutManualOverridesInput>
    create: XOR<UserCreateWithoutManualOverridesInput, UserUncheckedCreateWithoutManualOverridesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManualOverridesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManualOverridesInput, UserUncheckedUpdateWithoutManualOverridesInput>
  }

  export type UserUpdateWithoutManualOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManualOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUncheckedUpdateManyWithoutUserNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DepartmentCreateWithoutPerformanceThresholdInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentDepartment?: DepartmentCreateNestedOneWithoutChildDepartmentsInput
    childDepartments?: DepartmentCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    positions?: PositionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPerformanceThresholdInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPerformanceThresholdInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPerformanceThresholdInput, DepartmentUncheckedCreateWithoutPerformanceThresholdInput>
  }

  export type DepartmentUpsertWithoutPerformanceThresholdInput = {
    update: XOR<DepartmentUpdateWithoutPerformanceThresholdInput, DepartmentUncheckedUpdateWithoutPerformanceThresholdInput>
    create: XOR<DepartmentCreateWithoutPerformanceThresholdInput, DepartmentUncheckedCreateWithoutPerformanceThresholdInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPerformanceThresholdInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPerformanceThresholdInput, DepartmentUncheckedUpdateWithoutPerformanceThresholdInput>
  }

  export type DepartmentUpdateWithoutPerformanceThresholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDepartment?: DepartmentUpdateOneWithoutChildDepartmentsNestedInput
    childDepartments?: DepartmentUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPerformanceThresholdInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDepartments?: DepartmentUncheckedUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateWithoutChildDepartmentsInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentDepartment?: DepartmentCreateNestedOneWithoutChildDepartmentsInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    positions?: PositionCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutChildDepartmentsInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutChildDepartmentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutChildDepartmentsInput, DepartmentUncheckedCreateWithoutChildDepartmentsInput>
  }

  export type DepartmentCreateWithoutParentDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    childDepartments?: DepartmentCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    positions?: PositionCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutParentDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    childDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutParentDepartmentInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutParentDepartmentInput, DepartmentUncheckedCreateWithoutParentDepartmentInput>
  }

  export type DepartmentCreateManyParentDepartmentInputEnvelope = {
    data: DepartmentCreateManyParentDepartmentInput | DepartmentCreateManyParentDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type PositionCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutDepartmentInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput>
  }

  export type PositionCreateManyDepartmentInputEnvelope = {
    data: PositionCreateManyDepartmentInput | PositionCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceThresholdCreateWithoutDepartmentInput = {
    id?: string
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceThresholdUncheckedCreateWithoutDepartmentInput = {
    id?: string
    redMin: number
    redMax: number
    yellowMin: number
    yellowMax: number
    greenMin: number
    greenMax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceThresholdCreateOrConnectWithoutDepartmentInput = {
    where: PerformanceThresholdWhereUniqueInput
    create: XOR<PerformanceThresholdCreateWithoutDepartmentInput, PerformanceThresholdUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentUpsertWithoutChildDepartmentsInput = {
    update: XOR<DepartmentUpdateWithoutChildDepartmentsInput, DepartmentUncheckedUpdateWithoutChildDepartmentsInput>
    create: XOR<DepartmentCreateWithoutChildDepartmentsInput, DepartmentUncheckedCreateWithoutChildDepartmentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutChildDepartmentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutChildDepartmentsInput, DepartmentUncheckedUpdateWithoutChildDepartmentsInput>
  }

  export type DepartmentUpdateWithoutChildDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDepartment?: DepartmentUpdateOneWithoutChildDepartmentsNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutChildDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUncheckedUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutParentDepartmentInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutParentDepartmentInput, DepartmentUncheckedUpdateWithoutParentDepartmentInput>
    create: XOR<DepartmentCreateWithoutParentDepartmentInput, DepartmentUncheckedCreateWithoutParentDepartmentInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutParentDepartmentInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutParentDepartmentInput, DepartmentUncheckedUpdateWithoutParentDepartmentInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutParentDepartmentInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutParentDepartmentInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    code?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    parentId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type PositionUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutDepartmentInput, PositionUncheckedUpdateWithoutDepartmentInput>
    create: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutDepartmentInput, PositionUncheckedUpdateWithoutDepartmentInput>
  }

  export type PositionUpdateManyWithWhereWithoutDepartmentInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type PositionScalarWhereInput = {
    AND?: PositionScalarWhereInput | PositionScalarWhereInput[]
    OR?: PositionScalarWhereInput[]
    NOT?: PositionScalarWhereInput | PositionScalarWhereInput[]
    id?: StringFilter<"Position"> | string
    title?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    level?: IntFilter<"Position"> | number
    isActive?: BoolFilter<"Position"> | boolean
    departmentId?: StringFilter<"Position"> | string
    minSalary?: DecimalNullableFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    maxSalary?: DecimalNullableFilter<"Position"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
  }

  export type PerformanceThresholdUpsertWithoutDepartmentInput = {
    update: XOR<PerformanceThresholdUpdateWithoutDepartmentInput, PerformanceThresholdUncheckedUpdateWithoutDepartmentInput>
    create: XOR<PerformanceThresholdCreateWithoutDepartmentInput, PerformanceThresholdUncheckedCreateWithoutDepartmentInput>
    where?: PerformanceThresholdWhereInput
  }

  export type PerformanceThresholdUpdateToOneWithWhereWithoutDepartmentInput = {
    where?: PerformanceThresholdWhereInput
    data: XOR<PerformanceThresholdUpdateWithoutDepartmentInput, PerformanceThresholdUncheckedUpdateWithoutDepartmentInput>
  }

  export type PerformanceThresholdUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    redMin?: IntFieldUpdateOperationsInput | number
    redMax?: IntFieldUpdateOperationsInput | number
    yellowMin?: IntFieldUpdateOperationsInput | number
    yellowMax?: IntFieldUpdateOperationsInput | number
    greenMin?: IntFieldUpdateOperationsInput | number
    greenMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceThresholdUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    redMin?: IntFieldUpdateOperationsInput | number
    redMax?: IntFieldUpdateOperationsInput | number
    yellowMin?: IntFieldUpdateOperationsInput | number
    yellowMax?: IntFieldUpdateOperationsInput | number
    greenMin?: IntFieldUpdateOperationsInput | number
    greenMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutPositionsInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentDepartment?: DepartmentCreateNestedOneWithoutChildDepartmentsInput
    childDepartments?: DepartmentCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPositionsInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    performanceThreshold?: PerformanceThresholdUncheckedCreateNestedOneWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPositionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
  }

  export type EmployeeCreateWithoutPositionInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPositionInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeCreateManyPositionInputEnvelope = {
    data: EmployeeCreateManyPositionInput | EmployeeCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutPositionsInput = {
    update: XOR<DepartmentUpdateWithoutPositionsInput, DepartmentUncheckedUpdateWithoutPositionsInput>
    create: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPositionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPositionsInput, DepartmentUncheckedUpdateWithoutPositionsInput>
  }

  export type DepartmentUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentDepartment?: DepartmentUpdateOneWithoutChildDepartmentsNestedInput
    childDepartments?: DepartmentUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDepartments?: DepartmentUncheckedUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUncheckedUpdateOneWithoutDepartmentNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutPositionInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutPositionInput>
  }

  export type SubAccountCreateWithoutCustomerInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountCreateOrConnectWithoutCustomerInput = {
    where: SubAccountWhereUniqueInput
    create: XOR<SubAccountCreateWithoutCustomerInput, SubAccountUncheckedCreateWithoutCustomerInput>
  }

  export type SubAccountCreateManyCustomerInputEnvelope = {
    data: SubAccountCreateManyCustomerInput | SubAccountCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentCreateNestedManyWithoutOrderInput
    ratings?: RatingCreateNestedManyWithoutOrderInput
    files?: FileCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationUncheckedCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentUncheckedCreateNestedManyWithoutOrderInput
    ratings?: RatingUncheckedCreateNestedManyWithoutOrderInput
    files?: FileUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutCustomerInput = {
    id?: string
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: OrderCreateNestedOneWithoutRatingsInput
    employee?: EmployeeCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderId?: string | null
    employeeId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutCustomerInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutCustomerInput, RatingUncheckedCreateWithoutCustomerInput>
  }

  export type RatingCreateManyCustomerInputEnvelope = {
    data: RatingCreateManyCustomerInput | RatingCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SubAccountWhereUniqueInput
    update: XOR<SubAccountUpdateWithoutCustomerInput, SubAccountUncheckedUpdateWithoutCustomerInput>
    create: XOR<SubAccountCreateWithoutCustomerInput, SubAccountUncheckedCreateWithoutCustomerInput>
  }

  export type SubAccountUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SubAccountWhereUniqueInput
    data: XOR<SubAccountUpdateWithoutCustomerInput, SubAccountUncheckedUpdateWithoutCustomerInput>
  }

  export type SubAccountUpdateManyWithWhereWithoutCustomerInput = {
    where: SubAccountScalarWhereInput
    data: XOR<SubAccountUpdateManyMutationInput, SubAccountUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubAccountScalarWhereInput = {
    AND?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    OR?: SubAccountScalarWhereInput[]
    NOT?: SubAccountScalarWhereInput | SubAccountScalarWhereInput[]
    id?: StringFilter<"SubAccount"> | string
    name?: StringFilter<"SubAccount"> | string
    code?: StringNullableFilter<"SubAccount"> | string | null
    isActive?: BoolFilter<"SubAccount"> | boolean
    customerId?: StringFilter<"SubAccount"> | string
    createdAt?: DateTimeFilter<"SubAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccount"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    description?: StringNullableFilter<"Order"> | string | null
    scheduledDate?: DateTimeFilter<"Order"> | Date | string
    startTime?: DateTimeNullableFilter<"Order"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Order"> | Date | string | null
    duration?: IntNullableFilter<"Order"> | number | null
    location?: StringNullableFilter<"Order"> | string | null
    requiredEmployees?: IntFilter<"Order"> | number
    priority?: IntFilter<"Order"> | number
    specialInstructions?: StringNullableFilter<"Order"> | string | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    customerId?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    createdBy?: StringNullableFilter<"Order"> | string | null
    updatedBy?: StringNullableFilter<"Order"> | string | null
  }

  export type RatingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutCustomerInput, RatingUncheckedUpdateWithoutCustomerInput>
    create: XOR<RatingCreateWithoutCustomerInput, RatingUncheckedCreateWithoutCustomerInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutCustomerInput, RatingUncheckedUpdateWithoutCustomerInput>
  }

  export type RatingUpdateManyWithWhereWithoutCustomerInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutSubAccountsInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    ratings?: RatingCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubAccountsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubAccountsInput, CustomerUncheckedCreateWithoutSubAccountsInput>
  }

  export type CustomerUpsertWithoutSubAccountsInput = {
    update: XOR<CustomerUpdateWithoutSubAccountsInput, CustomerUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<CustomerCreateWithoutSubAccountsInput, CustomerUncheckedCreateWithoutSubAccountsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubAccountsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubAccountsInput, CustomerUncheckedUpdateWithoutSubAccountsInput>
  }

  export type CustomerUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    ratings?: RatingUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccounts?: SubAccountCreateNestedManyWithoutCustomerInput
    ratings?: RatingCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutCustomerInput
    ratings?: RatingUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderQualificationCreateWithoutOrderInput = {
    id?: string
    required?: boolean
    minProficiency?: number
    qualification: QualificationCreateNestedOneWithoutOrderQualificationsInput
  }

  export type OrderQualificationUncheckedCreateWithoutOrderInput = {
    id?: string
    qualificationId: string
    required?: boolean
    minProficiency?: number
  }

  export type OrderQualificationCreateOrConnectWithoutOrderInput = {
    where: OrderQualificationWhereUniqueInput
    create: XOR<OrderQualificationCreateWithoutOrderInput, OrderQualificationUncheckedCreateWithoutOrderInput>
  }

  export type OrderQualificationCreateManyOrderInputEnvelope = {
    data: OrderQualificationCreateManyOrderInput | OrderQualificationCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderAssignmentCreateWithoutOrderInput = {
    id?: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutOrderAssignmentsInput
  }

  export type OrderAssignmentUncheckedCreateWithoutOrderInput = {
    id?: string
    employeeId: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAssignmentCreateOrConnectWithoutOrderInput = {
    where: OrderAssignmentWhereUniqueInput
    create: XOR<OrderAssignmentCreateWithoutOrderInput, OrderAssignmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAssignmentCreateManyOrderInputEnvelope = {
    data: OrderAssignmentCreateManyOrderInput | OrderAssignmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutOrderInput = {
    id?: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee: EmployeeCreateNestedOneWithoutAssignmentsInput
    files?: FileCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutOrderInput = {
    id?: string
    employeeId: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    files?: FileUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutOrderInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutOrderInput, AssignmentUncheckedCreateWithoutOrderInput>
  }

  export type AssignmentCreateManyOrderInputEnvelope = {
    data: AssignmentCreateManyOrderInput | AssignmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutOrderInput = {
    id?: string
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutRatingsInput
    customer?: CustomerCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutOrderInput = {
    id?: string
    employeeId?: string | null
    customerId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutOrderInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutOrderInput, RatingUncheckedCreateWithoutOrderInput>
  }

  export type RatingCreateManyOrderInputEnvelope = {
    data: RatingCreateManyOrderInput | RatingCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutOrderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutFilesInput
    assignment?: AssignmentCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutOrderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    employeeId?: string | null
    assignmentId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutOrderInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutOrderInput, FileUncheckedCreateWithoutOrderInput>
  }

  export type FileCreateManyOrderInputEnvelope = {
    data: FileCreateManyOrderInput | FileCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccounts?: SubAccountUpdateManyWithoutCustomerNestedInput
    ratings?: RatingUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccounts?: SubAccountUncheckedUpdateManyWithoutCustomerNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderQualificationUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderQualificationWhereUniqueInput
    update: XOR<OrderQualificationUpdateWithoutOrderInput, OrderQualificationUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderQualificationCreateWithoutOrderInput, OrderQualificationUncheckedCreateWithoutOrderInput>
  }

  export type OrderQualificationUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderQualificationWhereUniqueInput
    data: XOR<OrderQualificationUpdateWithoutOrderInput, OrderQualificationUncheckedUpdateWithoutOrderInput>
  }

  export type OrderQualificationUpdateManyWithWhereWithoutOrderInput = {
    where: OrderQualificationScalarWhereInput
    data: XOR<OrderQualificationUpdateManyMutationInput, OrderQualificationUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderQualificationScalarWhereInput = {
    AND?: OrderQualificationScalarWhereInput | OrderQualificationScalarWhereInput[]
    OR?: OrderQualificationScalarWhereInput[]
    NOT?: OrderQualificationScalarWhereInput | OrderQualificationScalarWhereInput[]
    id?: StringFilter<"OrderQualification"> | string
    orderId?: StringFilter<"OrderQualification"> | string
    qualificationId?: StringFilter<"OrderQualification"> | string
    required?: BoolFilter<"OrderQualification"> | boolean
    minProficiency?: IntFilter<"OrderQualification"> | number
  }

  export type OrderAssignmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderAssignmentWhereUniqueInput
    update: XOR<OrderAssignmentUpdateWithoutOrderInput, OrderAssignmentUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderAssignmentCreateWithoutOrderInput, OrderAssignmentUncheckedCreateWithoutOrderInput>
  }

  export type OrderAssignmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderAssignmentWhereUniqueInput
    data: XOR<OrderAssignmentUpdateWithoutOrderInput, OrderAssignmentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderAssignmentUpdateManyWithWhereWithoutOrderInput = {
    where: OrderAssignmentScalarWhereInput
    data: XOR<OrderAssignmentUpdateManyMutationInput, OrderAssignmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutOrderInput, AssignmentUncheckedUpdateWithoutOrderInput>
    create: XOR<AssignmentCreateWithoutOrderInput, AssignmentUncheckedCreateWithoutOrderInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutOrderInput, AssignmentUncheckedUpdateWithoutOrderInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutOrderInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutOrderInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutOrderInput, RatingUncheckedUpdateWithoutOrderInput>
    create: XOR<RatingCreateWithoutOrderInput, RatingUncheckedCreateWithoutOrderInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutOrderInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutOrderInput, RatingUncheckedUpdateWithoutOrderInput>
  }

  export type RatingUpdateManyWithWhereWithoutOrderInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutOrderInput>
  }

  export type FileUpsertWithWhereUniqueWithoutOrderInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutOrderInput, FileUncheckedUpdateWithoutOrderInput>
    create: XOR<FileCreateWithoutOrderInput, FileUncheckedCreateWithoutOrderInput>
  }

  export type FileUpdateWithWhereUniqueWithoutOrderInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutOrderInput, FileUncheckedUpdateWithoutOrderInput>
  }

  export type FileUpdateManyWithWhereWithoutOrderInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutOrderInput>
  }

  export type EmployeeQualificationCreateWithoutQualificationInput = {
    id?: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutQualificationsInput
  }

  export type EmployeeQualificationUncheckedCreateWithoutQualificationInput = {
    id?: string
    employeeId: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeQualificationCreateOrConnectWithoutQualificationInput = {
    where: EmployeeQualificationWhereUniqueInput
    create: XOR<EmployeeQualificationCreateWithoutQualificationInput, EmployeeQualificationUncheckedCreateWithoutQualificationInput>
  }

  export type EmployeeQualificationCreateManyQualificationInputEnvelope = {
    data: EmployeeQualificationCreateManyQualificationInput | EmployeeQualificationCreateManyQualificationInput[]
    skipDuplicates?: boolean
  }

  export type OrderQualificationCreateWithoutQualificationInput = {
    id?: string
    required?: boolean
    minProficiency?: number
    order: OrderCreateNestedOneWithoutQualificationsInput
  }

  export type OrderQualificationUncheckedCreateWithoutQualificationInput = {
    id?: string
    orderId: string
    required?: boolean
    minProficiency?: number
  }

  export type OrderQualificationCreateOrConnectWithoutQualificationInput = {
    where: OrderQualificationWhereUniqueInput
    create: XOR<OrderQualificationCreateWithoutQualificationInput, OrderQualificationUncheckedCreateWithoutQualificationInput>
  }

  export type OrderQualificationCreateManyQualificationInputEnvelope = {
    data: OrderQualificationCreateManyQualificationInput | OrderQualificationCreateManyQualificationInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeQualificationUpsertWithWhereUniqueWithoutQualificationInput = {
    where: EmployeeQualificationWhereUniqueInput
    update: XOR<EmployeeQualificationUpdateWithoutQualificationInput, EmployeeQualificationUncheckedUpdateWithoutQualificationInput>
    create: XOR<EmployeeQualificationCreateWithoutQualificationInput, EmployeeQualificationUncheckedCreateWithoutQualificationInput>
  }

  export type EmployeeQualificationUpdateWithWhereUniqueWithoutQualificationInput = {
    where: EmployeeQualificationWhereUniqueInput
    data: XOR<EmployeeQualificationUpdateWithoutQualificationInput, EmployeeQualificationUncheckedUpdateWithoutQualificationInput>
  }

  export type EmployeeQualificationUpdateManyWithWhereWithoutQualificationInput = {
    where: EmployeeQualificationScalarWhereInput
    data: XOR<EmployeeQualificationUpdateManyMutationInput, EmployeeQualificationUncheckedUpdateManyWithoutQualificationInput>
  }

  export type OrderQualificationUpsertWithWhereUniqueWithoutQualificationInput = {
    where: OrderQualificationWhereUniqueInput
    update: XOR<OrderQualificationUpdateWithoutQualificationInput, OrderQualificationUncheckedUpdateWithoutQualificationInput>
    create: XOR<OrderQualificationCreateWithoutQualificationInput, OrderQualificationUncheckedCreateWithoutQualificationInput>
  }

  export type OrderQualificationUpdateWithWhereUniqueWithoutQualificationInput = {
    where: OrderQualificationWhereUniqueInput
    data: XOR<OrderQualificationUpdateWithoutQualificationInput, OrderQualificationUncheckedUpdateWithoutQualificationInput>
  }

  export type OrderQualificationUpdateManyWithWhereWithoutQualificationInput = {
    where: OrderQualificationScalarWhereInput
    data: XOR<OrderQualificationUpdateManyMutationInput, OrderQualificationUncheckedUpdateManyWithoutQualificationInput>
  }

  export type EmployeeCreateWithoutQualificationsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutQualificationsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutQualificationsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutQualificationsInput, EmployeeUncheckedCreateWithoutQualificationsInput>
  }

  export type QualificationCreateWithoutEmployeeQualificationsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQualifications?: OrderQualificationCreateNestedManyWithoutQualificationInput
  }

  export type QualificationUncheckedCreateWithoutEmployeeQualificationsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderQualifications?: OrderQualificationUncheckedCreateNestedManyWithoutQualificationInput
  }

  export type QualificationCreateOrConnectWithoutEmployeeQualificationsInput = {
    where: QualificationWhereUniqueInput
    create: XOR<QualificationCreateWithoutEmployeeQualificationsInput, QualificationUncheckedCreateWithoutEmployeeQualificationsInput>
  }

  export type EmployeeUpsertWithoutQualificationsInput = {
    update: XOR<EmployeeUpdateWithoutQualificationsInput, EmployeeUncheckedUpdateWithoutQualificationsInput>
    create: XOR<EmployeeCreateWithoutQualificationsInput, EmployeeUncheckedCreateWithoutQualificationsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutQualificationsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutQualificationsInput, EmployeeUncheckedUpdateWithoutQualificationsInput>
  }

  export type EmployeeUpdateWithoutQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type QualificationUpsertWithoutEmployeeQualificationsInput = {
    update: XOR<QualificationUpdateWithoutEmployeeQualificationsInput, QualificationUncheckedUpdateWithoutEmployeeQualificationsInput>
    create: XOR<QualificationCreateWithoutEmployeeQualificationsInput, QualificationUncheckedCreateWithoutEmployeeQualificationsInput>
    where?: QualificationWhereInput
  }

  export type QualificationUpdateToOneWithWhereWithoutEmployeeQualificationsInput = {
    where?: QualificationWhereInput
    data: XOR<QualificationUpdateWithoutEmployeeQualificationsInput, QualificationUncheckedUpdateWithoutEmployeeQualificationsInput>
  }

  export type QualificationUpdateWithoutEmployeeQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQualifications?: OrderQualificationUpdateManyWithoutQualificationNestedInput
  }

  export type QualificationUncheckedUpdateWithoutEmployeeQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderQualifications?: OrderQualificationUncheckedUpdateManyWithoutQualificationNestedInput
  }

  export type OrderCreateWithoutQualificationsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentCreateNestedManyWithoutOrderInput
    ratings?: RatingCreateNestedManyWithoutOrderInput
    files?: FileCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutQualificationsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentUncheckedCreateNestedManyWithoutOrderInput
    ratings?: RatingUncheckedCreateNestedManyWithoutOrderInput
    files?: FileUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutQualificationsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutQualificationsInput, OrderUncheckedCreateWithoutQualificationsInput>
  }

  export type QualificationCreateWithoutOrderQualificationsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeQualifications?: EmployeeQualificationCreateNestedManyWithoutQualificationInput
  }

  export type QualificationUncheckedCreateWithoutOrderQualificationsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    isActive?: boolean
    requiresCertificate?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeQualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutQualificationInput
  }

  export type QualificationCreateOrConnectWithoutOrderQualificationsInput = {
    where: QualificationWhereUniqueInput
    create: XOR<QualificationCreateWithoutOrderQualificationsInput, QualificationUncheckedCreateWithoutOrderQualificationsInput>
  }

  export type OrderUpsertWithoutQualificationsInput = {
    update: XOR<OrderUpdateWithoutQualificationsInput, OrderUncheckedUpdateWithoutQualificationsInput>
    create: XOR<OrderCreateWithoutQualificationsInput, OrderUncheckedCreateWithoutQualificationsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutQualificationsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutQualificationsInput, OrderUncheckedUpdateWithoutQualificationsInput>
  }

  export type OrderUpdateWithoutQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUpdateManyWithoutOrderNestedInput
    ratings?: RatingUpdateManyWithoutOrderNestedInput
    files?: FileUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutOrderNestedInput
    files?: FileUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type QualificationUpsertWithoutOrderQualificationsInput = {
    update: XOR<QualificationUpdateWithoutOrderQualificationsInput, QualificationUncheckedUpdateWithoutOrderQualificationsInput>
    create: XOR<QualificationCreateWithoutOrderQualificationsInput, QualificationUncheckedCreateWithoutOrderQualificationsInput>
    where?: QualificationWhereInput
  }

  export type QualificationUpdateToOneWithWhereWithoutOrderQualificationsInput = {
    where?: QualificationWhereInput
    data: XOR<QualificationUpdateWithoutOrderQualificationsInput, QualificationUncheckedUpdateWithoutOrderQualificationsInput>
  }

  export type QualificationUpdateWithoutOrderQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeQualifications?: EmployeeQualificationUpdateManyWithoutQualificationNestedInput
  }

  export type QualificationUncheckedUpdateWithoutOrderQualificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresCertificate?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeQualifications?: EmployeeQualificationUncheckedUpdateManyWithoutQualificationNestedInput
  }

  export type OrderCreateWithoutEmployeeAssignmentsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    qualifications?: OrderQualificationCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutOrderInput
    ratings?: RatingCreateNestedManyWithoutOrderInput
    files?: FileCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutEmployeeAssignmentsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationUncheckedCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput
    ratings?: RatingUncheckedCreateNestedManyWithoutOrderInput
    files?: FileUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutEmployeeAssignmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutEmployeeAssignmentsInput, OrderUncheckedCreateWithoutEmployeeAssignmentsInput>
  }

  export type EmployeeCreateWithoutAssignmentsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAssignmentsInput, EmployeeUncheckedCreateWithoutAssignmentsInput>
  }

  export type FileCreateWithoutAssignmentInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutFilesInput
    order?: OrderCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutAssignmentInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    employeeId?: string | null
    orderId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutAssignmentInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutAssignmentInput, FileUncheckedCreateWithoutAssignmentInput>
  }

  export type FileCreateManyAssignmentInputEnvelope = {
    data: FileCreateManyAssignmentInput | FileCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutEmployeeAssignmentsInput = {
    update: XOR<OrderUpdateWithoutEmployeeAssignmentsInput, OrderUncheckedUpdateWithoutEmployeeAssignmentsInput>
    create: XOR<OrderCreateWithoutEmployeeAssignmentsInput, OrderUncheckedCreateWithoutEmployeeAssignmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutEmployeeAssignmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutEmployeeAssignmentsInput, OrderUncheckedUpdateWithoutEmployeeAssignmentsInput>
  }

  export type OrderUpdateWithoutEmployeeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    qualifications?: OrderQualificationUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutOrderNestedInput
    ratings?: RatingUpdateManyWithoutOrderNestedInput
    files?: FileUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutEmployeeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutOrderNestedInput
    files?: FileUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type EmployeeUpsertWithoutAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutAssignmentsInput, EmployeeUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<EmployeeCreateWithoutAssignmentsInput, EmployeeUncheckedCreateWithoutAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAssignmentsInput, EmployeeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type EmployeeUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutAssignmentInput, FileUncheckedUpdateWithoutAssignmentInput>
    create: XOR<FileCreateWithoutAssignmentInput, FileUncheckedCreateWithoutAssignmentInput>
  }

  export type FileUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutAssignmentInput, FileUncheckedUpdateWithoutAssignmentInput>
  }

  export type FileUpdateManyWithWhereWithoutAssignmentInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type OrderCreateWithoutOrderAssignmentsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    qualifications?: OrderQualificationCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentCreateNestedManyWithoutOrderInput
    ratings?: RatingCreateNestedManyWithoutOrderInput
    files?: FileCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderAssignmentsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationUncheckedCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentUncheckedCreateNestedManyWithoutOrderInput
    ratings?: RatingUncheckedCreateNestedManyWithoutOrderInput
    files?: FileUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderAssignmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderAssignmentsInput, OrderUncheckedCreateWithoutOrderAssignmentsInput>
  }

  export type EmployeeCreateWithoutOrderAssignmentsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutOrderAssignmentsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutOrderAssignmentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOrderAssignmentsInput, EmployeeUncheckedCreateWithoutOrderAssignmentsInput>
  }

  export type OrderUpsertWithoutOrderAssignmentsInput = {
    update: XOR<OrderUpdateWithoutOrderAssignmentsInput, OrderUncheckedUpdateWithoutOrderAssignmentsInput>
    create: XOR<OrderCreateWithoutOrderAssignmentsInput, OrderUncheckedCreateWithoutOrderAssignmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderAssignmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderAssignmentsInput, OrderUncheckedUpdateWithoutOrderAssignmentsInput>
  }

  export type OrderUpdateWithoutOrderAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    qualifications?: OrderQualificationUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUpdateManyWithoutOrderNestedInput
    ratings?: RatingUpdateManyWithoutOrderNestedInput
    files?: FileUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutOrderNestedInput
    files?: FileUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type EmployeeUpsertWithoutOrderAssignmentsInput = {
    update: XOR<EmployeeUpdateWithoutOrderAssignmentsInput, EmployeeUncheckedUpdateWithoutOrderAssignmentsInput>
    create: XOR<EmployeeCreateWithoutOrderAssignmentsInput, EmployeeUncheckedCreateWithoutOrderAssignmentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutOrderAssignmentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutOrderAssignmentsInput, EmployeeUncheckedUpdateWithoutOrderAssignmentsInput>
  }

  export type EmployeeUpdateWithoutOrderAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOrderAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAbsencesInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAbsencesInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAbsencesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
  }

  export type EmployeeUpsertWithoutAbsencesInput = {
    update: XOR<EmployeeUpdateWithoutAbsencesInput, EmployeeUncheckedUpdateWithoutAbsencesInput>
    create: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAbsencesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAbsencesInput, EmployeeUncheckedUpdateWithoutAbsencesInput>
  }

  export type EmployeeUpdateWithoutAbsencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAbsencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type OrderCreateWithoutRatingsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    qualifications?: OrderQualificationCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentCreateNestedManyWithoutOrderInput
    files?: FileCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRatingsInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationUncheckedCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentUncheckedCreateNestedManyWithoutOrderInput
    files?: FileUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRatingsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRatingsInput, OrderUncheckedCreateWithoutRatingsInput>
  }

  export type EmployeeCreateWithoutRatingsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutRatingsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutRatingsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRatingsInput, EmployeeUncheckedCreateWithoutRatingsInput>
  }

  export type CustomerCreateWithoutRatingsInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccounts?: SubAccountCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRatingsInput = {
    id?: string
    companyName: string
    contactEmail?: string | null
    contactPhone?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    industry?: string | null
    taxNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccounts?: SubAccountUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRatingsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRatingsInput, CustomerUncheckedCreateWithoutRatingsInput>
  }

  export type OrderUpsertWithoutRatingsInput = {
    update: XOR<OrderUpdateWithoutRatingsInput, OrderUncheckedUpdateWithoutRatingsInput>
    create: XOR<OrderCreateWithoutRatingsInput, OrderUncheckedCreateWithoutRatingsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutRatingsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutRatingsInput, OrderUncheckedUpdateWithoutRatingsInput>
  }

  export type OrderUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    qualifications?: OrderQualificationUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUpdateManyWithoutOrderNestedInput
    files?: FileUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUncheckedUpdateManyWithoutOrderNestedInput
    files?: FileUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type EmployeeUpsertWithoutRatingsInput = {
    update: XOR<EmployeeUpdateWithoutRatingsInput, EmployeeUncheckedUpdateWithoutRatingsInput>
    create: XOR<EmployeeCreateWithoutRatingsInput, EmployeeUncheckedCreateWithoutRatingsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutRatingsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutRatingsInput, EmployeeUncheckedUpdateWithoutRatingsInput>
  }

  export type EmployeeUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type CustomerUpsertWithoutRatingsInput = {
    update: XOR<CustomerUpdateWithoutRatingsInput, CustomerUncheckedUpdateWithoutRatingsInput>
    create: XOR<CustomerCreateWithoutRatingsInput, CustomerUncheckedCreateWithoutRatingsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRatingsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRatingsInput, CustomerUncheckedUpdateWithoutRatingsInput>
  }

  export type CustomerUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccounts?: SubAccountUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccounts?: SubAccountUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type EmployeeCreateWithoutWorkStatisticsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
    files?: FileCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWorkStatisticsInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    files?: FileUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWorkStatisticsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkStatisticsInput, EmployeeUncheckedCreateWithoutWorkStatisticsInput>
  }

  export type EmployeeUpsertWithoutWorkStatisticsInput = {
    update: XOR<EmployeeUpdateWithoutWorkStatisticsInput, EmployeeUncheckedUpdateWithoutWorkStatisticsInput>
    create: XOR<EmployeeCreateWithoutWorkStatisticsInput, EmployeeUncheckedCreateWithoutWorkStatisticsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutWorkStatisticsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutWorkStatisticsInput, EmployeeUncheckedUpdateWithoutWorkStatisticsInput>
  }

  export type EmployeeUpdateWithoutWorkStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type NotificationRecipientCreateWithoutNotificationInput = {
    id?: string
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationRecipientsInput
  }

  export type NotificationRecipientUncheckedCreateWithoutNotificationInput = {
    id?: string
    userId?: string | null
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationRecipientCreateOrConnectWithoutNotificationInput = {
    where: NotificationRecipientWhereUniqueInput
    create: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationRecipientCreateManyNotificationInputEnvelope = {
    data: NotificationRecipientCreateManyNotificationInput | NotificationRecipientCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationOutboxCreateWithoutNotificationInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    channel: string
    attempts?: number
    maxAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationOutboxUncheckedCreateWithoutNotificationInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    channel: string
    attempts?: number
    maxAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationOutboxCreateOrConnectWithoutNotificationInput = {
    where: NotificationOutboxWhereUniqueInput
    create: XOR<NotificationOutboxCreateWithoutNotificationInput, NotificationOutboxUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationOutboxCreateManyNotificationInputEnvelope = {
    data: NotificationOutboxCreateManyNotificationInput | NotificationOutboxCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationRecipientWhereUniqueInput
    update: XOR<NotificationRecipientUpdateWithoutNotificationInput, NotificationRecipientUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationRecipientWhereUniqueInput
    data: XOR<NotificationRecipientUpdateWithoutNotificationInput, NotificationRecipientUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationRecipientUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationRecipientScalarWhereInput
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationOutboxUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationOutboxWhereUniqueInput
    update: XOR<NotificationOutboxUpdateWithoutNotificationInput, NotificationOutboxUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationOutboxCreateWithoutNotificationInput, NotificationOutboxUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationOutboxUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationOutboxWhereUniqueInput
    data: XOR<NotificationOutboxUpdateWithoutNotificationInput, NotificationOutboxUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationOutboxUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationOutboxScalarWhereInput
    data: XOR<NotificationOutboxUpdateManyMutationInput, NotificationOutboxUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationOutboxScalarWhereInput = {
    AND?: NotificationOutboxScalarWhereInput | NotificationOutboxScalarWhereInput[]
    OR?: NotificationOutboxScalarWhereInput[]
    NOT?: NotificationOutboxScalarWhereInput | NotificationOutboxScalarWhereInput[]
    id?: StringFilter<"NotificationOutbox"> | string
    notificationId?: StringNullableFilter<"NotificationOutbox"> | string | null
    payload?: JsonFilter<"NotificationOutbox">
    channel?: StringFilter<"NotificationOutbox"> | string
    attempts?: IntFilter<"NotificationOutbox"> | number
    maxAttempts?: IntFilter<"NotificationOutbox"> | number
    lockedUntil?: DateTimeNullableFilter<"NotificationOutbox"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationOutbox"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationOutbox"> | Date | string
  }

  export type NotificationCreateWithoutRecipientsInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
    NotificationOutbox?: NotificationOutboxCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutRecipientsInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
    NotificationOutbox?: NotificationOutboxUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutRecipientsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
  }

  export type UserCreateWithoutNotificationRecipientsInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    notificationPreferences?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationRecipientsInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceUncheckedCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    notificationPreferences?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationRecipientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationRecipientsInput, UserUncheckedCreateWithoutNotificationRecipientsInput>
  }

  export type NotificationUpsertWithoutRecipientsInput = {
    update: XOR<NotificationUpdateWithoutRecipientsInput, NotificationUncheckedUpdateWithoutRecipientsInput>
    create: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutRecipientsInput, NotificationUncheckedUpdateWithoutRecipientsInput>
  }

  export type NotificationUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    NotificationOutbox?: NotificationOutboxUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    NotificationOutbox?: NotificationOutboxUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type UserUpsertWithoutNotificationRecipientsInput = {
    update: XOR<UserUpdateWithoutNotificationRecipientsInput, UserUncheckedUpdateWithoutNotificationRecipientsInput>
    create: XOR<UserCreateWithoutNotificationRecipientsInput, UserUncheckedCreateWithoutNotificationRecipientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationRecipientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationRecipientsInput, UserUncheckedUpdateWithoutNotificationRecipientsInput>
  }

  export type UserUpdateWithoutNotificationRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    notificationPreferences?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    notificationPreferences?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type NotificationCreateWithoutNotificationOutboxInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
    recipients?: NotificationRecipientCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutNotificationOutboxInput = {
    id?: string
    templateKey?: string | null
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deliveredAt?: Date | string | null
    status?: string
    recipients?: NotificationRecipientUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutNotificationOutboxInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutNotificationOutboxInput, NotificationUncheckedCreateWithoutNotificationOutboxInput>
  }

  export type NotificationUpsertWithoutNotificationOutboxInput = {
    update: XOR<NotificationUpdateWithoutNotificationOutboxInput, NotificationUncheckedUpdateWithoutNotificationOutboxInput>
    create: XOR<NotificationCreateWithoutNotificationOutboxInput, NotificationUncheckedCreateWithoutNotificationOutboxInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutNotificationOutboxInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutNotificationOutboxInput, NotificationUncheckedUpdateWithoutNotificationOutboxInput>
  }

  export type NotificationUpdateWithoutNotificationOutboxInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NotificationRecipientUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutNotificationOutboxInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateKey?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: NotificationRecipientUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type UserCreateWithoutNotificationPreferencesInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: string
    email?: string | null
    username: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    refreshToken?: string | null
    emailVerificationToken?: string | null
    emailVerificationExpires?: Date | string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    emailVerified?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    manualOverrides?: EmployeePerformanceUncheckedCreateNestedManyWithoutManualOverrideByInput
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    notificationRecipients?: NotificationRecipientUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<UserCreateWithoutNotificationPreferencesInput, UserUncheckedCreateWithoutNotificationPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferencesInput, UserUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type UserUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    manualOverrides?: EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByNestedInput
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    notificationRecipients?: NotificationRecipientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmployeeCreateWithoutFilesInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutSubordinatesInput
    performanceRecords?: EmployeePerformanceCreateNestedManyWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
    qualifications?: EmployeeQualificationCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeeInput
    ratings?: RatingCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutFilesInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    performanceRecords?: EmployeePerformanceUncheckedCreateNestedManyWithoutEmployeeInput
    qualifications?: EmployeeQualificationUncheckedCreateNestedManyWithoutEmployeeInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutEmployeeInput
    workStatistics?: WorkStatisticUncheckedCreateNestedManyWithoutEmployeeInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutFilesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutFilesInput, EmployeeUncheckedCreateWithoutFilesInput>
  }

  export type OrderCreateWithoutFilesInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    customer: CustomerCreateNestedOneWithoutOrdersInput
    qualifications?: OrderQualificationCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentCreateNestedManyWithoutOrderInput
    ratings?: RatingCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutFilesInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    qualifications?: OrderQualificationUncheckedCreateNestedManyWithoutOrderInput
    orderAssignments?: OrderAssignmentUncheckedCreateNestedManyWithoutOrderInput
    employeeAssignments?: AssignmentUncheckedCreateNestedManyWithoutOrderInput
    ratings?: RatingUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutFilesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutFilesInput, OrderUncheckedCreateWithoutFilesInput>
  }

  export type AssignmentCreateWithoutFilesInput = {
    id?: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    order?: OrderCreateNestedOneWithoutEmployeeAssignmentsInput
    employee: EmployeeCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutFilesInput = {
    id?: string
    orderId?: string | null
    employeeId: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type AssignmentCreateOrConnectWithoutFilesInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutFilesInput, AssignmentUncheckedCreateWithoutFilesInput>
  }

  export type EmployeeUpsertWithoutFilesInput = {
    update: XOR<EmployeeUpdateWithoutFilesInput, EmployeeUncheckedUpdateWithoutFilesInput>
    create: XOR<EmployeeCreateWithoutFilesInput, EmployeeUncheckedCreateWithoutFilesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutFilesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutFilesInput, EmployeeUncheckedUpdateWithoutFilesInput>
  }

  export type EmployeeUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type OrderUpsertWithoutFilesInput = {
    update: XOR<OrderUpdateWithoutFilesInput, OrderUncheckedUpdateWithoutFilesInput>
    create: XOR<OrderCreateWithoutFilesInput, OrderUncheckedCreateWithoutFilesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutFilesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutFilesInput, OrderUncheckedUpdateWithoutFilesInput>
  }

  export type OrderUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    qualifications?: OrderQualificationUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUpdateManyWithoutOrderNestedInput
    ratings?: RatingUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type AssignmentUpsertWithoutFilesInput = {
    update: XOR<AssignmentUpdateWithoutFilesInput, AssignmentUncheckedUpdateWithoutFilesInput>
    create: XOR<AssignmentCreateWithoutFilesInput, AssignmentUncheckedCreateWithoutFilesInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutFilesInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutFilesInput, AssignmentUncheckedUpdateWithoutFilesInput>
  }

  export type AssignmentUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutEmployeeAssignmentsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeePerformanceCreateManyManualOverrideByInput = {
    id?: string
    employeeId: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyManagerInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type NotificationRecipientCreateManyUserInput = {
    id?: string
    notificationId: string
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
  }

  export type EmployeePerformanceUpdateWithoutManualOverrideByInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPerformanceRecordsNestedInput
  }

  export type EmployeePerformanceUncheckedUpdateWithoutManualOverrideByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePerformanceUncheckedUpdateManyWithoutManualOverrideByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationRecipientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type NotificationRecipientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePerformanceCreateManyEmployeeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    score: Decimal | DecimalJsLike | number | string
    trafficLight: $Enums.TrafficLight
    trafficLightReason?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: boolean
    manualOverrideById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeQualificationCreateManyEmployeeInput = {
    id?: string
    qualificationId: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyEmployeeInput = {
    id?: string
    orderId?: string | null
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type AbsenceCreateManyEmployeeInput = {
    id?: string
    type: $Enums.AbsenceType
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    status?: $Enums.RequestStatus
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    documentUrls?: AbsenceCreatedocumentUrlsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyEmployeeInput = {
    id?: string
    orderId?: string | null
    customerId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkStatisticCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    hoursWorked: Decimal | DecimalJsLike | number | string
    overtimeHours?: Decimal | DecimalJsLike | number | string
    location?: string | null
    projects?: WorkStatisticCreateprojectsInput | string[]
    efficiency?: Decimal | DecimalJsLike | number | string | null
    qualityScore?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderAssignmentCreateManyEmployeeInput = {
    id?: string
    orderId: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateManyEmployeeInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    orderId?: string | null
    assignmentId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeePerformanceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manualOverrideBy?: UserUpdateOneWithoutManualOverridesNestedInput
  }

  export type EmployeePerformanceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    manualOverrideById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeePerformanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trafficLight?: EnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight
    trafficLightReason?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    manualOverride?: BoolFieldUpdateOperationsInput | boolean
    manualOverrideById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: QualificationUpdateOneRequiredWithoutEmployeeQualificationsNestedInput
  }

  export type EmployeeQualificationUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutEmployeeAssignmentsNestedInput
    files?: FileUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AbsenceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAbsenceTypeFieldUpdateOperationsInput | $Enums.AbsenceType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: AbsenceUpdatedocumentUrlsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutRatingsNestedInput
    customer?: CustomerUpdateOneWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkStatisticUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkStatisticUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkStatisticUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hoursWorked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: WorkStatisticUpdateprojectsInput | string[]
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qualityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAssignmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderAssignmentsNestedInput
  }

  export type OrderAssignmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAssignmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutFilesNestedInput
    assignment?: AssignmentUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyParentDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    code: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    positionId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PositionCreateManyDepartmentInput = {
    id?: string
    title: string
    description?: string | null
    level?: number
    isActive?: boolean
    minSalary?: Decimal | DecimalJsLike | number | string | null
    maxSalary?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutParentDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDepartments?: DepartmentUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutParentDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childDepartments?: DepartmentUncheckedUpdateManyWithoutParentDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
    performanceThreshold?: PerformanceThresholdUncheckedUpdateOneWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutParentDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PositionUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    minSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyPositionInput = {
    id?: string
    employeeCode: string
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    dateOfBirth?: Date | string | null
    address?: string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate: Date | string
    terminationDate?: Date | string | null
    departmentId?: string | null
    managerId?: string | null
    scheduleType?: $Enums.WorkScheduleType
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    isAvailable?: boolean
    priority?: number
    blockedAt?: Date | string | null
    blockedReason?: string | null
    performanceScore?: Decimal | DecimalJsLike | number | string | null
    trafficLight?: $Enums.TrafficLight | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type EmployeeUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutSubordinatesNestedInput
    performanceRecords?: EmployeePerformanceUpdateManyWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutEmployeeNestedInput
    files?: FileUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    performanceRecords?: EmployeePerformanceUncheckedUpdateManyWithoutEmployeeNestedInput
    qualifications?: EmployeeQualificationUncheckedUpdateManyWithoutEmployeeNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutEmployeeNestedInput
    workStatistics?: WorkStatisticUncheckedUpdateManyWithoutEmployeeNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    files?: FileUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableJsonNullValueInput | InputJsonValue
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleType?: EnumWorkScheduleTypeFieldUpdateOperationsInput | $Enums.WorkScheduleType
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    blockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    performanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    trafficLight?: NullableEnumTrafficLightFieldUpdateOperationsInput | $Enums.TrafficLight | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountCreateManyCustomerInput = {
    id?: string
    name: string
    code?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    orderNumber: string
    description?: string | null
    scheduledDate: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    duration?: number | null
    location?: string | null
    requiredEmployees?: number
    priority?: number
    specialInstructions?: string | null
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type RatingCreateManyCustomerInput = {
    id?: string
    orderId?: string | null
    employeeId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUpdateManyWithoutOrderNestedInput
    ratings?: RatingUpdateManyWithoutOrderNestedInput
    files?: FileUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: OrderQualificationUncheckedUpdateManyWithoutOrderNestedInput
    orderAssignments?: OrderAssignmentUncheckedUpdateManyWithoutOrderNestedInput
    employeeAssignments?: AssignmentUncheckedUpdateManyWithoutOrderNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutOrderNestedInput
    files?: FileUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    requiredEmployees?: IntFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatingUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutRatingsNestedInput
    employee?: EmployeeUpdateOneWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderQualificationCreateManyOrderInput = {
    id?: string
    qualificationId: string
    required?: boolean
    minProficiency?: number
  }

  export type OrderAssignmentCreateManyOrderInput = {
    id?: string
    employeeId: string
    role?: string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyOrderInput = {
    id?: string
    employeeId: string
    assignedDate?: Date | string
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.AssignmentStatus
    tier?: $Enums.AssignmentTier
    estimatedHours?: Decimal | DecimalJsLike | number | string | null
    actualHours?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type RatingCreateManyOrderInput = {
    id?: string
    employeeId?: string | null
    customerId?: string | null
    rating: number
    comment?: string | null
    category?: string | null
    status: $Enums.RatingStatus
    ratedBy?: string | null
    ratingDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateManyOrderInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    employeeId?: string | null
    assignmentId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderQualificationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
    qualification?: QualificationUpdateOneRequiredWithoutOrderQualificationsNestedInput
  }

  export type OrderQualificationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type OrderQualificationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualificationId?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type OrderAssignmentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutOrderAssignmentsNestedInput
  }

  export type OrderAssignmentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderAssignmentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAssignmentsNestedInput
    files?: FileUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    files?: FileUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    tier?: EnumAssignmentTierFieldUpdateOperationsInput | $Enums.AssignmentTier
    estimatedHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatingUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutRatingsNestedInput
    customer?: CustomerUpdateOneWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRatingStatusFieldUpdateOperationsInput | $Enums.RatingStatus
    ratedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ratingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutFilesNestedInput
    assignment?: AssignmentUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationCreateManyQualificationInput = {
    id?: string
    employeeId: string
    acquiredDate?: Date | string
    expiryDate?: Date | string | null
    certificateUrl?: string | null
    isVerified?: boolean
    proficiencyLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderQualificationCreateManyQualificationInput = {
    id?: string
    orderId: string
    required?: boolean
    minProficiency?: number
  }

  export type EmployeeQualificationUpdateWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutQualificationsNestedInput
  }

  export type EmployeeQualificationUncheckedUpdateWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeQualificationUncheckedUpdateManyWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    acquiredDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderQualificationUpdateWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutQualificationsNestedInput
  }

  export type OrderQualificationUncheckedUpdateWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type OrderQualificationUncheckedUpdateManyWithoutQualificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    minProficiency?: IntFieldUpdateOperationsInput | number
  }

  export type FileCreateManyAssignmentInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    path: string
    documentType?: $Enums.DocumentType
    description?: string | null
    expiryDate?: Date | string | null
    employeeId?: string | null
    orderId?: string | null
    uploadedBy?: string | null
    isVerified?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutFilesNestedInput
    order?: OrderUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientCreateManyNotificationInput = {
    id?: string
    userId?: string | null
    channels?: NotificationRecipientCreatechannelsInput | string[]
    readAt?: Date | string | null
    seenAt?: Date | string | null
    isArchived?: boolean
    status?: string
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationOutboxCreateManyNotificationInput = {
    id?: string
    payload: JsonNullValueInput | InputJsonValue
    channel: string
    attempts?: number
    maxAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRecipientUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationRecipientsNestedInput
  }

  export type NotificationRecipientUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    channels?: NotificationRecipientUpdatechannelsInput | string[]
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationOutboxUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationOutboxUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationOutboxUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    channel?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}